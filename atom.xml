<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>樱の詩</title>
  
  
  <link href="http://www.sion-io.cn/atom.xml" rel="self"/>
  
  <link href="http://www.sion-io.cn/"/>
  <updated>2024-05-13T00:31:14.157Z</updated>
  <id>http://www.sion-io.cn/</id>
  
  <author>
    <name>冰川里奈</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>❤</title>
    <link href="http://www.sion-io.cn/2024/05/13/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%E2%9D%A4/"/>
    <id>http://www.sion-io.cn/2024/05/13/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%E2%9D%A4/</id>
    <published>2024-05-13T00:30:25.401Z</published>
    <updated>2024-05-13T00:31:14.157Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="1fd10544d79b7ce0f2fdff594f7b54c907c417ac119a8f5d412fe3edcf0a275b">4630436162ade97ba2718b7d0c4b3b63aa2ab1619d9cdbb4bb5fd57226dc61d2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">有东西被加密了, 请输入密码查看.</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>redis-面试题</title>
    <link href="http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/redis/"/>
    <id>http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/redis/</id>
    <published>2024-05-12T08:42:17.436Z</published>
    <updated>2024-05-12T08:48:19.919Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>redis的数据结构：</p><ol><li><p>什么是跳表？<a href="https://mp.weixin.qq.com/s/Ok0laJMn4_OzL-LxPTHawQ">https://mp.weixin.qq.com/s/Ok0laJMn4_OzL-LxPTHawQ</a></p><ol><li>如果链表的结点数量非常多，我们就可以抽出更多的索引层级，每一层索引的结点数量都是低层索引的一半，删除和插入需要维护索引</li><li>程序中跳表采用的是双向链表，无论前后结点还是上下结点，都各有两个指针相互指向彼此。</li><li>程序中跳表的每一层首位各有一个空结点，左侧的空节点是负无穷大，右侧的空节点是正无穷大。</li></ol></li><li><p>五种数据结 </p></li><li><p>redisObject  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line">     //类型</span><br><span class="line">     unsigned type:4;</span><br><span class="line">     //编码</span><br><span class="line">     unsigned encoding:4;</span><br><span class="line">     //指向底层数据结构的指针</span><br><span class="line">     void *ptr;</span><br><span class="line">     //引用计数</span><br><span class="line">     int refcount;</span><br><span class="line">     //记录最后一次被程序访问的时间</span><br><span class="line">     unsigned lru:22;</span><br><span class="line">&#125;robj</span><br></pre></td></tr></table></figure></li></ol></li><li><p>redis的线程模型？文件事件处理器的结构包含 4 个部分：1.多个 socket（客户端连接），2.IO 多路复用程序（支持多个客户端连接的关键），3.文件事件分派器（将 socket 关联到相应的事件处理器）4.事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）—处理流程为：当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件 </p></li><li><p>为啥 redis 单线程模型也能效率这么高？</p></li><li><p>第一，纯内存访问，<code>Redis</code>将所有数据放在内存中，内存的响应时长大约为100纳秒，这是Redis达到每秒万级别访问的重要基础。</p></li><li><p>第二，非阻塞<code>I/O</code>，<code>Redis</code>使用<code>epoll</code>作为<code>I/O</code>多路复用技术的实现，再加上<code>Redis</code>自身的事件处理模型将<code>epoll</code>中的连接、读写、关闭都转换为事件。</p></li><li><p>第三，单线程避免了线程切换和竞态产生的消耗。既然采用单线程就能达到如此高的性能，那么也不失为一种不错的选择，因为单线程能带来几个好处：第一，单线程可以简化数据结构和算法的实现。如果对高级编程语言熟悉的读者应该了解并发数据结构实现不但困难而且开发测试比较麻烦。第二，单线程避免了线程切换和竞态产生的消耗，对于服务端开发来说，锁和线程切换通常是性能杀手。</p></li><li><p>Redis是如何判断数据是否过期的呢？</p><p>Redis  通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。 </p></li><li><p>过期的数据的删除策略了解么？</p><ol><li>惰性删除 ：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。</li><li>定期删除 ： 每隔一段时间抽取一批 key 执行删除过期key操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li></ol><p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期  key 的情况。这样就导致大量过期 key 堆积在内存里，然后就Out of memory了。</p><p>怎么解决这个问题呢？答案就是： Redis 内存淘汰机制。（不是很懂）</p></li><li><p>Redis 内存淘汰机制了解么？</p><p>Redis 提供 6 种数据淘汰策略：</p><ol><li>volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>*<em>no-<strong>eviction</strong></em>*：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0 版本后增加以下两种：</p><ol><li>volatile-lfu（least frequently used）：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li><li>allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ol></li><li><p>Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)</p><p>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</p><ol><li><p>快照（snapshotting）持久化（RDB）：快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快</span><br></pre></td></tr></table></figure></li><li><p>AOF（append-only file）持久化：与快照持久化相比，AOF 持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：appendonly yes</p><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure></li><li><p><strong>补充内容：AOF 重写</strong></p><p>AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p><p>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p><p>在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF  文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF  文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF  文件重写操作</p></li></ol></li><li><p>缓存穿透</p><ol><li>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</li><li>如何解决缓存穿透<ol><li>缓存无效 key（感觉没用）</li><li>布隆过滤器</li></ol></li></ol></li><li><p>缓存雪崩</p></li><li><p>实际上，缓存雪崩描述的就是这样一个简单的场景：缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</p></li><li><p>有哪些解决办法？</p><ol><li>针对 Redis 服务不可用的情况：<ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol></li><li>针对热点缓存失效的情况：<ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li></ol></li></ol></li><li><p>如何保证缓存和数据库数据的一致性？</p><p>下面单独对  Cache Aside Pattern（旁路缓存模式） 来聊聊。</p><p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p><p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p><ol><li>缓存失效时间变短（不推荐，治标不治本） ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li>增加cache更新重试机制（常用）： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li></ol></li><li><p>redis底层数据结构和为什么使用跳表而不使用红黑树原因：<a href="https://mp.weixin.qq.com/s/FtfAqXXDef6-bhuGyPDK7w">https://mp.weixin.qq.com/s/FtfAqXXDef6-bhuGyPDK7w</a>  <a href="https://mp.weixin.qq.com/s/JvL2IOUu8mGLfeahHaRBFg">https://mp.weixin.qq.com/s/JvL2IOUu8mGLfeahHaRBFg</a>   <a href="https://mp.weixin.qq.com/s/gRtiSNDCuS0c8nF_Q8Tv9A">https://mp.weixin.qq.com/s/gRtiSNDCuS0c8nF_Q8Tv9A</a></p><p><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200417125108-879609.png" alt="http://bodiegu.lsgdut.fun/20200417125108-879609.png"></p><ol><li><p>简单动态字符串</p><p><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/g6hBZ0jzZb0Zb0XiaaR6bGaN80wicXIIP7Diay6tbe99SxEdCbyfMItmJNEDgxQ3iayqmSyEZ8q6IIsibbNQJtP8AcQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ol><li>字符串长度处理，用一个 len 字段记录当前字符串的长度</li><li>内存重新分配，Redis 中会涉及到字符串频繁的修改操作， SDS 实现了两种优化策略1.空间预分配  2.惰性空间释放</li><li>二进制安全，通过len解决</li></ol></li><li><p>双端链表</p><p><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/g6hBZ0jzZb0Zb0XiaaR6bGaN80wicXIIP70cib2FMf1tT2Tn9ymRyiaTIPAvY0MBsqSCSWOAujwB2tcv4ItkSib1W3g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ol><li>前后节点</li><li>头尾节点：头节点里有 head 和 tail 两个参数</li><li>链表长度：头节点里同时还有一个参数 len，和上边提到的 SDS 里类似</li></ol></li><li><p>压缩列表：由于 ziplist 是连续紧凑存储，没有冗余空间，所以插入新的元素需要 realloc 扩展内存，所以如果 ziplist 占用空间太大，realloc 重新分配内存和拷贝的开销就会很大，所以 ziplist 不适合存储过多元素，也不适合存储过大的字符串</p><ol><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/g6hBZ0jzZb0Zb0XiaaR6bGaN80wicXIIP7WIOWyzXHCzPhr4bNJzH3QdYF8R4v27XuIWCqsg8PWGCGg39lTIe3LA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li><li>zlbytes：ziplist所占用的总内存字节数。</li><li>Zltail：尾节点到起始位置的字节数。</li><li>Zllen：总共包含的节点&#x2F;内存块数。</li><li>Entry：ziplist 保存的各个数据节点，这些数据点长度随意。</li><li>Zlend：一个魔数 255，用来标记压缩列表的结束。</li></ol></li><li><p>字典</p><ol><li><pre><code class="java">typedef struct dict &#123;    // 类型特定函数    dictType *type;    // 私有数据    void *privdata;    // 哈希表    dictht ht[2];    // rehash 索引    // 当 rehash 不在进行时，值为 -1    int rehashidx; /* rehashing not in progress if rehashidx == -1 */&#125; dict;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">       2. rehash：</span><br><span class="line"></span><br><span class="line">          1. 我们仔细可以看到`dict`结构里有个字段`dictht ht[2]`代表有两个dictht数组。第一步就是为ht[1]哈希表分配空间，大小取决于ht[0]当前使用的情况。</span><br><span class="line">          2. 将保存在ht[0]中的数据rehash(重新计算哈希值)到ht[1]上。</span><br><span class="line">          3. 当ht[0]中所有键值对都迁移到ht[1]后，释放ht[0]，将ht[1]设置为ht[0]，并ht[1]初始化，为下一次rehash做准备。</span><br><span class="line"></span><br><span class="line">       3. 渐进式rehash：这就涉及到了渐进式rehash，redis考虑到大量数据迁移带来的cpu繁忙(可能导致一段时间内停止服务)，所以采用了渐进式rehash的方案。步骤如下：</span><br><span class="line"></span><br><span class="line">          1. 为ht[1]分配空间，同时持有两个哈希表(一个空表、一个有数据)。</span><br><span class="line">          2. 维持一个技术器rehashidx，初始值0。</span><br><span class="line">          3. 每次对字典增删改查，会顺带将ht[0]中的数据迁移到ht[1],`rehashidx++`(注意：ht[0]中的数据是只减不增的)。</span><br><span class="line">          4. 直到rehash操作完成，rehashidx值设为-1。</span><br><span class="line"></span><br><span class="line">    5. 跳跃表</span><br><span class="line"></span><br><span class="line">       1. `Redis`之所以使用跳表而不使用红黑树原因如下：</span><br><span class="line">          - 实现简单，相对于红黑树来说，实现更加的简单，不容易出错，代码更加容易维护和调试。</span><br><span class="line">          - 跳表的底层节点有都是通过双向指针相互链接，这和B+树一样，对于范围查找会更加的方便。</span><br><span class="line">          - 跳表的效率和红黑树一样，查找单个Key时间复杂度都是`O(logn)`</span><br><span class="line">          - 跳表更加灵活，可以通过改变索引构建策略，有效的平衡执行效率和内存消耗。</span><br><span class="line"></span><br><span class="line">12. 各种数据类型使用的底层结构</span><br><span class="line"></span><br><span class="line">    1. String</span><br><span class="line">       1. 当 int 编码保存的值不再是整数，或大小超过了long的范围时，自动转化为raw </span><br><span class="line">       2. 对于 embstr 编码，由于 Redis 没有对其编写任何的修改程序（embstr 是只读的），在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。</span><br><span class="line">       3. embstr 和 raw 编码方式最主要的区别是在内存分配的时候。embstr 编码是专门用于保存短字符串的一种优化编码方式，raw  编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构，而 embstr  编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构</span><br><span class="line">    2. Zset</span><br><span class="line">       1. 当有序结合对象同时满足以下两个条件时，对象使用ziplist编码，否则使用skiplist编码</span><br><span class="line">          1. 保存的元素数量小于128</span><br><span class="line">          2. 保存的所有元素长度都小于64字节</span><br><span class="line">       2. ziplist编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。并且压缩列表内的集合元素按分值从小到大的顺序进行排列，小的放置在靠近表头的位置，大的放置在靠近表尾的位置</span><br><span class="line">       3. skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表</span><br><span class="line">    </span><br><span class="line">13. 待定</span><br><span class="line"></span><br><span class="line">14. redis持久化</span><br><span class="line"></span><br><span class="line">    1. RDB</span><br><span class="line"></span><br><span class="line">       1. 什么时候触发？</span><br><span class="line"></span><br><span class="line">          1. 如果从节点执行全量复制操作，那么主节点自动执行`bgsave`生成`RDB`文件发送给从节点。（以后将复制的时候会讲到）。</span><br><span class="line">          2. 执行`debug reload`命令重新加载`Redis`时，也会自动触发`save`操作。</span><br><span class="line">          3. 默认情况下执行`shutdown`命令时，如果没有开启`AOF`持久化功能则自动执行`bgsave`。</span><br><span class="line"></span><br><span class="line">       2. 默认的配置？</span><br><span class="line"></span><br><span class="line">          1. ```java</span><br><span class="line">             save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line">             save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line">             save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快</span><br></pre></td></tr></table></figure></code></pre></li><li><p>bgsave执行流程</p></li><li><p><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200406210007-114578.png" alt="1586178005704"></p></li><li><p>父进程执行<code>fork</code>操作创建子进程，<code>fork</code>命令执行过程中父进程会阻塞</p></li><li><p>操作系统的**<code>COW</code>机制<strong>来进行</strong>数据段页面**的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改（因此，避免在大量写入时做子进程重写操作，这样将导致父进程维护大量页副本，造成内存消耗）。这时子进程相应的页面是没有变化的，还是进程产生时那一瞬间的数据</p></li><li><p>RDB的优缺点</p><ol><li><p><code>RDB</code>的优点：</p><ol><li><code>RDB</code>是一个紧凑压缩的二进制文件，代表<code>Redis</code>在某个时间点上的数据快照。非常适用于备份，全量复制等场景。比如每6小时执行<code>bgsave</code>备份，并把<code>RDB</code>文件拷贝到远程机器或者文件系统中（如<code>hdfs</code>），用于灾难恢复。</li><li><code>Redis</code>加载<code>RDB</code>恢复数据远远快于<code>AOF</code>的方式。</li></ol></li><li><p><code>RDB</code>的缺点：</p><ol><li><code>RDB</code>方式数据没办法做到实时持久化&#x2F;秒级持久化。因为<code>bgsave</code>每次运行都要执行<code>fork</code>操作创建子进程，属于重量级操作，频繁执行成本过高。</li><li><code>RDB</code>文件使用特定二进制格式保存，<code>Redis</code>版本演进过程中有多个格式的<code>RDB</code>版本，存在老版本Redis服务无法兼容新版<code>RDB</code>格式的问题。</li></ol></li></ol></li></ol></li><li><ol><li><p>aop 什么时候触发？</p><ol><li>开启<code>AOF</code>功能需要在配置文件配置：<code>appendonly yes</code>，默认不开启。</li></ol></li><li><p>aop 默认的配置？</p><ol><li><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200406221107-431235.png" alt="http://bodiegu.lsgdut.fun/20200406221107-431235.png"></li></ol></li><li><p>aop 执行流程</p><ol><li><p><code>AOF</code>的工作流程操作：<strong>命令写入（<code>append</code>）、文件同步（<code>sync</code>）、文件重写（<code>rewrite</code>）、重启加载（<code>load</code>）</strong></p><ol><li>所有的写入命令会追加到<code>aof_buf</code>（缓冲区）中。</li><li><code>AOF</code>缓冲区根据对应的策略向硬盘做同步动作。</li><li>随着<code>AOF</code>文件越来越大，需要定期对<code>AOF</code>文件进行重写，达到压缩的目的。</li><li>当<code>Redis</code>服务器重启时，可以加载<code>AOF</code>文件进行数据恢复。</li></ol><p><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200406214619-703862.png" alt="http://bodiegu.lsgdut.fun/20200406214619-703862.png"></p><p>我们对<code>everysec</code>同步策略进行进一步的讨论</p><p><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200414220126-329857.png" alt="1586248933156"></p><p>当开启<code>AOF</code>持久化时，常用的同步硬盘的策略是<code>everysec</code>，用于平衡性能和数据安全性。对于这种方式，<code>Redis</code>使用另一条线程每秒执行<code>fsync</code>同步硬盘。当系统硬盘资源繁忙时，会造成<code>Redis</code>主线程阻塞。</p><p>阻塞流程分析：</p><ol><li>主线程负责写入<code>AOF</code>缓冲区。</li><li><code>AOF</code>线程负责每秒执行一次同步磁盘操作，并记录最近一次同步时间。</li><li>主线程负责对比上次<code>AOF</code>同步时间：<ol><li>如果距上次同步成功时间在2秒内，主线程直接返回。</li><li>如果距上次同步成功时间超过2秒，主线程将会阻塞，直到同步操作完成。</li></ol></li></ol></li></ol></li><li><p>aop重写机制</p><p><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200414220102-710483.png" alt="1586184662612"></p><ol><li>父进程执行<code>fork</code>创建子进程，开销等同于<code>bgsave</code>过程。</li><li>主进程<code>fork</code>操作完成后，继续响应其他命令。所有修改命令依然写入<code>AOF</code>缓冲区并根据<code>appendfsync</code>策略同步到<strong>硬盘</strong>，保证原有<code>AOF</code>机制正确性。</li><li>由于<code>fork</code>操作运用写时复制技术，子进程只能共享<code>fork</code>操作时的内存数据。由于父进程依然响应命令，<code>Redis</code>使用“<code>AOF</code>**重写缓冲区(aof_rewrite_buf)**”保存这部分新数据，防止新<code>AOF</code>文件生成期间丢失这部分数据。</li><li>父进程把<code>AOF</code>**重写缓冲区(aof_rewrite_buf)**的数据写入到新的<code>AOF</code>文件</li></ol></li></ol></li><li><p>混合持久化：将 <code>rdb</code> 文件的内容和增量的 <code>AOF</code> 日志文件存在一起。这里的 <code>AOF</code> 日志不再是全量的日志，而是 <strong>自持久化开始到持久化结束</strong> 的这段时间发生的增量 <code>AOF</code> 日志，通常这部分 <code>AOF</code> 日志很小：于是在 <code>Redis</code> 重启的时候，可以先加载 <code>rdb</code> 的内容，然后再重放增量 <code>AOF</code> 日志就可以完全替代之前的 <code>AOF</code> 全量文件重放，重启效率因此大幅得到提升。</p></li></ol></li><li><p>redis哨兵模式</p><ol><li><p>主要命令？</p><ol><li><code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt; </code>：<code>Sentinel</code>节点会定期监控主节点，所以从配置上必然也会有所体现，本配置说明<code>Sentinel</code>节点要监控的是一个名字叫做<master-name>，ip地址和端口为<ip><port>的主节点。<quorum>代表要判定主节点最终不可达所需要的票数。<strong>但实际上<code>Sentinel</code>节点会对所有节点进行监控，但是我们在上面的<code>Sentinel</code>节点的配置中没有看到有关从节点和其余<code>Sentinel</code>节点的配置，那是因为<code>Sentinel</code>节点会从主节点中获取有关从节点以及其余<code>Sentinel</code>节点的相关信息</strong></li></ol></li><li><p><code>Redis Sentinel</code>具有以下几个功能？</p><ol><li><p><strong>监控：<code>Sentinel</code>节点会定期检测<code>Redis</code>数据节点、其余<code>Sentinel</code>节点是否可达。</strong></p></li><li><p><strong>通知：<code>Sentinel</code>节点会将故障转移的结果通知给应用方。</strong></p></li><li><p><strong>主节点故障转移：实现从节点晋升为主节点并维护后续正确的主从关系。</strong></p></li><li><p><strong>配置提供者：后面我们会讲到，在<code>Redis Sentinel</code>结构中，客户端在初始化的时候连接的是<code>Sentinel</code>节点集合，从中获取主节点信息。</strong></p></li><li><p>同时看到，<code>Redis Sentinel</code>包含了若个<code>Sentinel</code>节点，这样做也带来了两个好处：</p><ol><li>对于节点的故障判断是由多个<code>Sentinel</code>节点共同完成，这样可以有效地防止误判。</li><li><code>Sentinel</code>节点集合是由若干个<code>Sentinel</code>节点组成的，这样即使个别<code>Sentinel</code>节点不可用，整个<code>Sentinel</code>节点集合依然是健壮的。</li></ol></li></ol></li><li><p>Redis Sentinel客户端基本实现原理</p><ol><li><code>Redis Sentinel</code>客户端只有在初始化和切换主节点时需要和<code>Sentinel</code>节点集合进行交互来获取主节点信息，所以在设计客户端时需要将<code>Sentinel</code>节点集合考虑成配置（相关节点信息和变化）发现服务。当发生故障转移时，客户端便可以收到哨兵的通知，从而完成主节点的切换。具体做法是：利用 <code>Redis</code> 提供的发布订阅功能，为每一个哨兵节点开启一个单独的线程，订阅哨兵节点的 + <code>switch-master</code> 频道，当收到消息时，重新初始化连接池</li></ol></li><li><p>实现原理</p><p><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200418181628-819186.png" alt="1586428999785"></p><ol><li>Redis Sentinel三个定时监控任务<ol><li>每隔10秒，每个<code>Sentinel</code>节点会<strong>向主节点和从节点</strong>发送<code>info</code>命令获取最新的拓扑结构这个定时任务的作用具体可以表现在三个方面：<ol><li>通过向主节点执行<code>info</code>命令，获取从节点的信息，这也是为什么<code>Sentinel</code>节点不需要显式配置监控从节点。</li><li>当有新的从节点加入时都可以立刻感知出来。</li><li>节点不可达或者故障转移后，可以通过<code>info</code>命令实时更新节点拓扑信息。</li></ol></li><li>每隔2秒，每个<code>Sentinel</code>节点会向<code>Redis</code>数据节点的**_ sentinel_ ：hello**频道上发送该<code>Sentinel</code>节点对于主节点的判断以及当前<code>Sentinel</code>节点的信息（如图所示），同时每个<code>Sentinel</code>节点也会订阅该频道，来了解其他<code>Sentinel</code>节点以及它们对主节点的判断<ol><li>发现新的<code>Sentinel</code>节点</li><li><code>Sentinel</code>节点之间交换主节点的状态，作为后面客观下线以及领导者选举的依据</li></ol></li><li>每隔1秒，每个<code>Sentinel</code>节点会向主节点、从节点、其余<code>Sentinel</code>节点发送一条<code>ping</code>命令做一次心跳检测，来确认这些节点当前是否可达。</li></ol></li><li>Redis Sentinel主观下线和客观下线<ol><li>主观下线：上一小节介绍的第三个定时任务，每个<code>Sentinel</code>节点会每隔1秒对主节点、从节点、其他<code>Sentinel</code>节点发送<code>ping</code>命令做心跳检测，当这些节点超过<code>down-after-milliseconds</code>没有进行有效回复，<code>Sentinel</code>节点就会对该节点做失败判定，这个行为叫做主观下线</li><li>当<code>Sentinel</code>主观下线的节点是主节点时，该<code>Sentinel</code>节点会通过<code>sentinel is-master-down-by-addr</code>命令向其他<code>Sentinel</code>节点询问对主节点的判断，当超过<quorum>个数，<code>Sentinel</code>节点认为主节点确实有问题，这时该<code>Sentinel</code>节点会做出客观下线的决定</li></ol></li><li><code>Sentinel</code>领导者选举<ol><li><p>假如<code>Sentinel</code>节点对于主节点已经做了客观下线，那么是不是就可以立即进行故障转移了？当然不是，实际上故障转移的工作只需要一个<code>Sentinel</code>节点来完成即可，所以<code>Sentinel</code>节点之间会做一个领导者选举的工作，选出一个Sentinel节点作为领导者进行故障转移的工作。</p></li><li><p>每个在线的<code>Sentinel</code>节点都有资格成为领导者，<strong>当它确认主节点主观下线时候</strong>，会向其他<code>Sentinel</code>节点发送<code>sentinel is-master-down-by-addr</code>命令，要求将自己设置为领导者</p></li><li><p>收到命令的<code>Sentinel</code>节点，如果没有同意过其他<code>Sentinel</code>节点的<code>sentinelis-master-down-by-addr</code>命令，将同意该请求，否则拒绝。</p></li><li><p>如果该<code>Sentinel</code>节点发现自己的票数已经大于等于<code>max（quorum，num（sentinels）/2+1）</code>，那么它将成为领导者。</p></li></ol></li><li>Redis Sentinel故障转移<ol><li><p>在从节点列表中选出一个节点作为新的主节点</p></li><li><p><code>Sentinel</code>领导者节点会对第一步选出来的从节点执行<code>slaveof no one</code>命令让其成为主节点。</p></li><li><p><code>Sentinel</code>领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点，复制规则和<code>parallel-syncs</code>参数有关。</p></li><li><p><code>Sentinel</code>节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点</p></li></ol></li></ol></li></ol></li><li><p>redis主从结构</p><ol><li>主要命令：<ol><li>psync<ol><li>从节点（<code>slave</code>）发送<code>psync</code>命令给主节点，参数<code>runId</code>是当前从节点保存的主节点运行<code>ID</code>，如果没有则为默认值，参数<code>offset</code>是当前从节点保存的复制偏移量，如果是第一次参与复制则默认值为-1。</li><li>主节点（<code>master</code>）根据<code>psync</code>参数和自身数据情况决定响应结果：<ol><li>如果回复+<code>FULLRESYNC&#123;runId&#125;&#123;offset&#125;</code>，那么从节点将触发全量复制</li><li>如果回复<code>+CONTINUE</code>，从节点将触发部分复制流程。</li></ol></li></ol></li></ol></li><li>复制过程<ol><li>保存主节点（<code>master</code>）信息。执行<code>slaveof</code>后从节点只保存主节点的地址信息便直接返回，这时建立复制流程还没有开始</li><li>从节点（<code>slave</code>）内部通过每秒运行的定时任务维护复制相关逻辑，当定时任务发现存在新的主节点后，会尝试与该节点建立网络连接<ol><li>从节点会建立一个<code>socket</code>套接字，专门用于接受主节点发送的复制命令</li></ol></li><li>发送<code>ping</code>命令。连接建立成功后从节点发送<code>ping</code>请求进行首次通信，<code>ping</code>请求主要目的如下：检测主从之间网络套接字是否可用。检测主节点当前是否可接受处理命令<ol><li>如果发送<code>ping</code>命令后，从节点没有收到主节点的<code>pong</code>回复或者超时，比如网络超时或者主节点正在阻塞无法响应命令，从节点会断开复制连接，下次定时任务会发起重连</li></ol></li><li>同步数据集。主从复制连接正常通信后，对于首次建立复制的场景，主节点会把持有的数据全部发送给从节点，这部分操作是耗时最长的步骤（是全量复制，发送的是RDB文件）</li><li>命令持续复制。当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。在命令传播阶段，除了发送写命令，<strong>主从节点还维持着心跳机制</strong>：<code>PING</code>和<code>REPLCONF ACK</code></li></ol></li><li><code>psync</code>命令运行需要三个组件支持<ol><li><strong>主从节点</strong>各自复制偏移量：主节点和从节点分别维护一个复制偏移量（<code>offset</code>），代表的是<strong>主节点向从节点传递的字节数</strong>；</li><li>主节点复制积压缓冲区：复制积压缓冲区是保存在主节点上的一个固定长度的队列，默认大小为1MB，当主节点有连接的从节点（<code>slave</code>）时被创建，这时主节点（<code>master</code>）响应写命令时，不但会把命令发送给从节点，还会写入复制积压缓冲区，<strong>用于部分复制和复制命令丢失的数据补救</strong>。</li><li><strong>主节点</strong>运行id：每个<code>Redis</code>节点启动后都会动态分配一个40位的十六进制字符串作为运行<code>ID</code>。</li></ol></li><li>复制的两种类型<ol><li>全量复制<ol><li>从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行全量复制；</li><li>主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令</li><li>主节点的bgsave执行完成后，将RDB文件发送给从节点；</li><li>主节点将前述复制缓冲区中的所有写命令发送给从节点</li></ol></li><li>部分复制<ol><li>当从节点（<code>slave</code>）正在复制主节点（<code>master</code>）时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向主节点要求补发丢失的命令数据，如果主节点的<strong>复制积压缓冲区</strong>中存在这部分数据则直接发送给从节点</li></ol></li></ol></li></ol></li><li><p>redis集群</p><ol><li>讲了哨兵，选举Leader，掉线了会发生什么，哨兵之间订阅沟通，主从，集群，脑裂，hash一致性算法（讲了虚拟结点），还有一些不记得了</li><li>主要命令：<ol><li><code>cluster meet&#123;ip&#125;&#123;port&#125;</code> 加入集群</li><li><code>cluster replicate&#123;nodeId&#125;</code>命令让一个节点成为从节点</li></ol></li><li>数据分布<ol><li>一致性哈希分区（<code>Distributed Hash Table</code>）实现思路是为系统中每个节点分配一个<code>token</code>，范围一般在0~2^32，这些<code>token</code>构成一个哈希环。数据读写执行节点查找操作时，先根据<code>key</code>计算<code>hash</code>值，然后顺时针找到第一个大于等于该哈希值的<code>token</code>节点</li><li>虚拟槽分区：每个节点会负责一定数量的槽，槽是集群内数据管理和迁移的基本单位，槽解耦了数据和实际节点之间的关系，增加或删除节点对系统的影响很小<ol><li><code>Redis</code>虚拟槽分区的特点：<ol><li>解耦数据和节点之间的关系，简化了节点扩容和收缩难度。</li><li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据。</li><li>支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。</li></ol></li></ol></li></ol></li><li>通信流程：Gossip 协议的特点是：在节点数量有限的网络中，每个节点都 “随机” 的与部分节点通信 <ol><li>大概流程<ol><li>集群中的每个节点都会单独开辟一个<code>TCP</code>通道，用于节点之间彼此通信，通信端口号在基础端口上加10000</li><li>每个节点在固定周期内通过特定规则选择几个节点发送<code>ping</code>消息。</li><li>接收到<code>ping</code>消息的节点用<code>pong</code>消息作为响应。</li></ol></li><li>命令：常用的<code>Gossip</code>消息可分为：<code>ping</code>消息、<code>pong</code>消息、<code>meet</code>消息、fail消息<ol><li><code>meet</code>消息：用于通知新节点加入。消息发送者通知接收者加入到当前集群，<code>meet</code>消息通信正常完成后，接收节点会加入到集群中并进行周期性的<code>ping</code>、<code>pong</code>消息交换。</li><li><code>ping</code>消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送<code>ping</code>消息，用于检测节点是否在线和交换彼此状态信息。<code>ping</code>消息发送封装了<strong>自身节点和部分其他节点的状态数据</strong>。</li><li><code>pong</code>消息：当接收到<code>ping</code>、<code>meet</code>消息时，作为响应消息回复给发送方确认消息正常通信。<code>pong</code>消息内部封装了<strong>自身状态数据</strong>。节点也可以向集群内广播自身的<code>pong</code>消息来通知整个集群对<strong>自身状态</strong>进行更新。</li><li><code>fail</code>消息：当节点判定集群内<strong>另一个节点</strong>下线时，会向集群内广播一个<code>fail</code>消息，其他节点接收到<code>fail</code>消息之后把对应节点更新为下线状态。</li></ol></li></ol></li><li>扩容和收缩：上层原理：集群伸缩&#x3D;槽和数据在节点之间的移动<ol><li>扩容<ol><li>对目标节点发送<code>cluster setslot&#123;slot&#125;importing&#123;sourceNodeId&#125;</code>命令，让目标节点准备导入槽的数据。</li><li>对源节点发送<code>cluster setslot&#123;slot&#125;migrating&#123;targetNodeId&#125;</code>命令，让源节点准备迁出槽的数据。</li><li>源节点循环执行<code>cluster getkeysinslot&#123;slot&#125;&#123;count&#125;</code>命令，获取<code>count</code>个属于槽<code>&#123;slot&#125;</code>的键。</li><li>在源节点上执行<code>migrate&#123;targetIp&#125;&#123;targetPort&#125;&quot;&quot;0&#123;timeout&#125;keys&#123;keys...&#125;</code>命令，把获取的键通过流水线（<code>pipeline</code>）机制批量迁移到目标节点，批量迁移版本的<code>migrate</code>命令在Redis3.0.6以上版本提供，之前的<code>migrate</code>命令只能单个键迁移。对于大量<code>key</code>的场景，批量键迁移将极大降低节点之间网络<code>IO</code>次数。</li><li>重复执行步骤3）和步骤4）直到槽下所有的键值数据迁移到目标节点。</li><li>向集群内所有主节点发送<code>cluster setslot&#123;slot&#125;node&#123;targetNodeId&#125;</code>命令，通知槽分配给目标节点。为了保证槽节点映射变更及时传播，需要遍历发送给所有主节点更新被迁移的槽指向新节点。</li></ol></li></ol></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;redis的数据结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是跳表？&lt;a href=&quot;https://mp.weixin.qq.com/s/Ok0laJMn4_OzL-LxPTHawQ&quot;&gt;https://mp.weixin.qq.com/s/Ok0laJM</summary>
      
    
    
    
    <category term="面试题" scheme="http://www.sion-io.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="http://www.sion-io.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>jvm-面试题</title>
    <link href="http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/jvm/"/>
    <id>http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/jvm/</id>
    <published>2024-05-12T08:42:17.432Z</published>
    <updated>2024-05-12T08:48:19.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a><strong><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F">Java 内存区域</a></strong></h1><h2 id="二-运行时数据区域"><a href="#二-运行时数据区域" class="headerlink" title="二 运行时数据区域"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=%E4%BA%8C-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F">二 运行时数据区域</a></h2><h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=_21-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8">2.1 程序计数器</a></h3><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><h3 id="2-2-Java-虚拟机栈"><a href="#2-2-Java-虚拟机栈" class="headerlink" title="2.2 Java 虚拟机栈"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=_22-java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">2.2 Java 虚拟机栈</a></h3><p><strong>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p><p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p><p><strong>局部变量表主要存放了编译期可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=_25-%E6%96%B9%E6%B3%95%E5%8C%BA">2.5 方法区</a></h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p><h3 id="2-6-运行时常量池"><a href="#2-6-运行时常量池" class="headerlink" title="2.6 运行时常量池"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=_26-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0">2.6 运行时常量池</a></h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p><p>&#96;既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p><p><del><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></del> </p><blockquote><p>修正(<a href="https://github.com/Snailclimb/JavaGuide/issues/747">issue747</a>，<a href="https://blog.csdn.net/q5706503/article/details/84640762">reference</a>)： </p><ol><li><strong>JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代</strong></li><li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代</strong> 。</li><li><strong>JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li></ol></blockquote><h2 id="三-HotSpot-虚拟机对象探秘"><a href="#三-HotSpot-虚拟机对象探秘" class="headerlink" title="三 HotSpot 虚拟机对象探秘"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=%E4%B8%89-hotspot-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98">三 HotSpot 虚拟机对象探秘</a></h2><h3 id="3-1-对象的创建"><a href="#3-1-对象的创建" class="headerlink" title="3.1 对象的创建"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=_31-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA">3.1 对象的创建</a></h3><p>下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。 <img src="/img/OIP-C.jpg" data-original="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="Java创建对象的过程"></p><h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1:类加载检查"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=step1%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5">Step1:类加载检查</a></h4><p> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2:分配内存"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=step2%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98">Step2:分配内存</a></h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=step3%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B6%E5%80%BC">Step3:初始化零值</a></h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=step4%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4">Step4:设置对象头</a></h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="Step5:执行 init 方法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=step5%E6%89%A7%E8%A1%8C-init-%E6%96%B9%E6%B3%95">Step5:执行 init 方法</a></h4><p> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="3-3-对象的访问定位"><a href="#3-3-对象的访问定位" class="headerlink" title="3.3 对象的访问定位"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=_33-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D">3.3 对象的访问定位</a></h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p><ol><li><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；  <img src="/img/OIP-C.jpg" data-original="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png" alt="对象的访问定位-使用句柄"></li><li><strong>直接指针：</strong>  如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</li></ol><p><img src="/img/OIP-C.jpg" data-original="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" alt="对象的访问定位-直接指针"></p><p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference  本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p><h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B?id=%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">类的生命周期</a></h1><p>一个类的完整生命周期如下：</p><p><img src="/img/OIP-C.jpg" data-original="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%AE%8C%E5%96%84.png" alt="img"></p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B?id=%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B">类加载过程</a></h2><p>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</p><p>系统加载 Class 类型的文件主要三步:<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步:<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><img src="/img/OIP-C.jpg" data-original="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="img"></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B?id=%E5%8A%A0%E8%BD%BD">加载</a></h3><p>类加载过程的第一步，主要完成下面3件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口</li></ol><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B?id=%E9%AA%8C%E8%AF%81">验证</a></h3><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B?id=%E5%87%86%E5%A4%87">准备</a></h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B?id=%E8%A7%A3%E6%9E%90">解析</a></h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B?id=%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a></h3><p>初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程。</p><p>对于<code>&lt;clinit&gt;（）</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt;（）</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。</p><p>对于初始化阶段，虚拟机严格规范了有且只有5种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p><ol><li>当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。<ul><li>当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当jvm执行getstatic指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li><li>当jvm执行putstatic指令时会初始化类。即程序给类的静态变量赋值。</li><li>当jvm执行invokestatic指令时会初始化类。即程序调用类的静态方法。</li></ul></li><li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如Class.forname(“…”),newInstance()等等。 ，如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</li><li>MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类。</li><li><strong>「补充，来自<a href="https://github.com/Snailclimb/JavaGuide/issues/745">issue745</a>」</strong> 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><h2 id="类加载器总结"><a href="#类加载器总结" class="headerlink" title="类加载器总结"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8?id=%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%80%BB%E7%BB%93">类加载器总结</a></h2><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p><ol><li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的jar包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的jar包。</li><li><strong>AppClassLoader(应用程序类加载器)</strong> :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。</li></ol><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8?id=%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B">双亲委派模型</a></h2><h3 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8?id=%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84">双亲委派模型的好处</a></h3><p>双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API  不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p><h1 id="JVM-垃圾回收"><a href="#JVM-垃圾回收" class="headerlink" title="JVM 垃圾回收"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">JVM 垃圾回收</a></h1><h2 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3 垃圾收集算法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95">3 垃圾收集算法</a></h2><h3 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_31-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95">3.1 标记-清除算法</a></h3><h3 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_32-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95">3.2 复制算法</a></h3><h3 id="3-3-标记-整理算法"><a href="#3-3-标记-整理算法" class="headerlink" title="3.3 标记-整理算法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_33-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95">3.3 标记-整理算法</a></h3><h3 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_34-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95">3.4 分代收集算法</a></h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p><p>根据上面的对分代收集算法的介绍回答。</p><h2 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4 垃圾收集器"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_4-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8">4 垃圾收集器</a></h2><h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><ol><li><p>jvm运行时内存区域？</p><ol><li><p>程序计数器</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li><li>程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域</li></ol></li><li><p>虚拟机栈：</p><ol><li>Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息；局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用</li><li>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。<ul><li><code>StackOverFlowError</code>： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li><li><code>OutOfMemoryError</code>： 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出 OutOfMemoryError 错误。</li></ul></li></ol></li><li><p>本地方法栈： 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一</p></li><li><p>堆：</p><ol><li><p><code>OutOfMemoryError: GC Overhead Limit Exceeded</code> ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</p><p><code>java.lang.OutOfMemoryError: Java heap space</code> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发<code>java.lang.OutOfMemoryError: Java heap space</code> 错误。(和本机物理内存无关，和你配置的内存大小有关！)</p></li></ol></li><li><p>方法区，现在的实现是元空间，元空间使用的是直接内存：</p><ol><li>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li><li>当你元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></li></ol></li><li><p>运行时常量池：是方法区的一部分</p><ol><li>运行时常量池：Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</li><li>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</li></ol></li><li><p>直接内存 (非运行时数据区的一部分)</p></li></ol></li><li><p>静态常量池有啥？静态常量池包含的字面量和符号引用：一字面量：字符串，基本数据类型，final修饰的常量；———-  二符号引用：1.类的全限定名，2.字段名和属性，3.方法名和属性 &amp;&amp; &amp;&amp; &amp;&amp;注意：符号引用其实引用的就是常量池里面的字符串，但符号引用不是直接存储字符串，而是存储字符串在常量池里的索引。</p></li><li><p>方法区中有啥？<a href="https://blog.csdn.net/wangbiao007/article/details/78545189">方法区和常量池的关系</a>：方法区里存储着class文件的信息和动态常量池——–class文件的信息包括类信息和静态常量池。可以将类的信息是对class文件内容的一个框架，里面具体的内容通过静态常量池来存储。———动态常量池里的内容除了是静态常量池里的内容外，还将静态常量池里的符号引用转变为直接引用</p></li><li></li><li></li><li><p>垃圾回收算法？<a href="https://blog.csdn.net/wuzhiwei549/article/details/80563134">https://blog.csdn.net/wuzhiwei549/article/details/80563134</a></p><ol><li>标记清除：首先标记出所有不需要回收的对象； 1.效率问题：标记和清除过程的效率都不高  2. 空间问题：标记清除之后会产生大量不连续的内存碎片</li><li>标记复制：1.效率问题：在对象存活率较高时，复制操作次数多，效率降低  2. 空间问题：內存缩小了一半；需要額外空间做分配担保</li><li>标记整理：</li></ol></li><li><p>垃圾回收器？</p><ol><li><p>Serial收集器：简单高效</p></li><li><p>Serial Old：Serial 的老年版本</p></li><li><p>ParNew 收集器：其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样</p></li><li><p>Parallel Scavenge ：吞吐量高</p></li><li><p>Parallel Old ：收集器的老年代版本</p></li><li><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器</p><ol><li>MS以牺牲CPU资源的代价来减少用户线程的停顿。当CPU个数少于4的时候,有可能对吞吐量影响非常大；</li><li>CMS收集器无法处理浮动垃圾（Floating Garbage）,即第一次标记，认为某个对象不是垃圾，但是在CMS线程和用户线程在并发执行的过程中此对象可能变成了垃圾，那么CMS无法在这次的垃圾回收中将它回收掉。</li><li>由于基于MS算法即Mark-Sweep，收集结束时会带来碎片问题，空间碎片过多会给大对象分配带来很大麻烦，望往往出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前进行一次Full GC。无法处理这些垃圾可能出现”concurrent mode failure“失败而导致另一次Full GC的产生。</li></ol></li><li><p>拓展：并行和并发</p><ol><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKLsXsibtn5q5PLEvACtCkB2DVTEZ5MyRC4KnKL8uVBEoZMYFAHyle3WJA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKLd3GJNGMLYtEAXgjlU8OeNThEZyacDlkXP3mleQjhfeWic2wsWT7zElA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKLiaNovQyk5kTDpKyZY4bSJicn9HMl0OPvUWPwqmI89uicBY1LRbNNNoicyw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol></li></ol></li><li><p>JVM内存分配与回收?</p><ol><li>内存分配：<ol><li>空间分配担保（先进行minorGC，把<code>Survivor</code>无法容纳的对象直接进入老年代）；</li><li>大对象直接进入老年代，大对象就是需要大量连续内存空间的对象（比如：字符串、数组）；      </li><li>长期存活的对象将进入老年代，通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置</li></ol></li><li>垃圾回收<ol><li>垃圾回收的算法：引用计数算法    根搜索算法</li><li>哪些对象可以作为 GC ROOTS？1.虚拟机栈(栈帧中的本地变量表)中引用的对象2.本地方法栈(Native 方法)中引用的对象3.方法区中类静态属性引用的对象4.方法区中常量引用的对象</li><li>GC的时机：<ol><li>Scavenge GC (Minor GC）：对新生代，触发时机是在新对象生成时，Eden空间满了，理论上Eden区大多数对象会在 Scavenge GC回收，复制算法的执行效率会很高， Scavenge GC时间比较短  ；     </li><li>Full GC：对整个JVM进行整理，包括 Young、Old和Perm（永久代，jdk8没有，jdk为元空间），主要的触发时机:1)Old满了【1.大对象把它塞满了2.主要是在触发minorGC的时候判断老年代够不够，不够就进行FullGC，够的话仅是MinorGC】2)Perm满了3) system.gc()   Full GC的执行效率很低，尽量减少 Full GC</li></ol></li><li>GC时机-线程角度：<ol><li>主动式中断:当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起；      </li><li>抢占式中断:它不需要线程的执行代码主动去配合,在GC发生时,首先把所有线程全部中断,如果有线程中断的地方不在安全点上,就恢复线程,让它“跑”到安全点上</li></ol></li></ol></li></ol></li><li></li><li></li><li><p>怎么解决垃圾回收中的跨代引用问题？<a href="https://mp.weixin.qq.com/s/t1Cx1n6irN1RWG8HQyHU2w">https://mp.weixin.qq.com/s/t1Cx1n6irN1RWG8HQyHU2w</a></p><ol><li>第一种：针对老年代回收<ol><li>生代对象持有老年代中对象的引用，这种情况称为“跨代引用”</li><li>增加可中断的并发预请理阶段，并增加参数强制Minor   (由于跨代引用的存在，CMS在Remark阶段必须扫描整个堆，同时为了避免扫描时新生代有很多对象，增加了可中断的预清理阶段用来等待Minor  GC的发生。只是该阶段有时间限制，如果超时等不到Minor  GC，Remark时新生代仍然有很多对象，我们的调优策略是，通过参数强制Remark前进行一次Minor GC，从而降低Remark阶段的时间。)</li></ol></li><li>第二种：针对新生代回收<ol><li>即老年代可能持有新生代对象引用，所以Minor GC时也必须扫描老年代</li><li>卡表的具体策略是将老年代的空间分成大小为512B的若干张卡（card）。卡表本身是单字节数组，数组中的每个元素对应着一张卡，当发生老年代引用新生代时，虚拟机将该卡对应的卡表元素设置为适当的值。之后Minor GC时通过扫描卡表就可以很快的识别哪些卡中存在老年代指向新生代的引用</li></ol></li></ol></li><li><p>怎么排查 OOM？<a href="https://mp.weixin.qq.com/s/MAQEmIpnMMN6GGD9WbPUFw">https://mp.weixin.qq.com/s/MAQEmIpnMMN6GGD9WbPUFw</a></p><ol><li>确认是不是内存本身就分配过小    jmap -heap 10765</li><li>找到最耗内存的对象     jmap -histo:live 10765 | more<ol><li>如果发现某类对象占用内存很大（例如几个G），很可能是类对象创建太多，且一直未释放。例如：<ul><li>申请完资源后，未调用close()或dispose()释放资源</li><li>消费者消费速度慢（或停止消费了），而生产者不断往队列中投递任务，导致队列中任务累积过多</li></ul></li></ol></li><li>确认是否是资源耗尽<ol><li>工具：<ul><li>pstree(查看进程树)</li><li>netstat（查看网络连接）</li></ul></li></ol></li></ol></li><li><p>哪些情况会出现 OOM？  <a href="https://mp.weixin.qq.com/s/MAQEmIpnMMN6GGD9WbPUFw">https://mp.weixin.qq.com/s/MAQEmIpnMMN6GGD9WbPUFw</a></p><ol><li>有可能是内存分配确实过小，而正常业务使用了大量内存</li><li>某一个对象被频繁申请，却没有释放，内存不断泄漏，导致内存耗尽</li><li>某一个资源被频繁申请，系统资源耗尽，例如：不断创建线程，不断发起网络连接</li></ol></li><li></li><li></li><li><p>四种引用？</p></li><li><p>虚引用与软引用和弱引用的一个区别?（虚引用的作用！）：虚引用主要用来跟踪对象被垃圾回收的活动。—————- 引用必须和引用队列（ReferenceQueue）联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用</p></li><li><p>软引用的作用：软引用可用来实现内存敏感的高速缓存。—————- 软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</p></li><li></li><li></li><li><p>类加载机制  加载—连接–初始化（初始化中主动使用的五个点）–卸载（卸载类需要满足3个要求）</p><ol><li>初始化<ol><li>当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。<ul><li>当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当jvm执行getstatic指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li><li>当jvm执行putstatic指令时会初始化类。即程序给类的静态变量赋值。</li><li>当jvm执行invokestatic指令时会初始化类。即程序调用类的静态方法。</li></ul></li><li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如Class.forname(“…”),newInstance()等等。 ，如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</li><li>MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类。</li><li><strong>「补充，来自<a href="https://github.com/Snailclimb/JavaGuide/issues/745">issue745</a>」</strong> 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol></li><li>卸载？<ol><li>该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被GC</li></ol></li></ol></li><li><p>双亲委派模式有什么好处？1.可以确保java核心库的类型安全 —-2.可以确保java核心类型所提供的类不会被自定义的类所覆盖掉(因为会先向上查找)</p></li><li><p>怎么打破双亲委托机制？为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 loadClass() 即可。<br>完善修正（issue871：类加载器一问的补充说明）：<br>自定义加载器的话，需要继承 ClassLoader 。如果我们不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 loadClass() 方法</p></li><li></li><li><p>了解过JIT么？博客地址：<a href="https://blog.csdn.net/sunxianghuang/article/details/52094859">jit即时编译器</a>   1.编译器首先分为静态编译和动态编译（jit是动态编译的一种，静态编译就是我们的java编译成class文件）</p></li><li><p>虚拟机的参数？</p><ol><li>-XX:+PrintGCDetails  打印出垃圾回收的详情</li><li>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC  参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</li><li>对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</li><li>堆空间调整</li><li>-XX:SurvivorRatio&#x3D;8   eden 和survivor的所占空间大小比例为 8：1</li><li>-Xms5m -Xmx5m  初始和最大的堆内存，通常设置成一样的，防止垃圾回收之后有堆抖动的问题</li><li>-Xmn10m 新生代的容量</li><li>-XX:MetaspaceSize&#x3D;N &#x2F;&#x2F;设置 Metaspace 的初始（和最小大小）<br>-XX:MaxMetaspaceSize&#x3D;N &#x2F;&#x2F;设置 Metaspace 的最大大小</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-内存区域&quot;&gt;&lt;a href=&quot;#Java-内存区域&quot; class=&quot;headerlink&quot; title=&quot;Java 内存区域&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/do</summary>
      
    
    
    
    <category term="面试题" scheme="http://www.sion-io.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="http://www.sion-io.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础-面试题</title>
    <link href="http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/java/"/>
    <id>http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/java/</id>
    <published>2024-05-12T08:42:17.429Z</published>
    <updated>2024-05-12T08:47:27.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="1-Java-基本功"><a href="#1-Java-基本功" class="headerlink" title="1. Java 基本功"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_1-java-%E5%9F%BA%E6%9C%AC%E5%8A%9F">1. Java 基本功</a></h2><h3 id="1-1-Java-入门（基础概念与常识）"><a href="#1-1-Java-入门（基础概念与常识）" class="headerlink" title="1.1. Java 入门（基础概念与常识）"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_11-java-%E5%85%A5%E9%97%A8%EF%BC%88%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86%EF%BC%89">1.1. Java 入门（基础概念与常识）</a></h3><h4 id="1-1-7-为什么说-Java-语言“编译与解释并存”？"><a href="#1-1-7-为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="1.1.7. 为什么说 Java 语言“编译与解释并存”？"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_117-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-java-%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%B9%B6%E5%AD%98%EF%BC%9F">1.1.7. 为什么说 Java 语言“编译与解释并存”？</a></h4><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读， 有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p><p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java  编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java  语言编译与解释并存。</p><h3 id="1-2-Java-语法"><a href="#1-2-Java-语法" class="headerlink" title="1.2. Java 语法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_12-java-%E8%AF%AD%E6%B3%95">1.2. Java 语法</a></h3><h4 id="1-2-1-字符型常量和字符串常量的区别"><a href="#1-2-1-字符型常量和字符串常量的区别" class="headerlink" title="1.2.1. 字符型常量和字符串常量的区别?"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_121-%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB">1.2.1. 字符型常量和字符串常量的区别?</a></h4><ol><li><p>形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的 0 个或若干个字符</p></li><li><p>含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</p></li><li><p>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>),</p><blockquote><p>字符封装类 <code>Character</code> 有一个成员常量 <code>Character.SIZE</code> 值为 16,单位是<code>bits</code>,该值除以 8(<code>1byte=8bits</code>)后就可以得到 2 个字节</p></blockquote></li></ol><blockquote><p>java 编程思想第四版：2.2.2 节 <img src="/img/OIP-C.jpg" data-original="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-15/86735519.jpg" alt="img"></p></blockquote><h4 id="1-2-8-和-equals-的区别"><a href="#1-2-8-和-equals-的区别" class="headerlink" title="1.2.8. &#x3D;&#x3D;和 equals 的区别"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_128-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB">1.2.8. &#x3D;&#x3D;和 equals 的区别</a></h4><p><strong><code>==</code></strong> : 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。(<strong>基本数据类型&#x3D;&#x3D;比较的是值，引用数据类型&#x3D;&#x3D;比较的是内存地址</strong>)</p><blockquote><p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></blockquote><h4 id="1-2-7-Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？"><a href="#1-2-7-Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？" class="headerlink" title="1.2.7. Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_127-java-%E6%B3%9B%E5%9E%8B%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9F%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%9F">1.2.7. Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</a></h4><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p><strong>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</strong> 更多关于类型擦除的问题，可以查看这篇文章：<a href="https://www.cnblogs.com/wuqinglong/p/9456193.html">《Java 泛型类型擦除以及类型擦除带来的问题》</a> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//这里直接添加会报错</span></span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">List</span>&gt; clazz = list.getClass();</span><br><span class="line"><span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line"><span class="comment">//但是通过反射添加，是可以的</span></span><br><span class="line">add.invoke(list, <span class="string">&quot;kl&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(list)</span><br></pre></td></tr></table></figure><p>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。</p><p><strong>1.泛型类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实例化泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure><p><strong>2.泛型接口</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，不指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.泛型方法</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">         System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure><p><strong>常用的通配符为： T，E，K，V，？</strong></p><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个 java 类型</li><li>K V (key value) 分别代表 java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><p>更多关于 Java 泛型中的通配符可以查看这篇文章：<a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9">《聊一聊-JAVA 泛型中的通配符 T，E，K，V，？》</a></p><p>自己的总结：</p><p>泛型的使用方式？</p><ol><li>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法，</li><li>上面需要使用<T> 括号包起来，如果是用来声明变量类型就不用&lt;&gt;括号了</li></ol><p>各个符号的区别？</p><ol><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个 java 类型</li><li>K V (key value) 分别代表 java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ol><p>？ 和 T 的区别？</p><ol><li>类型参数可以多重限定而通配符不行，类型参数使用 &amp; 符号设定多重边界</li><li>通配符可以使用超类限定而类型参数不行</li></ol><p>extends 和 super 的区别？</p><ol><li>用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</li><li>用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</li></ol><p>什么是范型擦除？</p><ol><li>Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</li><li>类型擦除后保留的原始类型：无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换</li></ol><h3 id="1-3-基本数据类型"><a href="#1-3-基本数据类型" class="headerlink" title="1.3. 基本数据类型"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_13-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1.3. 基本数据类型</a></h3><h4 id="1-3-3-8-种基本类型的包装类和常量池"><a href="#1-3-3-8-种基本类型的包装类和常量池" class="headerlink" title="1.3.3. 8 种基本类型的包装类和常量池"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_133-8-%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0">1.3.3. 8 种基本类型的包装类和常量池</a></h4><p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4  种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean  直接返回 True Or False。如果超出对应范围仍然会去创建新的对象。</strong> 为啥把缓存设置为[-128，127]区间？（<a href="https://github.com/Snailclimb/JavaGuide/issues/461">参见 issue&#x2F;461</a>）性能和资源之间的权衡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i11</span> <span class="operator">=</span> <span class="number">333</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i22</span> <span class="operator">=</span> <span class="number">333</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line"><span class="type">Double</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure><p><strong>Integer 缓存源代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong></p><ol><li>Integer i1&#x3D;40；Java 在编译的时候会直接将代码封装成 Integer i1&#x3D;Integer.valueOf(40);，从而使用常量池中的对象。</li><li>Integer i1 &#x3D; new Integer(40);这种情况下会创建新的对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">//输出 false</span></span><br></pre></td></tr></table></figure><p><strong>Integer 比较更丰富的一个例子:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6));</span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6));</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i1=i2   <span class="literal">true</span></span><br><span class="line">i1=i2+i3   <span class="literal">true</span></span><br><span class="line">i1=i4   <span class="literal">false</span></span><br><span class="line">i4=i5   <span class="literal">false</span></span><br><span class="line">i4=i5+i6   <span class="literal">true</span></span><br><span class="line"><span class="number">40</span>=i5+i6   <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>语句 i4 &#x3D;&#x3D; i5 + i6，因为+这个操作符不适用于  Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 &#x3D;&#x3D; 40。然后 Integer  对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 &#x3D;&#x3D; 40 进行数值比较。</p><h3 id="1-4-方法（函数）"><a href="#1-4-方法（函数）" class="headerlink" title="1.4. 方法（函数）"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_14-%E6%96%B9%E6%B3%95%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89">1.4. 方法（函数）</a></h3><h4 id="1-4-2-为什么-Java-中只有值传递？"><a href="#1-4-2-为什么-Java-中只有值传递？" class="headerlink" title="1.4.2. 为什么 Java 中只有值传递？"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_142-%E4%B8%BA%E4%BB%80%E4%B9%88-java-%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F">1.4.2. 为什么 Java 中只有值传递？</a></h4><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用来描述各种程序设计语言（不只是 Java)中方法参数传递方式。</p><p><strong>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p><h4 id="1-4-3-重载和重写的区别"><a href="#1-4-3-重载和重写的区别" class="headerlink" title="1.4.3. 重载和重写的区别"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_143-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB">1.4.3. 重载和重写的区别</a></h4><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote><p><strong>重载：</strong></p><p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>下面是《Java 核心技术》对重载这个概念的介绍：</p><p><img src="/img/OIP-C.jpg" data-original="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktopjava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E9%87%8D%E8%BD%BD.jpg" alt="img"></p><p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p><p><strong>重写：</strong></p><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><p>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</p><p>暖心的 Guide 哥最后再来个图表总结一下！</p><table><thead><tr><th>区别点</th><th>重载方法</th><th>重写方法</th></tr></thead><tbody><tr><td>发生范围</td><td>同一个类</td><td>子类</td></tr><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可修改</td><td>子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td>异常</td><td>可修改</td><td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td></tr><tr><td>访问修饰符</td><td>可修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr><tr><td>发生阶段</td><td>编译期</td><td>运行期</td></tr></tbody></table><p><strong>方法的重写要遵循“两同两小一大”</strong>（以下内容摘录自《疯狂 Java 讲义》,<a href="https://github.com/Snailclimb/JavaGuide/issues/892">issue#892</a> ）：</p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><h4 id="1-4-4-深拷贝-vs-浅拷贝"><a href="#1-4-4-深拷贝-vs-浅拷贝" class="headerlink" title="1.4.4. 深拷贝 vs 浅拷贝"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_144-%E6%B7%B1%E6%8B%B7%E8%B4%9D-vs-%E6%B5%85%E6%8B%B7%E8%B4%9D">1.4.4. 深拷贝 vs 浅拷贝</a></h4><ol><li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li><li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li></ol><p><img src="/img/OIP-C.jpg" data-original="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/java-deep-and-shallow-copy.jpg" alt="deep and shallow copy"></p><h2 id="2-Java-面向对象"><a href="#2-Java-面向对象" class="headerlink" title="2. Java 面向对象"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_2-java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">2. Java 面向对象</a></h2><h3 id="2-1-类和对象"><a href="#2-1-类和对象" class="headerlink" title="2.1. 类和对象"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_21-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1">2.1. 类和对象</a></h3><h4 id="2-1-4-成员变量与局部变量的区别有哪些？"><a href="#2-1-4-成员变量与局部变量的区别有哪些？" class="headerlink" title="2.1.4. 成员变量与局部变量的区别有哪些？"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_214-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">2.1.4. 成员变量与局部变量的区别有哪些？</a></h4><ol><li>从语法形式上看:成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static  所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li>从变量在内存中的存储方式来看:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ol><h3 id="2-5-其它重要知识点"><a href="#2-5-其它重要知识点" class="headerlink" title="2.5. 其它重要知识点"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_25-%E5%85%B6%E5%AE%83%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9">2.5. 其它重要知识点</a></h3><h4 id="2-5-1-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#2-5-1-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="2.5.1. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_251-string-stringbuffer-%E5%92%8C-stringbuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88-string-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84">2.5.1. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</a></h4><p>简单的来说：<code>String</code> 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以<code>String</code> 对象是不可变的。</p><blockquote><p>补充（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/675">issue 675</a>）：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code>;</p></blockquote><p>而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 的构造方法都是调用父类构造方法也就是<code>AbstractStringBuilder</code> 实现的，大家可以自行查阅源码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AbstractStringBuilder.java</span><br><span class="line">abstract class AbstractStringBuilder implements Appendable, CharSequence &#123;</span><br><span class="line">    /**</span><br><span class="line">     * The value is used for character storage.</span><br><span class="line">     */</span><br><span class="line">    char[] value;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The count is the number of characters used.</span><br><span class="line">     */</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(int capacity) &#123;</span><br><span class="line">        value = new char[capacity];</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>线程安全性</strong></p><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ol><h2 id="3-Java-核心技术"><a href="#3-Java-核心技术" class="headerlink" title="3. Java 核心技术"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_3-java-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF">3. Java 核心技术</a></h2><h3 id="3-2-异常"><a href="#3-2-异常" class="headerlink" title="3.2. 异常"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_32-%E5%BC%82%E5%B8%B8">3.2. 异常</a></h3><h4 id="3-2-1-Java-异常类层次结构图"><a href="#3-2-1-Java-异常类层次结构图" class="headerlink" title="3.2.1. Java 异常类层次结构图"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_321-java-%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE">3.2.1. Java 异常类层次结构图</a></h4><p><img src="/img/OIP-C.jpg" data-original="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="img"></p><p>图片来自：<a href="https://simplesnippets.tech/exception-handling-in-java-part-1/">https://simplesnippets.tech/exception-handling-in-java-part-1/</a></p><p><img src="/img/OIP-C.jpg" data-original="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE2.png" alt="img"></p><p>图片来自：<a href="https://chercher.tech/java-programming/exceptions-java">https://chercher.tech/java-programming/exceptions-java</a></p><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p><p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h5 id="受检查异常"><a href="#受检查异常" class="headerlink" title="受检查异常"></a><strong>受检查异常</strong></h5><p>Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>&#x2F;<code>throw</code> 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码。</p><p><img src="/img/OIP-C.jpg" data-original="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/check-exception.png" alt="check-exception"></p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…。</p><h5 id="不受检查异常"><a href="#不受检查异常" class="headerlink" title="不受检查异常"></a><strong>不受检查异常</strong></h5><p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，例如：<code>NullPointExecrption</code>、<code>NumberFormatException</code>（字符串转换为数字）、<code>ArrayIndexOutOfBoundsException</code>（数组越界）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）等。</p><h4 id="3-2-3-try-catch-finally"><a href="#3-2-3-try-catch-finally" class="headerlink" title="3.2.3. try-catch-finally"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_323-try-catch-finally">3.2.3. try-catch-finally</a></h4><ul><li><strong><code>try</code>块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><strong><code>catch</code>块：</strong> 用于处理 try 捕获到的异常。</li><li><strong><code>finally</code> 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li></ul><p><strong>在以下 4 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p><ol><li>在 <code>finally</code> 语句块第一行发生了异常。 因为在其他行，<code>finally</code> 块还是会得到执行</li><li>在前面的代码中用了 <code>System.exit(int)</code>已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><p>下面这部分内容来自 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/190%E3%80%82">https://github.com/Snailclimb/JavaGuide/issues/190。</a></p><p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value * value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用 <code>f(2)</code>，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p><h2 id="4-特别总结"><a href="#4-特别总结" class="headerlink" title="4. 特别总结"></a>4. 特别总结</h2><ul><li>从语法形式上看:成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被  public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static  所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li></li><li></li><li>redis实现高并发处理</li></ul><hr><h1 id="易错的知识"><a href="#易错的知识" class="headerlink" title="易错的知识"></a>易错的知识</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%96%91%E9%9A%BE%E7%82%B9?id=_1-%E5%9F%BA%E7%A1%80">1. 基础</a></h2><h3 id="1-3-BigDecimal"><a href="#1-3-BigDecimal" class="headerlink" title="1.3. BigDecimal"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%96%91%E9%9A%BE%E7%82%B9?id=_13-bigdecimal">1.3. BigDecimal</a></h3><h4 id="1-3-1-BigDecimal-的用处"><a href="#1-3-1-BigDecimal-的用处" class="headerlink" title="1.3.1. BigDecimal 的用处"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%96%91%E9%9A%BE%E7%82%B9?id=_131-bigdecimal-%E7%9A%84%E7%94%A8%E5%A4%84">1.3.1. BigDecimal 的用处</a></h4><p>《阿里巴巴Java开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用&#x3D;&#x3D;来比较，包装数据类型不能用 equals 来判断。</strong> 具体原理和浮点数的编码方式有关，这里就不多提了，我们下面直接上实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999964</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（<strong>精度丢失</strong>），我们如何解决这个问题呢？一种很常用的方法是：<strong>使用使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b); </span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c); </span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure><h4 id="1-3-4-BigDecimal-的使用注意事项"><a href="#1-3-4-BigDecimal-的使用注意事项" class="headerlink" title="1.3.4. BigDecimal 的使用注意事项"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%96%91%E9%9A%BE%E7%82%B9?id=_134-bigdecimal-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">1.3.4. BigDecimal 的使用注意事项</a></h4><p>注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。《阿里巴巴Java开发手册》对这部分内容也有提到如下图所示。</p><p><img src="/img/OIP-C.jpg" data-original="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/BigDecimal.png" alt="《阿里巴巴Java开发手册》对这部分BigDecimal的描述"></p><h2 id="2-集合"><a href="#2-集合" class="headerlink" title="2. 集合"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%96%91%E9%9A%BE%E7%82%B9?id=_2-%E9%9B%86%E5%90%88">2. 集合</a></h2><h3 id="2-2-Collection-toArray-方法使用的坑-如何反转数组"><a href="#2-2-Collection-toArray-方法使用的坑-如何反转数组" class="headerlink" title="2.2. Collection.toArray()方法使用的坑&amp;如何反转数组"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%96%91%E9%9A%BE%E7%82%B9?id=_22-collectiontoarray%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9D%91amp%E5%A6%82%E4%BD%95%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84">2.2. Collection.toArray()方法使用的坑&amp;如何反转数组</a></h3><p>该方法是一个泛型方法：<code>&lt;T&gt; T[] toArray(T[] a);</code> 如果<code>toArray</code>方法中没有传递任何参数的话返回的是<code>Object</code>类型数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">s=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);<span class="comment">//没有指定类型的话会报错</span></span><br></pre></td></tr></table></figure><p>由于JVM优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。详见：<a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">https://shipilev.net/blog/2016/arrays-wisdom-ancients/</a></p><h3 id="2-3-不要在-foreach-循环里进行元素的-remove-add-操作"><a href="#2-3-不要在-foreach-循环里进行元素的-remove-add-操作" class="headerlink" title="2.3. 不要在 foreach 循环里进行元素的 remove&#x2F;add 操作"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%96%91%E9%9A%BE%E7%82%B9?id=_23-%E4%B8%8D%E8%A6%81%E5%9C%A8-foreach-%E5%BE%AA%E7%8E%AF%E9%87%8C%E8%BF%9B%E8%A1%8C%E5%85%83%E7%B4%A0%E7%9A%84-removeadd-%E6%93%8D%E4%BD%9C">2.3. 不要在 foreach 循环里进行元素的 remove&#x2F;add 操作</a></h3><p>如果要进行<code>remove</code>操作，可以调用迭代器的 <code>remove </code>方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身<code>remove/add</code>方法，迭代器都将抛出一个<code>ConcurrentModificationException</code>,这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p><blockquote><p><strong>fail-fast 机制</strong> ：多个线程对 fail-fast 集合进行修改的时，可能会抛出ConcurrentModificationException，单线程下也会出现这种情况，上面已经提到过。</p></blockquote><p>Java8开始，可以使用<code>Collection#removeIf()</code>方法删除满足特定条件的元素,如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.removeIf(filter -&gt; filter % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">/* 删除list中的所有偶数 */</span></span><br><span class="line">System.out.println(list); <span class="comment">/* [1, 3, 5, 7, 9] */</span></span><br></pre></td></tr></table></figure><p><code>java.util</code>包下面的所有的集合类都是fail-fast的，而<code>java.util.concurrent</code>包下面的所有的类都是fail-safe的。</p><p><img src="/img/OIP-C.jpg" data-original="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/foreach-remove:add.png" alt="不要在 foreach 循环里进行元素的 remove/add 操作"></p><h2 id="特别总结"><a href="#特别总结" class="headerlink" title="特别总结"></a>特别总结</h2><ul><li><h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93?id=static-%E5%85%B3%E9%94%AE%E5%AD%97">static 关键字</a></h2><p><strong>static 关键字主要有以下四种使用场景：</strong></p><ol><li><strong>修饰成员变量和成员方法:</strong> 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：<code>类名.静态变量名</code>    <code>类名.静态方法名()</code></li><li><strong>静态代码块:</strong> 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li><li><strong>静态内部类（static修饰类的话只能修饰内部类）：</strong> 静态内部类与非静态内部类之间存在一个最大的区别:  非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1.  它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。</li><li><strong>静态导包(用来导入类中的静态资源，1.5之后的新特性):</strong> 格式为：<code>import static</code> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li></ol></li><li><p>注意：静态变量 存放在 Java 内存区域的方法区</p></li><li><p>注意：非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。</p></li><li><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93?id=final-%E5%85%B3%E9%94%AE%E5%AD%97">final 关键字</a></h2><p><strong>final关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点：</strong></p><ol><li><strong>final修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法；</strong></li><li><strong>final修饰的方法不能被重写；</strong></li><li><strong>final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</strong></li></ol><p>说明：使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。</p></li></ul><h1 id="易问的知识"><a href="#易问的知识" class="headerlink" title="易问的知识"></a>易问的知识</h1><h2 id="八-接口和抽象类的区别是什么"><a href="#八-接口和抽象类的区别是什么" class="headerlink" title="八 接口和抽象类的区别是什么?"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/essential-content-for-interview/PreparingForInterview/%E5%BA%94%E5%B1%8A%E7%94%9F%E9%9D%A2%E8%AF%95%E6%9C%80%E7%88%B1%E9%97%AE%E7%9A%84%E5%87%A0%E9%81%93Java%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98?id=%E5%85%AB-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">八 接口和抽象类的区别是什么?</a></h2><ol><li>接口的方法默认是 public，所有方法</li><li>在接口中不能有实现，抽象类可以有非抽象的方法</li><li>接口中的实例变量默认是 final 类型的，而抽象类中则不一定</li><li>一个类可以实现多个接口，但最多只能实现一个抽象类</li><li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</li><li>接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li></ol><p>注意：Java8 后接口可以有默认实现( default )。</p><h2 id="十五-什么是线程死锁-如何避免死锁"><a href="#十五-什么是线程死锁-如何避免死锁" class="headerlink" title="十五. 什么是线程死锁?如何避免死锁?"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/essential-content-for-interview/PreparingForInterview/%E5%BA%94%E5%B1%8A%E7%94%9F%E9%9D%A2%E8%AF%95%E6%9C%80%E7%88%B1%E9%97%AE%E7%9A%84%E5%87%A0%E9%81%93Java%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98?id=%E5%8D%81%E4%BA%94-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81">十五. 什么是线程死锁?如何避免死锁?</a></h2><h3 id="15-1-认识线程死锁"><a href="#15-1-认识线程死锁" class="headerlink" title="15.1. 认识线程死锁"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/essential-content-for-interview/PreparingForInterview/%E5%BA%94%E5%B1%8A%E7%94%9F%E9%9D%A2%E8%AF%95%E6%9C%80%E7%88%B1%E9%97%AE%E7%9A%84%E5%87%A0%E9%81%93Java%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98?id=_151-%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81">15.1. 认识线程死锁</a></h3><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><h2 id="十六-说说-sleep-方法和-wait-方法区别和共同点"><a href="#十六-说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="十六. 说说 sleep() 方法和 wait() 方法区别和共同点?"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/essential-content-for-interview/PreparingForInterview/%E5%BA%94%E5%B1%8A%E7%94%9F%E9%9D%A2%E8%AF%95%E6%9C%80%E7%88%B1%E9%97%AE%E7%9A%84%E5%87%A0%E9%81%93Java%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98?id=%E5%8D%81%E5%85%AD-%E8%AF%B4%E8%AF%B4-sleep-%E6%96%B9%E6%B3%95%E5%92%8C-wait-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9">十六. 说说 sleep() 方法和 wait() 方法区别和共同点?</a></h2><ul><li>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong> 。</li><li>两者都可以暂停线程的执行。</li><li>Wait 通常被用于线程间交互&#x2F;通信，sleep 通常被用于暂停执行。</li><li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。</li></ul><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ol><li><p>String StringBuffer 和 StringBuilder 的区别是什么? </p></li><li><p>String 为什么是不可变的?</p><ol><li>缓存：如果字符串是可变的，我们一旦修改了s的内容，那必然导致s2的内容也被动的改变了</li><li>hashcode缓存：因此，hashCode()方法在String类中被重写，以方便缓存，这样在第一次hashCode()调用期间计算和缓存散列，并从那时起返回相同的值</li><li>安全性 ：字符串在Java应用程序中广泛用于存储敏感信息，如用户名、密码、连接url、网络连接等。JVM类加载器在加载类的时也广泛地使用它，当我们在程序中传递一个字符串的时候，如果这个字符串的内容是不可变的，那么我们就可以相信这个字符串中的内容</li><li>线程安全：不可变会自动使字符串成为线程安全的，因为当从多个线程访问它们时，它们不会被更改</li></ol></li><li><p>String类的常量池</p><ol><li><pre><code class="java">String str = &quot;aaa&quot;;   // 创建了一个对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   使用字面量创建字符串对象时，jvm首先会在字符串常量池中查找是否存`&quot;aaa&quot;`这个对象，</span><br><span class="line"></span><br><span class="line">   1. 如果不存在，则在字符串常量池中创建`&quot;aaa&quot;`对象，然后将此对象的引用地址返回给字符串常量</span><br><span class="line">   2. 如果存在，则则不创建任何对象，直接将常量池中的对象的引用地址返回给字符串常量</span><br><span class="line"></span><br><span class="line">2. ```java</span><br><span class="line">   String str = new String(&quot;aaa&quot;);  // 创建了两个对象</span><br></pre></td></tr></table></figure>1. 使用new关键字创建对象时，jvm首先在字符串常量池中查找有没有&quot;aaa&quot;这个对象1. 如果不存在，则首先在字符串常量池中创建一个`&quot;aaa&quot;`对象，然后再在堆中创建一个`&quot;aaa&quot;`对象，最后把堆中创建的这个对象的引用地址返回给字符串常量str；2. 如果存在，则只直接在堆中创建一个`&quot;aaa&quot;`对象返回给字符串常量str</code></pre></li><li><pre><code class="java">String s3 = new String(&quot;hello&quot;) + new String(&quot;hello&quot;); // 只在堆中创建了一个对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 当执行s3.intern()方法时</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   String intern3 = s3.intern();    </span><br></pre></td></tr></table></figure>1. 如果字符串常量池中不存在`&quot;hellohello&quot;`对象，则在字符串常量池中储存一份s3的引用，这个引用指向堆中的`&quot;hellohello&quot;`对象；2. 如果在字符串常量池中已经存在`&quot;hellohello&quot;`对象，那么就直接返回该对象的引用</code></pre></li></ol></li><li><p>重载和重写，动态分派和静态分派，及重载是多态吗？：</p><ol><li><strong>方法的重写要遵循“两同两小一大”</strong>（以下内容摘录自《疯狂 Java 讲义》,<a href="https://github.com/Snailclimb/JavaGuide/issues/892">issue#892</a> ）：<ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul></li><li>静态分派，方法的重载体现了静态分派，是一种静态行为<ol><li>静态分派，方法的重载体现了静态分派，是一种静态行为，即重载方法只关系传递参数g1 和 g2 的静态类型，而不关心参数它们的实际类型。MyTest5.java</li><li>动态分派，方法的重写体现了动态分派，动态分派涉及到一个概念：方法接受者（即方法的调用者），动态分派关系到invokevirtual字节码指令的查找流程，查找流程的调用过程是这样的<strong>（我不太懂，感觉这里没有说清楚）</strong>，找到操作数栈顶元素的实际类型，如果在常量池的这个实际类型中找到了方法描述符和方法名称都和要调用的方法完全相同的方法，并且具相应的访问权限。那么就返回这个方法的直接引用，如果没有找到，则沿着继承体系从下往上查找。动态分派在字节码中的展示状态，是静态类型去调用方法，在运行期动态确认它的实际类型。</li></ol></li><li>因为重载是静态的，重写是动态的，所以只有重写算是多态性的体现，重载不算多态。笔者认为这种争论没有意义，概念仅仅是说明问题的一种工具而已  <a href="https://segmentfault.com/q/1010000009725780">https://segmentfault.com/q/1010000009725780</a></li></ol></li><li><p>枚举类</p><ol><li><p>特点</p><ol><li>enum和class、interface的地位一样</li><li>使用enum定义的枚举类默认继承了java.lang.Enum，而不是继承Object类。枚举类可以实现一个或多个接口。</li><li>使用enum定义、非抽象的枚举类默认使用final修饰，不可以被继承。</li><li>枚举类的所有实例都必须放在第一行展示，不需使用new 关键字，不需显式调用构造器。自动添加public static final修饰。</li><li>枚举类的构造器只能是私有的。</li></ol></li><li><p>为啥要使用枚举类？</p><ol><li><p>枚举类更加直观，类型安全。使用常量会有以下几个缺陷：</p><p>　　1. 类型不安全。若一个方法中要求传入季节这个参数，用常量的话，形参就是int类型，开发者传入任意类型的int类型值就行，但是如果是枚举类型的话，就只能传入枚举类中包含的对象。</p><p>   　　2. 没有命名空间。开发者要在命名的时候以SEASON_开头，这样另外一个开发者再看这段代码的时候，才知道这四个常量分别代表季节。</p></li></ol></li></ol></li><li><p>说说反射？<a href="https://www.cnblogs.com/lzq198754/p/5780331.html">https://www.cnblogs.com/lzq198754/p/5780331.html</a>   <a href="https://www.cnblogs.com/tech-bird/p/3525336.html">https://www.cnblogs.com/tech-bird/p/3525336.html</a></p><ol><li>作用<ol><li>在运行时判断任意一个对象所属的类；</li><li>在运行时调用任意一个对象的方法；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法；</li><li>生成动态代理。</li></ol></li><li>反射机制优缺点<ul><li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li><li><strong>缺点：</strong> 1,性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。2,安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。</li></ul></li><li>反射的应用场景<ol><li>我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；</li><li>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；</li><li>动态配置实例的属性；</li></ol></li></ol></li><li><p>JDK动态代理的原理? <a href="https://www.cnblogs.com/flyoung2008/p/3251148.html">https://www.cnblogs.com/flyoung2008/p/3251148.html</a></p><p>1、通过实现InvocationHandler接口创建自己的<strong>调用处理器</strong> IvocationHandler handler &#x3D; new InvocationHandlerImpl(…);<br>2、通过为Proxy类指定ClassLoader对象和一组interface创建动态代理类<br>Class clazz &#x3D; Proxy.getProxyClass(classLoader,new Class[]{…});<br>3、通过反射机制获取动态代理类的构造函数，其参数类型是<strong>调用处理器接口类型</strong><br>Constructor constructor &#x3D; clazz.getConstructor(new Class[]{InvocationHandler.class});<br>4、通过构造函数创建代理类实例，此时需将<strong>调用处理器对象</strong>作为参数被传入<br>Interface Proxy &#x3D; (Interface)constructor.newInstance(new Object[] (handler));<br>为了简化对象创建过程，Proxy类中的newInstance方法封装了2~4，只需两步即可完成代理对象的创建。<br>生成的ProxySubject继承Proxy类实现Subject接口，实现的Subject的方法实际调用处理器的invoke方法，而invoke方法利用反射调用的是被代理对象的的方法（Object result&#x3D;method.invoke(proxied,args)）</p></li><li><p>访问权限修饰符</p><ol><li><img src="/img/OIP-C.jpg" data-original="/assets/image-20210325150403752.png" alt="image-20210325150403752"></li></ol></li><li><p>lambda 表达式</p><ol><li><pre><code class="java">//1.表示无参数并生成结果的函数public interface Supplier&lt;T&gt; &#123;    /**     * Gets a result.     * @return a result     */    T get();&#125;//2.表示接受一个参数并生成结果的函数public interface Function&lt;T, R&gt; &#123;  R apply(T t);  //....  &#125;&#125;//3.表示接受单个输入参数但不返回结果的操作public interface Consumer&lt;T&gt; &#123;void accept(T t);   //....  &#125;&#125;//4.表示接受两个输入参数且不返回结果的操作public interface BiConsumer&lt;T, U&gt; &#123;   void accept(T t, U u);     //....  &#125;&#125;</code></pre></li></ol></li><li><p>final 关键字 和 finalize 关键字  <a href="https://www.cnblogs.com/Smina/p/7189427.html">https://www.cnblogs.com/Smina/p/7189427.html</a></p><ol><li>final关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点：</li><li>final修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法；</li><li>final修饰的方法不能被重写；</li><li>final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</li><li>大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;h2 id=&quot;1-Java-基本功&quot;&gt;&lt;a href=&quot;#1-Java-基本功&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="面试题" scheme="http://www.sion-io.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="http://www.sion-io.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/hr%E9%9D%A2/"/>
    <id>http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/hr%E9%9D%A2/</id>
    <published>2024-05-12T08:42:17.426Z</published>
    <updated>2022-06-17T09:53:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-你最大的缺点"><a href="#1-你最大的缺点" class="headerlink" title="1.你最大的缺点"></a>1.你最大的缺点</h2><p>年轻经验不足、缺乏磨炼、有些着急、对待效率低下的人缺乏耐心等</p><p>解决方法：</p><ol><li>首先，我刚毕业，经验方面不足，我会在工作中积极完成工作，积累各方面经验</li><li>其次性子急，对待效率低下的人缺乏耐心，我在实验室是后台的组长，有时候会有很简单的问题他们也不懂就比较容易失去耐心，但是我平时和别人聊天的时候会控制自己语速和讲话，慢慢培养自己耐心，避免浮躁，</li></ol><h2 id="2-面试最难：自我介绍"><a href="#2-面试最难：自我介绍" class="headerlink" title="2.面试最难：自我介绍"></a>2.面试最难：自我介绍</h2><p>首先，我叫xxx，广东大学信息专业毕业，学习上我在学校大二获得绩点专业第一荣誉（或者证书）</p><p>其次，在工作方面，我在实验室实习（或者学校活动）</p><ol><li>项目方面，我负责后台这方面工作，进行项目模块的搭建和工作的分配，我做了两个项目了；为了完成这个工作，日常工作的话就是和老师一起讨论需求和进度，进行思想的碰撞hh；通过这次活动学会了项目合作，同时也对专业和实际的工作交流有了更深的了解；</li><li>因为我们实验室的老师还带了研究生，负责带新人学习，负责疑问的解答；</li></ol><p><strong>关键点，在做了什么努力这部分要体现做的深度</strong>。<strong>（利用STAR法则）</strong></p><p>（ps:最好准备一个1分钟自我介绍，一个3-5 分钟自我介绍，多手准备!!）</p><h2 id="3-面试必答题：谈谈薪酬待遇？"><a href="#3-面试必答题：谈谈薪酬待遇？" class="headerlink" title="3.面试必答题：谈谈薪酬待遇？"></a>3.面试必答题：谈谈薪酬待遇？</h2><h2 id="4-你的兴趣爱好？"><a href="#4-你的兴趣爱好？" class="headerlink" title="4.你的兴趣爱好？"></a>4.你的兴趣爱好？</h2><p><strong>问题分析：</strong>了解候选人的心态、性格、价值观、责任感等</p><p>第一，喜欢的运动，篮球，锻炼身体</p><p>第二，喜欢探店，比如一些广州的名小吃</p><p>第二，喜欢学习，在实验室呆的时间长，一起学习，学累了就去探店放松</p><h2 id="5-介绍未来5年职业规划（必考题！！-）"><a href="#5-介绍未来5年职业规划（必考题！！-）" class="headerlink" title="5.介绍未来5年职业规划（必考题！！!）"></a>5.介绍未来5年职业规划（必考题！！!）</h2><p><strong>参考建议：</strong></p><p>第一，介绍自己认真思考过这个问题，自己的规划是基于目前的实际情况来设计的。</p><p>第二，在工作方面，突出自己打算通过积极完成工作任务，积累各方面的经验，让自己成为这个领域的专业人士，也希望有机会能够带领团队，成为优秀的管理者，为单位做出更大贡献，获得双赢。</p><p>第三，在学习方面，打算在专业领域做进一步学习和研究，将实践经验与专业知识相结合，为自己的职业成长做好铺垫，打好基础。</p><p>短期和长期的职业规划</p><h2 id="6-面试入坑题：怎样看待加班？"><a href="#6-面试入坑题：怎样看待加班？" class="headerlink" title="6.面试入坑题：怎样看待加班？"></a>6.面试入坑题：怎样看待加班？</h2><p>第一，任何一家单位都有可能要加班，我们实验室的项目赶进度的时候会加班。</p><p>第二，自身的工作任务没有完成，加班是理所当然的，当然，自己会不断提高专业技能，以尽量减少不必要的加班，之前也是这么做的，刚刚进入实验室的时候我周末都是在学习的，因为毕竟是因为自己太菜了，只有不断提高才能锻炼自己。</p><p>第三，如果遇到紧急任务或突发情况时，需要加班，自己会尽己所能，希望能够尽快顺利地完成团队面临的任务。</p><h2 id="7-面试陷阱题：希望与怎样的领导共事？"><a href="#7-面试陷阱题：希望与怎样的领导共事？" class="headerlink" title="7.面试陷阱题：希望与怎样的领导共事？"></a>7.面试陷阱题：希望与怎样的领导共事？</h2><p>第一，尽量不要提及对领导的具体要求，而应该突出自己会认真向领导学习，尽快熟悉和适应工作环境，主动向领导请教，保质保量完成本职工作。   比较有经验，自己向领导学习，适应工作</p><p>第二，如果有做得不到的地方，会诚恳地向领导请教，可以在哪些地方多多改善。这才是一位职业人作为下属应该秉持的工作态度。   可以耐心回答我的问题，指出我的不足</p><h2 id="8-若领导布置了大量的工作，而完成时间又十分有限，为了完成任务，您怎么办？"><a href="#8-若领导布置了大量的工作，而完成时间又十分有限，为了完成任务，您怎么办？" class="headerlink" title="8.若领导布置了大量的工作，而完成时间又十分有限，为了完成任务，您怎么办？"></a>8.若领导布置了大量的工作，而完成时间又十分有限，为了完成任务，您怎么办？</h2><p><strong>问题分析：</strong>考察候选人的时间管理能力。</p><p><strong>参考建议：</strong></p><p>第一，分清任务的轻重缓急，紧急又重要的任务先完成。</p><p>第二，发动团队其他成员，借力完成。</p><p>第三，鼓励老人带新人，提高工作效率。</p><p><strong>Tips：</strong>实在是过重，以上方法全部用上了都不行，可以与领导协商，先完成几成，其他不重要的任务可以缓办。</p><h2 id="9-为什么应聘这个岗位？"><a href="#9-为什么应聘这个岗位？" class="headerlink" title="9.为什么应聘这个岗位？"></a>9.为什么应聘这个岗位？</h2><p>第一 ，是要突出个人经验和技能与该职位的匹配度相对比较高。</p><p>第二，提前做功课，仔细查阅用人单位的网站和视频资料，最好是要在应答中提到招聘单位的规模、品牌、知名度、规范性、愿景等等。</p><p>第三，强调用人单位是适合个人职业发展的平台。</p><p><strong>Tips：</strong>重点突出个人经验和技能与该职位的匹配度。如果之前有与这个单位有直接交往的正面案例，也可以顺便提出来，这是个加分项，说明对方是自己心仪的单位，希望能够加盟这个优秀的团队。</p><h2 id="10-面试终极必杀问题：还有什么要问的吗？"><a href="#10-面试终极必杀问题：还有什么要问的吗？" class="headerlink" title="10.面试终极必杀问题：还有什么要问的吗？"></a>10.面试终极必杀问题：还有什么要问的吗？</h2><p>第一，可以问本职岗位工作要求、职责。例如，这个部门人员设置是怎么样的。</p><p>第二，可以问公司、公司的业务、体系、行业、客户。eg：为了胜任该职位，需要我提前学习哪些技术知识？</p><p>eg：贵公司业务及战略的未来发展？eg：团队、公司现在面临的最大挑战是什么？</p><ol><li><p>实习生培养方案</p></li><li><p>表现如何</p></li><li><p>如何评价你的性格，优缺点</p></li><li><p>体能如何</p></li><li><p>用3个标签描述自己</p></li><li><p>如何评价你的年级排名</p></li><li><p>学生时代印象深刻的事，对你现在还有什么影响 </p></li><li><p>说一下你人生中压力最大的时候，是因为什么，当时有什么表现</p></li><li><p>组织过什么活动</p></li><li><p>自己相对于其他人的优点  </p><ol><li>听话</li></ol></li><li></li><li></li><li><p>有没有看什么技术博客？了解什么最新的技术？</p></li><li><p>平时怎样学习</p></li><li></li><li></li><li><p>家庭情况（父母工作、兄弟姐妹） 都想去哪些公司，假设拿到了其它实习offer，和cvte之间怎样选择 </p></li><li><p>家庭成员中对你影响比较大的，哪些方面，这些方面具体是怎样的 </p></li><li><p>有没有女朋友，家人对你的工作的期望 </p></li><li></li><li></li><li><p>接受什么样的工作强度，为什么 职业规划，长远一点到了中后期怎样平衡工作和生活</p></li><li><p>工作地点希望在哪里 居住地有确定吗 </p></li><li></li><li></li><li></li><li><p>有对面试中你失误的地方做改正吗 </p></li><li><p>分别给前两次面试打分，原因</p></li><li></li><li></li><li></li><li></li><li><p>如果你这次面试被我们拒绝，你觉得会是什么原因</p></li><li><p>有在面试其他公司吗</p></li><li><p>你会因为什么原因拒绝我们的offer</p></li><li><p>假如给了你转正offer，哪些原因你会放弃？（这不送命题吗，舔不了，说了实话）</p></li><li><p>你期待的薪资（别说的太低，显得不自信）</p></li><li><p>实习薪资希望多少，如果没能给到这么多，那你会放弃吗 </p></li><li></li><li></li><li></li><li></li><li><p>说一个你做的项目里面遇到的难题，怎么解决的</p></li><li><p>说一个你在项目里面用到创新技术的地方</p></li><li><p>说一个你们做的最好的项目</p></li><li><p>看你做了那么多项目，讲一讲最有成就感的一个 （切忌把技术说的太详细）</p></li><li><p>你的后台团队有多少人？如何评价你在团队中起到的作用？给个排名，自己排第 几？</p></li><li><p>你的团队组成，你是什么角色</p></li><li><p>你主导的项目里面跟客户遇到了矛盾怎么解决</p></li><li><p>觉得开发和沟通需求哪个更难，沟通需求时是怎样跟客户沟通的</p></li><li></li><li></li><li></li><li><p>大三的安排，课多吗，可以开始实习时间，可以实习多久</p></li></ol><h2 id="同程艺龙hr"><a href="#同程艺龙hr" class="headerlink" title="同程艺龙hr"></a>同程艺龙hr</h2><ol><li>自我介绍一下</li><li>介绍一下蓝牙签到项目？你扮演了什么样的角色，你负责了什么模块？你们团队有几个人？项目有什么难点？</li><li>怎么学习新技术？</li><li>每天学习多长时间？</li><li>对工作地点有要求吗？感觉可以从家庭和个人意愿两方面答。</li><li>实习可以实习多久？</li><li>还有投别的公司吗？</li><li>对实习薪资有什么要求吗？这里答得很不好。</li><li>第三方的合同？</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-你最大的缺点&quot;&gt;&lt;a href=&quot;#1-你最大的缺点&quot; class=&quot;headerlink&quot; title=&quot;1.你最大的缺点&quot;&gt;&lt;/a&gt;1.你最大的缺点&lt;/h2&gt;&lt;p&gt;年轻经验不足、缺乏磨炼、有些着急、对待效率低下的人缺乏耐心等&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>项目-面试题</title>
    <link href="http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%A1%B9%E7%9B%AE/"/>
    <id>http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%A1%B9%E7%9B%AE/</id>
    <published>2024-05-12T08:42:17.424Z</published>
    <updated>2024-05-12T08:51:27.525Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="3aac06cb336c710ff8cb336ccb96dafa0f3a9e5a035e77ef54cec0487d446224">4630436162ade97ba2718b7d0c4b3b636438bb933c28fae3a0e8db9d93a0a3f4c41a9ab271bcc33518724b2386fabecbb65cb1c6011989ded92cf9e99c3782ef4424ed2155f32f006fb8a01d372a05aad55fb593d3db25b4595b2ca23edc6b3ce80a0dfe934035ac82ad4ad5e51f29aa0a6e1b3528ef7257152d305148c60c7ee3637d849c451aa05655056257e215669c0a61cfaeb58ff4f350a06627d0f03fb42ce8c198bc79063d91c961567fdd977106b7ada22c5d1b86fead59244986a213da05567e4ed70efcdaa98ced2e2dba02d1fa864a3f33a5ac3b803721d34d7b18ef4b6e096695d2e4a724697969ea9f0f24a51e350e279ddb7a378d944f76e736fc94b48398c5878e1d94b674a76ad85562654083a6f1725d43a3d9fba4cbbe0ca40a41cff99baedac3a5274ea40026275814fce1d99be40bffd44cd2788e8e686e05e84753c6fecdc3bf1ded3ed42927b9880f8769da9a0926cf8dfd569c1ebe00dc9fbaa63984ba9c8bc4be9591c8da25eb795ee90bff18e161de6ebc39f011c9931ccd888939d994f5b5e44daaa8722224e48daf848e4541eaa755fa81feb77d6737e891d1b1d922d2e35328cc9c2989e533ef96411aa48a53ada63aad76e0170c59d8c230738256c4ebcdd0a0a66dac100991192da3a2c5a6fa1d8e4d881ebcc7899d8d11c9b6ef30ea708b6e2239d5a795f8886644dc5633897a104201256ecb54bd3cf1852e4b20d12837d070ecd0052bcec1b7f4c6f8dae9762fc3f1ba8abb2e296d7290f21571d2e42bdd23f242b68e7251abeb0451c69e35b4cfd676be8d120ed0e126c0e2b8794ad54c7841619886a281d9432d23e768ad504bf7f78525b3b92dc1360617440f804651171bccba0a698c22750475b9fbaa44bf86ccac6d8938479143d07db9ec01535f696d7bd57d0bedb4b6667ee2f6239dfc94df814cbb68a96dc01274b52698500d0bfc7bf979439aa93db6933d6fbbef41b7462e07e1e8b6dcdc2347faff170ec8397755b6844fd0c6e118c47063060642acecddac4af9e07fe47e2fb7d717e15f6abb6940ee777d2bbab076707d9e47f7791365cb50f30b0e8e52ee215d63e9bc4b8fc5d8dfaeb4741a874d2efcf3295cdc598237dec2d2817bf0a4429e81d175e28f58bd9d0ee8fe8bec7eb0b1fecd9247cf8ebaf7f6651501beeff3bf25b25d99d223f210193789b13b78029d8d85e68b5c6a2634a2b3d95e1f846b17bfa53e083fc8b9d2b23188ddbe0a60ceed2d74e763d394e7c0eb71d238b82d16d992c3699efe442e69b88b86fcec2c05460eadabf9863c5c6205845cdd56de4759923a24270ad5fb2d7d942561dab6a29ce7c6b5442acc371845b4374660b5294157579a7e0f5850036e9e7d84f892a06761ce200df9cf78e110bf114b153cb52779b826cd92d4b13da7828a4b202a17645886375ce50d855845db2be3cce0b1aa0b14b4599017ce57e35ead659c04da0c5f3f49790e33f6e24109dcbdf165bb5c8c1afb3d15102f3acef27c74d276432846e646ce4c62f209ee80227c7fa90cba6294a8f65907fc58a3dd99cddf80626fe459bee52c2306a31bbff02f12884b7da59c602adf457da78962e1511ab5e71730c0adff4a3ae1eaea2ee3f0fe5797f76a45d26bd041204c3d5fd68398c641e15a7f30f32d4a9069c626999a16b613aca9ab1501ea62a0c2f08548101889d9f1a64e5101e82d8f07200573328a4b9ef9ee2bc476646710a2972fd13e23dcf7d7fc13876adfab39b222df5277436e2ca0da023fd38918aa9472ead377b0825cc941543419113e6311c522b782c3d2d1dc179689653e5aaa8446f1e193e97d9f8c5c22dc40716d67942c23dd308381827caf6b2de138259a9042fe633ae2d0bb2a72009ccf4fe9067177d31958fe50aec84a60e390456c50d28f91c70fe35efb357e38fac3b61577128f0a2b5b117f4e1f0ec120dc5565fcf1d156f7758fa76f1e4397ffa759248c573ecd257c559e55dfdf831a135e9139f0efd2cf65caf64a27d1b979f36c465aa4f13d5f44283831f2ead819c702a652104ffb69b0ae65c093f2170a5103c4e5a700f00383cb6c6a77eb1327c732c067ac1b6d98bb67bffb538821c14415351d316b752a268e8cf322c2772ccaeec3c09b338fb95304d19df3be49152365ea1b752da4bae9330bd1a17a2f88b4cf15a39b6dd43fe049b78d1212d8de9cd1d288ab8bba6ffed3fb8f537680bda64963f15a5a8c100d8a72126ca2ae854d55cdd8b2ef333c6ffe29945f654e2349299dd88317060e7cd035c9d2e6bdc5b72ab6338b5f3268edb4f6e6217279dd412cf2941e7dc185e74403fa35ced321805b079c159acd42d41ffc2c2fb1158c4a3d80a766a8908331b738cf37b7535bff63746ea533ea75ca51b0c54011e024ffb477a4f1f1fcba136d0897d08c368d0237e59ef4a7db5a8f140f3579f0710021c63e1248cbab79a01f064ae6b6b90d60f85c9b8efb83154c6d17ae0d81acbc7f27432561e0d00c19faf0de45c22ae4ba2c66fd418c02a9e520060571761a54884f2c8dea470e9712553dca1963c8e1c8470ad4fb2ec07974bee42225127936fc0c3706a0892837cb92e2f22bd98f744d799b89b72033ef5c36346b3732376726a11d603087deca2801c123ac39e34ef8ff7ade61e3f1c26b5e2d76909acbef76457c1a8433390b4b867592a6e4f373eec7dea7d23d185d5538732215eeb45817a66a7cd63d9f08d7bb605bd7bdc0cd63af3486b359e878dded7ed5e1b93b6c8350a0fa80a6a66b6ec683fac078f7eaf4d552bc732a9f6f3e0a9d775a5d1abef7991076d596496b8daeba2cd1f23ee7ec1c663ce9cd4dce08a065ac35105ea95a50fe2c64139cc8cae2a8f45df90968cf966e8f3fb53cad635ee1209b9fefb2235cc77d7db022bbca0c1a449b0eba0ecf44224f8a3f92622fa4cb31fabc208eecc34f5bfbd3a199f0f952e02dde889bdeba9ebe0bc64836ac17759ae1d6e0871509dcfab39dad7a08cb887c48c550456a7f211058e584104af536d182048b8e5ff21f77c112061ec28f80de38858f1708808f98b29e1dc1eeb842c1039ab32412d2dee0439305f65f3817ced2c923f22c344f5e42c44c96270471378a4a1c8e9ae494e543f159fa46e7022234a4b2e5ed0d3b97e89947506861158f94174e15427d600ce1e01ef9dfb4db17d05b10909ed1284a2d642c85cd091313f397da044fc6d484b7ae109f001fc2ecd69d01967e6ace8aab5eba5fa8142f46a3bb1f9125062eb7ec337075aa81a377f7c5bfa31a56ef8a0afa7bfe5b967898429d66f3b530dd25b0aab01290c328dcb781122e017da7e4ba58e854da4189ab9e7438cae3c0a2593201799104b1559cd80d7dc1864f2441295d525fa7bdaf92443ab4706821c78906130c33ed9f6cc8445ca914117ca8f14cbfff1812ca96761421c953d1e7ce445725b6aa39f5fe62f24dabcd3c0fe6d577666a76d342b12e3901cd6ad194a2ab1f24ab61d72e11c8847b858e1661ebfc7de3782d715715cde05a982ae379c91972c54e05f4b6fadc949593ac73e80c651eebef4027d164a9889d2ff8a89e23775c4ad1fa29cf5b276e1d5336b813444b0d8fce64bd81b9df34e30f7297a100026bec21d96224b23243ef0aa36d49f662bea87b75f8d815b78591a0d26adc04a1a1af6ea97ec76564e3236144593a16c80bcc852076ab44ba5032473966893f631819815f0da3ec31354b53b851ca3490672f34c12379a8b3b9fb511e89ce732a36d3a0b26f746567b40dba3c86b30bc95a26b49b968a3c9525aedf2c909d2215a13482c2abdc046fa0fad9fd6e81421fb48549a6bf232b22e05e4f816bb95c1d977921b02785111f7a91da8a1740543bd93c39cb043e9bdb733fbb7ab1e49a04512885789b90b9354b46c80bae015dcff41a85754c33408f9c4daee9744d1335856808db44148d7ff0f0a32000d256e1ecf13c569c427779d4c24b03fccd93db3a2d314c19f07707aab6dd0e3889b2d1afc2d3fef16d0e064050f4e77ee2ee688dc7bdcac3273720e1d238c041bb38d3c9a54bedf04966983b634ae7063024773f5c262615cdc591c676675f00191112068bb97076ad519080803eb5cf45ebe4495a1710d19b18e7fba7dee9a7db75790d7edde6997f27c991c30a4abec062ab4e74510ab48f8b2494030dd5f6c5a47c881297e51eada7a8b2b38fc7c47eb08cd0480e41e941a2899c9dda9cf57dffbe4fbb544255bfa9de1608adf8ee5771f176b08a1b3e71e45ad798e8be19ade1b2c4d0fc3bea1fae631e8584a5833a55bd1c9d06cd773442dcaa1417eae733f201cc692d43eddc99f2087d610f2e138cee7177567ced060a9194efe8382af06f09e1d8c3b88b4b45548d2baf66e9fc0247b6b77fd1c9254988ab95448750385b1d959b127c05d695c48165ae4e68615b6f2a93409d32621e621a599a134d8d17838588da687e4cbbb5bda58666cc1c291329c099ffb9d1a3e487a45e0e3b1834e2be1529d494c23cab3e1f29e91df60097ed97fa1dbdb39faaeb53b757359e17d5476f22847832d109c34346b6a35d5ec41a1f9559f4aa9618ba95cabda1cea6cfe8280d4e082fe9f857a1ca1e19757b17290ae6a02f26dcbaae19cf375c738838e68e878479904311faf41480bb87a2c03c2f00756116060b336a2df3c03f0ed768ce11d5226987f1468372b5dc5dd30e4bed89c0c3454c47b6cedadaa39d10e9739c32ed2aa0826c7565d715cef2c901695cc11d3eb629215dcb146254d969b50ecfdf78c802d04710bae8380e1a460ae5f150cb90557c3b1debfea258887e3a5f1259fc78525dc21c81509859d8aa5fc6ed4bdde2f485022a3099ae6e3d07831915250b9f7344023f6dfe335a2805a935e243cbae349586092167621ca3b800ec45680d51cff9a664a5ac4557b8caee1d3ca9224c18c337964590505eecf1880920feefb9a373ced3761820b443005ea1a7f1ff2171d2cf8cf7dc1a157597787226387d4c2cd6e1e1c230a4c63195c293c4f11436d5492ca6c43757d7b30d6ac949941020d8aa8175f456a4abbb52a7d70f186226783487cbad4b4caab71b4cf0c617ecbbabbca4b624db195d3dce3cbc0be29249f20aa90086651b45ff49956101a8eabfc936e893eb542d596059a0cfccbe07ca0eb2ee1a4e497d7354da971d805da92cecfb4932f20e05a0d3fbd2a4cb901d417b7bdba0dd355359dd0a0208516bb11fa80faa599a85e9f2f4cd31f1755b9a329dd8418ae3a4a7d7f12f65d2f260770f76624758b18b3bfa44fca15a376eeeb2a7d6b4832e372251852512cb03c1348b7f63e5f926c2e386dc5c38aeb8a2471aa1606304dc27e580bb1a6fdf402c4d2a411b22f5775ee136911db7dec0dde1548f842b2f9aeb26ebce467a07cee62261740425866f2de7e6c585c7669246943bfb1cd22fa7de6b6d638a97eac461915d610e190196715519f86df4ed64c12a07ce8d961c95e211888191f02dcc1b70225ab39dfa7cd70d065cc4819c968b91e7cc755280535b425cef8d08c7a3db6472607df70dfb96323a57c8cba20c1e77e2b0299c8ee766e41e487ef345700e39577ea97aec3ae6fa00ecd639cbcbd6688dd4bd99a05bbab60b68f0aabb80c542eef7283b034d673b7bd9b7b4c3e7a2ca27d415b557ec14a38cccef72d4a1689fa9ebea073708f6ad642f7c8586eb1a23055280f0d023d7feeaa429d13b48aa3d930895338018b2dcb40683c64270a3cc48c5901e108235657312886a49da1adcb3d4d1029ac400ad85c34bbab9b8ac5a8d66cdf7cf1502a550d84eaf2871e2af29a779b811af60ea02c2b4f74d0c716193b6be2103f5565d24409c456e9b93db6a3afa63398f362260dc208e4652aec7ac74f530137efee6c4db9229040e049a420f49bd199fd5f365ed94413163dd19cc978b64a17668f9a6b4db92ffa03c56d4487df23a51c9a145cbeca6f89334f53c543909577f9ee489647e8f735a5e2f41bfd9da8fbb0e35cea81cb6d5455fcc907d641e4dfc9291430a442bb04aa9915a546e217299ab659ddeb7254e0fc1224ada618d88dc3fdfa9551431159a118f61eb917e3534ec0d756b590361cfc5aa3708899258e2beae207932b5d52ea3c60b273eb4d467cb5b55b0a43ea75bb3c566ad08634220dd7eddfc7996a5d3cf84f07e3689466915e6ac202e77ab9b99647eb9a6b82c44fd6f69d66be9f8da083ca95699956d6f914aa5689e390711385318f7336dcf114398c00d254305789ebf062235da9b2041777ccab47d122b41023683bd541f66c60785294ca8dac85a8acc79f4c8a2b0d96196397002e8356b2e6d5f3c21a5b88e8e2a19286d88352e59dd05bbb3a14a0fa2476355ceae24893a1ffd50308da0131040fa56656a1ea3164cd37da08133a94e2e3e26910f439e62f909342afa2452e783d9430c2e60728a06d948908771d5e0f1cb3f56e28cfc1ce81058758b3b5bb6667d885fb094b428daac7eb71c1edb6d06f0ad1a201738613f44105a849ce608867f1d33c7e25396ba99124f807c3e5d9638807adb75f2410bd7924494f6a4fa311dd892fe47c59c4c8b32fa59ef20d9d0429ea60157e8a036082271e06e4ede64e0b1471549058b45574994c99c91570d8352781da995588ea20bf7de7480714e14f2246335886686d63284c71480a651225574f9bd5bca49d17805c1212bf98857d05056109045c947911c84ca15584b6dcd08fb06e33d167c5519ce1ad97ec07e126631030a05d8af029cbc0dccf3e5475ea6ead572750fa9ff4378538ac3d6a82bc69e9d0b255c524a570e2d9f8925ee44b370eba3b8219f79ea589b03421661fa862a8fe151111ba534c0b649e753467d31b0f54553d9be33c6d25a78572cc64249aa95e80030972beaeb60fe1e86775bdb3e93cc0d47667528e2ca43ef60e11eef9a050b406aa10fd76350953a96121b649b6429765c0c660bd1fb455a24e682686cbf24d7ba80836cdfbad1f79a4202b03a4e56a7e11847fb7e249a0090540dc5add773660795956ca164352d2ba503f95474cb05032c4aba09c26a06299e5023b1fac26c68def7199079ac470c2b3623142d7f6f48b1254f145774bc089086e4aa6dc8b8c1062a450a03b591e98ce8b5baabed0544410d5e39b50ba48ad6ab237e6c19c1aee7586d07104ed97cbce2449dd37ecadce6fd48412578661df806e933a1f7667d95ac34768dbf8a400a79299c3aaf8c3a315bfae3e08401a396a80da628b6146bcf43fa20bc26fa3786520637a6e4f4995aded1b95f7099d881ff8fd6ed1058f5276bb840c3741fb1ed054d9fd527e442654f5e67f00ad718d59194ecec2427bdda17352bf461f00e30b7cb1e9fb6541a105e90ec41605b5fc19e967e41ee7560c79938fac4ea2c7ae44dbfc6fb0ac755ed33263ada700c5a5456edbcdec3faf75e2b9c9ad64bfa4ceef40a11720bec453db19962d2a4087043285830bbe633111b65200091172dd02c06cc64221104383a9d1f0f0231313877397e9be6c311ac2b9ffc31973a3abff0680ad6557b096165374e96d245d35834a7c189e9ac61222b44f073e9c03ca12a2b51ed7de7379ff4fef24fec569ef1b5b5460d106b4ed18595f74b08979a987eb27bad78ff1b6c3994552aadc119af53266c2899264827c7cd347172e6b42aca37367eee09d63c0471e527565db7897299a1d0c0f8ac80419ab3ff5437547a6d0fbbc1487dc687a46051c0c33b06609898f70efdd1d91cf5cc5db22484a05959a31203b33a5b371883bcb509035ba7f1e0435b9b241bff869f26352e48faf9eddb343c864cd2d2d290cd191dd1a975e26d86a0b7ccfb2a91a50d0222cd135d9a214fcb27d17ba1090f65fbe3c6beb1fd27f139f69245779bf20f4381b82a05779fb89bc08c7b51a1b5e11b03dabae1bc0a0288f54075a797e9b7cef33b01f1203378a61e1eaa360ff49b79b6372836cd4a65260587435a30e67d4fcc36303a10ede3f24dd0aa6474043f1f45c5f9b71db828d1eadea2c6dea94b9e0fada2e99ef86a2d977ccef5f52444a79033c57be80bdcb33ffcac25b2359869b5602b7f7738388b881a5816c719dba8ac2cb398d90b32476579c538b2310b811868d62ec72ea0c1c34ac7d18a7a8d3d48ac15c6e89d0eafbc51d7c672734134984c8c71f9b4d04de2961df96d5831b26234049e6579ec9f25150651a08bcc93a1a0b9e6c86b184ae83d7f5067ab6b917ee5c28d9a69a753079b2298a02c9daa73afede4a19ae1ef57e07fb04e6ad6305d65ee3eab5c418cd99d78a6a76589079e8aaa54bd6243db89dc8a7f7e83c1e20f26031e1dbd3ed5677ca11679577cfa98b319ba78e7bbe37e70b78af595d7b3f88724a11aea2a5dfb57ea59e00161878d773c87e0f565726dc8004cc2fd09a47be59f203c39745ab9b2d85145ba9b004117bf31da53b09d0b84581b0fd801c0de6bbb52a4db12c3d86000df0f2809ae4561ca5c6ca5af4e36ceb636604466f35c7a5298e5196fee42ed65d73c8ab0cdab79def4eb53ffee4b0aed275b98ca4a49ac7b5a7484df731f543bcec888526e1993894f6adaf64851f40bfc2393f51259049253c891588541d1e37307ac0523032822f28f96302358811371ad291d584ad9b69ea1b694b302b735a2ca82e914ded78796e7f7248b15a9028c9a298f9f60d27db4b81aa0ef9ae9498ba533f9fd476506899ef2cbe2275fe010087bb524ec061c30a786966f12ca5dbac8f49a2a69abbce4e733f9180a87c3e1fb26d368370c4cabda247c53dfdbcfb85df92b26aa087e899252ee51c39aefd05da9d0f153ddf28be47571acb58de3555da8958d03192bcfba4bd314bcffd4a7049e2cfdf86169e4f0cae337a993a2f7bac79156a5214260c51b66d7592f4bd52aac3407c39d5fb63167de7a40313eaf0df2618d884a049c62952a683559baa8c951337dcc7019c30be15bd936ea40ccd61dc51f43be83d89a7e41c03275b3233807ea80d5ebd3ba10755845617f70ee66b9ba80221648f3b714359119d388f053e59eace4fde5244a99a263f223d8476362d4313328b5578a5480ba0ef2aa8899d3e3f94077108e181992869a643987cb9d87c16eb8f42fa8bb7b34fcab9806d06deae8dae4af8d0a10b5c85e97c85166488568822d54f1862a9087d255bf18a87a059fef5d4efed12ecb73afd8015141c8d373356ff6de7325f8f012987a18738a9c9290b586f622c9b8046f46a583ff5381666ee59a64df736254c6363a1036fc77028c33c70832d24288bd513fbad8190533ef1989ddc2da6d6f625dc3a425b38dabcacb9c194dc76d91008d5d85f9f406c296ea2646f6e0e65fdaeb50777030f3715d8c7308a2d41168b3ad483acc9b79903f1140ade6237eae2bae90b5c7ce6d95641c05d1b8de89d4733eb36bc5d416cf12df8dfb190789c806949aec297aca76c2f73909bcbbb212b7c5fc0f166f6837190cd21b4761bdf0576dadb9c26c20a97cea4c3ba7196f01f9239b4ea12b2d2ce1ab466deadf8f2e79fc204284583ed22d5bd240b284c0e9532fc915799ba26f72ae646a1bebe69d4d3d6c0c73ccc52facdfb2fee7c4dc0938ded6219085263ca884b27a449c03a7156ccc681ce663c781cb0a925303c109d3e59b82d739ebd1b3eacdad29481306111e59527fa038f3ad2e293b0fcdfbba6bb765edb485c6ab587184cf14531725a85b8a11de034aa7ecb28da378aaf3b6eb03568130b9e6089f741eda735590463c5f103b4f716195ccc74e53910494d685a8bef3aeeb6f7d942d88ef65921fde2bf12008601678d4ad3141055cca1707701bcff91ed97ad4802ba1f6494f682fc784c7a9bd234b03712148f4a58d3ffbfa8766cf423345f53d7bc82d875e0bf59cbfab4e7e087ab02977073efb6fa5b5b8eecde1785f240afa63d616428eea90b1800e8384d4a28a5e833145b032becf9ec9c258c38ed3a41d6f8cdb0ab259fef0e80e8a7fe3a5d7fe474618b2b5c8b5b6a90dbce62e82ac61f90c0848c0d0285dab26c59fd9ef8cf2a56bc4f27054f9d01311adfa4f4309fe3ffa36c50c6d5596df01f75900dc1b3df2eccae8fd079b4592f627662809d927614e74bdf6a42c8ef0cbc13fcfa5aa9b902a247b65083cc0a3b40b23381a66fd86883afe978629206846c135d756f168c3da5df17d16ddff609784ada9ccc2e17896badbffb0b974b5f5e064c0ab424472f58da9b08709f1bb0a18efc3c76aa6dd052afae65e2ce3fd1679df37afdf962de56dd760088586a2715b17f3dc9ddd14d4e551c2626725b84ce61073d5035a1e87c20a90815aa80f26ad22a8234c755cbae0bf556a1fc601c25d57c3478b4a5a7f24dc5eb2a8e5795bc5d7056e77d8fbfb7c505cb087b73ce326f4b0ae17a3ea014bb780ee4732098be1376c0f2a2df03ada5ff179c563626a04f9fa3af3e36c50e7437a2ffe8d9681775b1af0e2b6ef8f0d874b61f0a3ec3d75c8db7d43f98a243704c556e05cea00e78de705793f527b28d14eba565eb0ff44a059d4532182fb53cd5dabcc1a25d3ff953f2b57a6faafabacd5bdb4a6e57e73818594a6af11dccd73285be8d4cb5a671677211672bba5f33f8a076924425d0102ad6a0721dfd659edaf41503d923854690f058fd3a5dc999d964da3d58ca91c54c6eddb72776ad275a49dc8bb34770819cae57c8b12884f2dd038697dbf9484838989a15c85a1117f71577e6d0c4349c83ba6df7698ac9db95493ea1aae4e70cf51589d615b3aa0dc8bc22daad47ead8c72e274dfb06d4b5ee33a7315ba724d1dac3aec40659f352158054fe495f04c5c28e33a81dc8e27186de9d999dc7a3e524c358b422d0276537814402d17323ed3c94a0a8a15c4634b91c45ab47accbc6df14cd72a418b610a7e53a7c276c3d4d31c323cfc7989ae8b99786b17154c88d679580fd2d15c75b67fe2bdbf08397630f6a565a6915424f4f4d26ec68efcffcea9e8798b86e15bba8156fe2ae9d173e35d874732be06b39a6c3a75b5d677a9178c0825b36882875384f59d3a4e78b4af45c4c0a7dd2e6751ec661640394dddbfcfd1f6bc2096a1604bb5cdb97ff31fb1ffc4e703b9102ee42df5079d0fceafb29ca7926df6d82585863dcbbb6a4c102c8891aa55acea925b00bd1df9a20a17c0bb9026fd7abe155757ee6226689eb2542a6f8ec67a3fae3f1c0f83a7e266be420a8e621f1aa9b278be497a9c165bd4c2ba415489334ab4a0040a054b2bc05ffff6db3db73f50e575c038e5bbded81e305d746bafac9460163c2f38dbd9b2269876e3ee89dd924cb19900f2f9c6ea8af474204c4d45d33b3973e7b6cfd721203bae3920f1a02f16607d7da32c77f60e8fc35bda9bf3397ab2073031261f1aa710b569220f8e50b23a0c3dc847a580de52cc4d2792bf7903f30a718abb3a9547141e5b311861ac464df5562caa1b33b3a2d6d0900ed011ff0b2e4de896ac2a391ac40bbf61599e96f66984640aebd7badbb7833a9a0b61fc19fc24a2ab170dde1bed564af0256ec4cd68eb43f0af475f285039aecc56361ed38c8c09faaf255d9d2be65cc486aa187b8a7a420946182576a7fcc607b91f237b4e0981ceefa295ae52c752d19341965829acd5fc44c21d24bf86b63eb0f6c13f9bba77da98ff7a5faa3a4be5fe7fc86fca1b1060a2b50f09e89e03db762186c71d5561ab648550bc4f20f9460b9c1b3b1115c0dc787ea96229404eef430d48598ff7109c66c9335849e4282478801e7697fe5e91a1888e61ff05fb14969cfa0f6c747de5b80ac959340f6707f8e917c703e4533202ce60b6437ff40bbefc29e2647d980e9b9a1bf5009e9d66dcebfd853a75e5314a3471519e2e97f39fbbd1f7658b7a95738b530766d1836e3be63ce1b9d6b5440d231b4d0422ea6a45d2e491c26a934e8614105ee06341235718c5c1cbaff6faa47108f5e912bb9e9c30be394f982c7e17ba2fa2f84fd950bacce10feaaa5c7c94c7ccf2443f036822d02aa25d75d86918134b640c9fbc829eae7df712337ab83d7e35728ebfc0875216df293eabd458777f17c58b3abd4d4fe0afa532810f1004ab4941ee4ae5223e9c4aa06f60e22e6e4b55fb1f45b8cfdec920a24bf88b6206484df6f59615c477548941c6f05042a01cc49d4bf6671ea4ae114182ba32e3103cd91089760f17296746f00ab266568af0fdfe27b7b732fe490da7c0570579ca888b8d7246618fd2dcc5323827632008a9147bb8490e968092a6b83277ba1dbfb3c00c1c11b069b69499cb72e5923d18ed4013a37a577a6539f6b5df435eda0658901fe2b99b4b74a0ec195f170db931c30e4c0bb327cb330ca954b68417eecb82fa7bb830cb19f320149f276b506eeecd4ee637f5b30aa312929582a8cdf57584eb6a57e3065420050de53d0d9e9080f8a6037a14cfc0149222d80d9d58fb311547cec5cb4fa9574f1f269522ae747c9d35879b7a4c0eec7b6c376d93113865f5847036ef868c29a295d88ff10bc427f455cab3a8fcba9bb83db7da961c4af925763e82b6d7e2e14a032c33f09d498d2c63e090f6374037facb2b993adddafc0d8b0febebfc8031c595bb3b9ce44ce773eb0dc863ef78cdbc9d0327fe32dc36b42dd63c4422625b526770f288d023e52db12a457d34c2167f18a31a756bdb1e1c2d75ea8aff14de5058ee1909a386433e8d3d924faf4c7037e8a65f10c9c05a63bd686cda8e91505854117b0f333e6a87765a09a899fe4930f7a263de8ad6c997df9b5bd4bad165f73c5c0f7d5674db4e2144b8031f6223c62bf7ce37437679f10b7979bfda1e9fd4758662a24b7bc19d515bf6c33594318035866ec88cc9b7137ac97c390d0aec7d93716ac63263b05467c485744f419015abcf2915a21025cc5e40281a7a707c62bd35c3373cee88f8465b75f36aab7c390d1c21f8727cba94aac7eda2f1bb527277c1dd4c9a73ba4867eec2c78abdf3bf9948287472c80fb1f1f60f955b15c72fa3eef636c4ad6a0130e4cf7c8c6d8f6591c4c17f2acea6a373a0ee12f72753bd93bfbb61480bf82e5968f16c20e0eb8e28370f9e94a9206d42da773f4010c49ef7840879c460a91e0976633eb5a9cca19c75c2a0a6f252c7e5b18eb3246f3b0d4711583a7bc84459a133f2c8e226c6c29875f9f8addf52c1b94398b8d13ae8b1492c400faaa96f51d8f7a761105f994094cc6f82de899f0c8a8e67b30fa04c4f7671838da7ea4e64b1dbdca23b683c09737e257cab3e7ddfb753923d3496480e7108892addbeae213d8c51e1181038056b260cfa64e06794ac416d7242d720f0abacf695a993ee6b53505fc3f1e7cd57a309961020a52f576eb68c716923d98bf6e0ccfadabc72310e4c3c4065c0892c0ebf8bfd30a0e6aec1f35242899b72c656f19e65c6c8a516a3576a0311f980e0b066b0529047b829a7983627a83c32f929314ddbd78092586989b014073929e63ae0ca02c986a5aa994fdc9e0a83d5cf1da590a118a0c5fbb2b4d8fda41e7dda7d648fa9cf8a5692f25b896e342383b94eef99c421b35fd79fcc01a1c021427dfc48086150f96d475d4a0a1b3083bfbe80ffba47acdba15fc14fa99dd4b415093a6a8e474d994b591a44b87c8fe5d600c66c010e72edd08e0e7e899298580d7a20059f622a972c01ac11a2a5a6cf78f04c8ab27a2db907328f568ad59702144dbd52a4f80a80e159f25b3cc6fb06c87988188703db8cc396b801ca5c88ca38acc50640c8acdf7987b41731067a0b397bf069267cfe5f23bc73f397530ddacab91381c52e89a5b52a9258492f479a02e127bb63c3e2cf3076af2ed34d649b53381d3ac31688c2ab8b76ed9e64b164f206ce6ef352051a1b35a47a7409dc5676347597b44e01a85b64a54827ae199f6bec1edbab05d48d125ee28f3caa0a9cfab90cf2a65e559f9bc740021216117757f5e67aa64d13b153cb196c5a943094281178d2565a1dd6ac92bcae81f60748fdb2a30e217782e742eaae083d4a0b3a683f2fe20532a05440bcd1348e5b606379b6f443dd725f1ba43faa75fa79730c14add138870513a8f0132ae7222c9fed49b0a25fc786dd5a179761a0da1a15811d6a48e1fe4516b0a557287ecd6410a4e9c07736c0fbf6bd829e9058c605ec285f9bf6961ae9e624c16939607ddc47e2b25ca26efd092e6f43e0bb67258aff98e1b7beadab659e92937f1b46def10bcb2d36a98dc8b03eaa74d593ac37c7c150dc0f24af1ad5f8aab6895a9a89ad1c213e28e7f365cdf7c671d6894714d64ef2a86eed120919906e4b26a1a8d3477b7721074ad9fa5adc2b79fc392afa135ec8e131cb261753876e5e31f07fb1c966aa9a95fd81c629fcef949caa318e331c7627af31c30a4242aa4fd6e8a5a4c15e052f1ffe59ee1dcf47de8a845ab19d2f5e40dec2bb3cedd3cfe92b380c28c8c607c0bdd66a7411d038c2fb21466583f064e96d6920c5e4c79586855521fc805bd2bf12f99b8f0fb1b3f8c9347e5df3e037bf1896bf50ea146ae4242424bb58e5e1e0dfa6ea7ba1afcdcaef5f96809ed21b98ebe5cf7eb2db4bcff16b64c39738d370020f53b0f1d6b6955f25df870a14a67513d7c74a6c67b2d15a76f7866e787fbcf748893b1e3036918c48ec20af636f9d2eafc8d877c6070c795be3d270104d3b0ca3b6f19b2ac925a2dbe856efc4eda80f2886558d345160038315c8ca0fc8830175d79266e6a2291556b6e03af74bb76559c7f14cd8615065d3d92a34ff5a432f2a31c672820d401081754b062446fbe6426f824e048bf36a3def5eb63f917b731d981949a6f29f57977bd29908566c461533297a6d9b9e2b17efe8982981825f3972b204a3c2549e2f39f5af91412444b496c79c991b1def37f548de0ec3c41e85baa4fc02403d041c7ed4e02aeb48e2852434c7f5bde7365785faec3fad97f39919838a04917b24b9ba010cd504fea741b15ac2bad9d374efdb372b2e9df54b3535c2fbafbfdc92d612bd82a36982f15d33a980c20fe08f7101c125927f2ac783056574cfe72da91540188778fb1d1cef9d2ca8ecaec55c0f662c948e0a50fee1dc2dc913f0a48926d94a0ba83efcaf99e694c701344cf742824e975b1ff0dbea4cb9785d42a26557b2c7a8eb043f2713ed8a9c5e8a4f2f8ff462c7c6b06178102105d3ae34751f9e7e7f27b933b732b9055e75fb563bf693c6425a1d23dace74adf6d300c2ff7fc3812bcbbd4592c6e1882028ee7865878d326d0d90f09e46965efc01fa2c1f5564ffc4b97cd47c791d90cdc48b0273d11d97620e5269d9e1a3591f069ec5e5ae6c0266beb8e065d850e8928f3a8bf14a19caa32b29d47355bbaec78bc39b751efaf911d5c23745c4327d1a3fa47ebd39b3d36c0743062a323364092528cc1bd3447295cce3d8078011a5ea33e24a98d21f94134bff5abc37af9385199382bed8e921e1bb317fec67d50e6853c07d5697d122c766a5bdeaa79ffe1785e9b46e609b9191158e785190461c4d62c62e2fac70d20666e90b47d5b07a8cafcce38c11c6334b06df0e35c5aac21b5e2b324ae8da4d055963f041fe04a8f2bd69a28f2c2ad0784193cd1e1be388e0e46f0386c7342e0e53bb753836980e7fefc59ef49480c24ea0de59d435e2bdff0e71745b1b28e372f8b20db89089c19dd25d423eecfd6591a3d752795f58c44af1528acd065fafb62e8ba536a9d61c915054d33741eff2a42dca3e1a1812290d8319a08e96333e4bb50d6d04dc5cdf1025315088332145152889971a5460e079d75fbc23b775f1db87d45b626d2edbc6a505ecc5818eb1f6aa81b060691143f471d5e084e955aa0f36d46c2b821a639258eb9351847867a19b0c030ce7abc3336765d1151c33f54348b744a1be4e0ac8a488f35f3c0382564fa7bd5281382c615bcc219664c79bd0b5f97ef1f144e0562a29d7b0193fab19bb28051fc34cd0e5243e4b431878b30114aaaf97e00dfac5ff81bd7acf574524c24117fa41588f56d4b3599b8be48e767edfa43afc2eb2dc3c8e22b072cc00faaf9197e55696a6b05352f2102cc828f352e76d066c49874d65fc49a8ce19426504ed5c651869b86c40391d63b5cad4d7b09114c56cc956a10f95a4201a62a1cf2a08c8dc764c63e90136ab6e02211e7f677419fa835d36550e3bf692509789a8cbd325c7a9c6c191a460a4bb1926d7ae6e1faec713a36a2af8929fee7bb515267da0f2ba97ce04b871723e2b5bb7463b27690b5df16d0f0e8bf44198a53cb0fd104283cb00895020c93013c25d858a57ab09b6c1cf76d90c61998ba87c8e89921e625ceb38b3cecf95dd4adffacd2f42ced0dfd7168159f1f8c8e2d110231548bd9cc8ac26be5ac694755a41beb00c72b5f6b9b65a63e295c450dab4ce4df3f82b05cf6c8e8e618b5ff4ee036d13546265d528c20653f49827f850db7a4c84a1b7a0af13352950504f9c50ef4fc059135407902c27b0e7bdb86e191b5644c93b65161c771acfabdf90cd3747b035398308bc43b3309381bd527ca67eb4571cf16e21b6b4535d1d31cfe775ff7edb66aa0e3f87cacc47d37f5da39a00e5a219561dfc1f0a66da553b3afd0cb36847f0fb5a01bf11d5f56287e3e88c7479f66e012073eab757ca9266a6fb19bbbda09145755600de3d524025ee563f21a708728477ca8b8278bab7f3af254d3c71b77f56bef5b018bf156d321fd672eed7c14b595aba31f980193d5058262f07c898b6802405c79873eef6caaf827c9117c44901a5727de186c5871eed5de6f57ca0a48ea139d881c96b4e74a4c609498daf391a9a02cfa4517725acd0d515f51267aaffe4c98deb82805ee053f0ac5c5ef7c88812d52d61c6114c8888b15d762e9f46c84be2353a0c6121a5cb6ce6baa4b9f600b8b03bda4366040e50046607cfc43671298a94c535118b6a3479b7ba7534f25cd90cddbe8933c5908504e0f5e328abf4d56640bb28736b29e3ccc18aa70ac9c9fc18b5c67c84cc7814d12fac5e74abfcabd625e61455f5b7995e7944890cf9c416ef060d513c8931c3be5e76267c6be16fdd50652dab6719b103f54376889c6c59ba8bc8aebf9e6a0a122fbdae0a224dbfedc154cda3aee08fff85302ecc95470367e4966f7e50d9dcc6b6492c95a003ca211286dad8b4d16efe9288f5695eeea1425324ba5139d241a713f48eb21511448aaefe95de3d3a16b74405ac4cbada5e0da3d5b29ca46c64fd4bb6ca378c03213abc7862192482c6e4c1edd5fc6c084276e7fe001ae6090772146acb88bb960ae71408a8d5e748632d37c19b41553588ccb8bb228142a2c31a621b9aba2a19ff4c46ffc49c724cb4deed33ef79641351220c8d8a8740059fb77b04ad528fad935e35a118cbf5b659a9b4b9c3be19b6a8d86c2b3c7e8f0b82ea9e98b4734216ee05a35fc40a7906ca6141d4af8328294c2e5454e49185ff54f4b208dbfa3c0a99165a55ef13ab6f15bb3d44340347b2dcf7be1011c03563e0a79698fb27ce2f1b0afe9ab8a57203fc0c81061219e9e990df6ad1816043e8573e81677ecd02a6cb8099479aad1afb0a1b46a94b4260cbca45cf5a0a3798fef84459ac63737f3e4f14336b46f5b303fdd70bf239b013ace0feaf8cda5585aabb1cc48778dc4e1ed3b321cbee2548742d06e04220599c9e427b22b560b9a6a9a128d91f91aa024ecf8e6740cf4a9801d3e209e1aeb1ab9180a9ed1123af17ca2d6fbab571f893b8a83d46f632aa647a560e01087dfdeb76c022f65835591c66e2977faad77d3a5ee4d0843a7d92b9ca5315414a339c19aee313ac6e76e6699bf8865c324623c2c8172179e74098865b672086ff85b1a675449c26513086ba152c0874d95129d29e39ada30889e1121a24470c10e9cc39e97963fe06c913f1f1ddea7bbb971616501ce34ae9a1b29ee914438759280ed80b248625b5a652c43fa78efc72d1fd77486df7873b42699488d7e84777c603377156be9836d91b175ac149f931f6a1df2e73d88e8a7076664458506c7fac19aec89e7486166b87a29900a3f19267af88720a0deb6e9f57a1219b682693e7e3b657a3eddc99e05bb17bfc7ab67e23728b7a83501ca9241530173553c23ee697a0469b689e81be5bdb1455bac03aea3608a407d239e1fce8df570a653c2fd31c917d8489dd290e50df4cefd99968f82a644249c8d24d59c33569595be909e7cec30cc6d3c1f84f50fd80a6099945866fc2c1919e75f108c2b991fd136242c0a512845a53475adfc1418b784266372252f1cd7c8cb03db43351b052f0b3a3c581911c58190ffdae3a664e00813e6595de35994573f335bff0bfc70be32c3b8237204358a62b7fbee3a0cf3a59b9aa70d695ca44f7059f414af9035874e749705c24b534d15ef011d7a891c2f26c8ed99372e5ae0df4d9a27a1f63f734c5bebd0cd49db1ed31fd173904c283d492da0ad57035c1418cbabb2b20acffb0c0e1b146bb744f25f7397c7cf0abfb8df708ebf2aa90854fe8884c56a529abbe61d8627785b44be9ae5c349188368a25ad5b8ca03e7f3d27e4d614fcaa928cbeac28f907f7367930ec6457d20049c06640b6d14fe79a8572ec083dc6b5f925eb5ac085821a7e9681b3a27d2b669e9375da1adad2e6071c313f66f1bf7a8208ea5888cfeb719e4be988c5711f40b2563cba4305a5295272d481ad82683989411a742085810bf72f17ac085390229091eb1178b7a8f63eaef1ed4044d343a5a81fd16913800dcfbaf0d1f1cdddf5b17fac77ab221e0ff718620d7a889e441ea5eced9c1f912681551cc1d1afba96456fcfd75fa56bea2d31f681b9892acbb3471701d2b0b25d123ee3f5cc83e3130359e61e294973bb8c3128f06ee70f52067c00795e3a7ef93364a5d92050697c5ee199f72ae3e96f4cb6213c600c1ff4d74d1ce63ce47948e09fb5a11f82fbd537e32b7ee89f92ae529e758e70f40655ef73493c09bc8522774e64ba85bbc22c65630169b5fd0dee49dac5f499813a34b64a3d921d2f4e3daddad658f6084b400a5fde4ec3a9459a4b5998614eb3cb16ac07fe734345f1eba7585893dec3b33f2d21a2ac135b01e2cb0239a3cc4363755d90dc975cf2e25b62b427048f30bb938ca5736ae2d9a1aed1b095624f176cdfc93fb41897ef6a6e2400bbd13ec8cc788280f11dcdeddd2dc812c67789a27b57c89aeadd8c7c221541ae54f0ebe65ef3fce95aff81cfa002feebbc85e49cb32a32971bff10f80842721547323d9e64b89ed3ea64a3173c50b58d64e6734cf5264659d86003c2e8e5222dca3d23516d0feaeebc9d848326e71ef0a3b6b1b14bfc6fad8d479cb8788caa220aad98083b95eab588b894dad50667941070a187e1ff237db82783726da6748f3b7f1eba2f1f003de1d60ff782e2c3d978b13e03e854dfee1d7782891cd1bb8914c601bd525714e8c1f94c81c77f9364ee386cd4e4d109cb0d1edf354858885ceac54c7c858f97da49f36264ebec8f11d15f40892100976bc835ee505c674ff9074b1df98bd9d1c7442a7aab1477732775b072483707a5fff8923d8cc1c3baebb4bb773ce6a489a0265ad47aa7e4f679ec620ec2152a5ccdcca0f53edc8b6c562b8a2ac7e41a2d94c1b530ab079af60779cd87f1e66ee498685923fd58e606ead63d652c0f7816e730b062eca7d6c70a11a6b2b3cd162f5e60f09b18c217926e2ca69a25ac11367ddfb7c2e7fcbdc9d537a603e9ca9bbf88408a1148d23117703c534deb8b2b5097c7e3aa10e733f22c2f3ad73eb0dbe4ae6db8bf9b909738f3975729d67718ae63773003d1e1fdf8b5c7cb0e24796dc4397726933f63ae432a2ba8aaf91547e1fac66066d2d67b75fc4b6ea73b67bf3953dd24b268a2abc879fb057cb538e1d18d21704d27b49aae9be6214b06d27ccead0e59c51c9aabb3a5ffe2e9b4cccae6cb78266c349ce126c7687c622b1b7570a0d336d4d5f836d2304232fa7a7ab4b7c419b9ecc2ab265e2ef2471aa231bb3d1c85bed9b38ad71aa88f0cc6c32bca9e32eaffeb5d6960f7599feed1a26af623837be52a90a582ef5c953a1f3591756adde531ae5b397313356a84b9813617b64acc62b2fdb90d288cd7c50adb9371f7325b3578a5b8ca85a7d77dd3d4db4f453ec93b54f5f06723495204863f543a619de2745367610cc72acc8e662ef9ee7f206cf2ba118acb585ce4f386ef3c8c9baddc394866844fc4074e11e94e01cb0318ae08d41bdb29986ca8718ced70e4f9b640b082ca09fc34703d5a10f39997d76a9c896885c0371d56eb7c19f4a539d26099fa517bccdce3eab918c182c3ff0901a611560188c83cbb82dd319b6c747b15bb810ed5f9eb0cdbd417270eb7681cf569251d2bb8251bd1323110d7c7f0bdf796b74b980375aa6c0bb7518693be086e7059bd66af598bdea62f1c7fc24f77109cfac7daee142455ddfee793d96a4a133501419b96903969510efd7488066a4b7adbf31b2fa9231de1cac9202496688b9f6b6736c633dba27a40dbf38899885b042b95f59c5061cb768a31952847810fd3e0f4df019971164fa3ebd693d5049bc7acbac62352c58a40659dacfbabec47f0b279474c80938719e0b044066fc300d1a702c152245a0796aea6847afa742e9cbfa5493eb99ab316e438010a634c151ceedf0b02afe58f598fee2a93d5de6c1d0bae9b598cab241bfdfd677dd23ce14ca535d422a89ee06f19c024fa86a9194e393ec5081d10f3eb5e33623467dbf857a78a569fe78a6749506b6687f2fd4abcb8f5726f6aeae829da055074df8ed8d7874167faccac32ba38c46ea18bd3538d94724205658630ed8ab9d2be61576c6662058a06b54b3f4a1ce0b691c840ec75c0808ccf2b52acfb06cdad30c3de96e57cf0cb2b35635e6b72dfffc9b36bec8386de9bd2d46461ac292693bdbceddbe3bcb76ca7d05ed36ed28009fea29dcb62a2b11b15ee04c237fc20651bb517ab3c5153a3a0072ed5d279654054e3462c7457bb132c62ac788a109150e54c663006e866a7cf41fa3b579238fd35cf447cffed31a0718b7e6f631a8a4dff95345895275f1c43c3a6d34e344daf2e4735d48533935160eb316214b7ef751e888bd05c635e6e226e52213b4c453107eaf9f634820bed1ce6b64836c8b83cb521fe40cc945ee213a2779b2ae3c2977696c4db58eb2f3450d320fe74e7ebbd51402eaab05be5dce7a311e0a802e7ea69e8169d01451b03a353025708e8a6a6a64fe65ab8e8e8ff372257f5cb4fbc95021c4ae3d7762984ddc3824d129b91cf26b06cee4095554bb84a144ccf210de86e9e745fc8c7aed34287084e0c79507377a0eac744c72bb728e3217fef50e36bda5a9b5ef9886ccf635406a259962cbad1a5a8a2303f1c847e6eb5542c52c9de0c723a4b07609e09471b4751a40f61ec641819304fd880dfae0f5eaf63e8cee05d94b793ebad7aed79224fc17f950e717f45d5cfccad8c8c697513feae24fc30f6e22c62a24e67db9d929280638f08e021431fc589428de592f6a16ab5bda48c61b68edeaed79036c7f389a510eb2fe090e719942a73b02f8003916545b581b99547a324e402c7b178926f3723a24ac316cfdfdb77fa5587c0a8179dd24ff7206334db6e61ae98ea6a19b2a210d726a436468d0c098d2726558b3bef56fa0e3a70c0762fcf88afeca1de566cfbb93bc90211c405df2026625bfacf04d835c19035e4f2fb3da5409020711ecab5d0a6172cab1f25528afed9e10b7395341e405ea5e3ecd87e8c3e2f53eeb2bca8e95808f8b3e1ca1ce63f79616f301bd9d5a883fa1671cb50492a6dda4ddf851163d1d065a0c5291c51bec08043bf157f99e962e1a4d8a64f1bac2d30ba0adcc8a13b004622e2ab3541c1acf094a0471a9ebcd83cc3f08edc7ac2f6148d05aab13de1bec19b6b2eefb701dba4224790bcd9ea675c5eb82aaa8f0c2c342b51bbc302093bd4b694504e74fe355d38195fdbcf17db0dd0eadcfbcdfe3d3527fcf7bebb07c4e0867b2c01fe12c9fdc323dbb8c41b0c2b9af482a132836b715e68657032c26182bd7969e254f14a39558f6d3b06faa137aabc03d3bdb68cef4db80e7e1349b177ee835bb592ed9b665df0466b3f2483721d455d987ab6c7ed958863a790e4d0bdb54803eb30cf913db9a839e3572f1b0fd240ffd10c3669ef28c78b8118c1455faabc8e04be6148fea970237bb2a860816d390220433fcbba2a85d54438a42f182e550d67dc436c1f9c6991f1efc385fe8f03422813339ae92c41b820521fdeb428caf34a2c170195225321ed9f7b8fef74a3cd9fac8533a68f8eaea6bde9a0a1d77383d7ae1ea6af05b14feb56109b34e88cee3dea8aeaffedc78533f7c9d3b6476ed412eb6d590101ebc83feb9503cf51c2d5b8b6906ef3792f1197188566e2e05abe2bb4b39788f12e4cb175dc0cd7af37628f111fcc72f67a11bfd695bb193433a42b29bed85c33dc2bd98de98970d28a827bd1dd69cc4addd9f8930129f3073b3c3efb00ad4c084c394817df1b7e97d3034c7047b03ae4f54831b5329a7f55702f2ab539f35ef16766945a2c26a3a83d77ec50831c834b5ee6c0895bab393750da17d8fc541e7cba57daaa9f9220bed1f630dff66504af883597bbb60381f18767e0c9a2f48d7ee381bc6680e177e7b1dacf9ee9350777d3c0b491b5f4316100fa8e536f7dc7630d767da01ee9fcb0d075db7a3ffa5f83ac12fd8cb5ad6f63c9eafc9d1b1ddcc7441bc32d0fc82b22e87d04d87e093152116d52db84c64c312936003e274b41abfb73294764824e6097e8c41780b5d52caf27bf7798d4f1bec92a87759f8facf04d1c530101c61eadcba1f920b74ccb669dfadd4541597f19cacdab5c26038d645734258742e7ad2d8d61884a3add3a3ae11eafa0174f20c0353150dca4995833d1438faef9136802db7d51c6fadf3698818919c9e1e56115eb23cc15598ad8e54911f55729e4be3974e5037b5791abd02c7abc644bfcf6128371b14a94d64e15d3d54b8dc40d45fabb4266db8780704da4422cdaf0ae5c0996a923ede7a6c25416dd594884c55a9d502a78b20873278951db192e936750741a14c52f0078ddff46ceefdec80148ea44f649ef89d816c2a51dcc0f8e77c0d162b4030f1fa59ca8e618cce33e25ce9c07d67097db7d73b806f6c5bbbadf324174905e7050a097c4f63b0ffff1dfb53f454cdc336a567fe60f230505e8a28fe44aea54b605a0270cbc52fa253b53fae3e6ffe44785e4ff77b45d10310544938e19333b660cf57b64f2897ba3328b3f6511c79e842ddb3859e5d2638756ca30c41c8125b6a3a398f389822df4ed6064d442341a0534d6b9c336d6a728d59d14e7dbb26a3187b6db44f1d898ee770aa427846772b7fd7ee8ff1d43a68449e832471be2ad71d8a20747533c7d6aa4c2d371fc7627134aefdf0beb5f3fd5e3571167eceb0d9cc84977c9e5df8bda5bf92ab50093052297070a505a4b1c363d94764fe7d3547479a3ad51b7e9d986ca8d087a03217b1ce979b56a8414d4a8a97651ae656e4fa8655ca535ca5ccaa6be4bc369d69d457c4159ff8658d5eaa7cfbf7c03cea2aad058ccac0d61110828dc619c5a4f0aa5552afc04bff1ebc45f161037199742dbadee7906506a4ef7bca583102c2e89086035ef357504cde4175e9dab15145e0affa84694dce3113ee8a145cde7dd27ab42908b4ded9fadca86daa7004bf019903d2f7b52b2255c2a342226c99114a010449e6325565bb7e1bb89fc467bfff2f4a915971c9b05d510586e481b038cb1ca6eab271b5e89e7c691fcb0de8d3cf126c65665145f07214a8b775d89f2b47d9c27a8fe94b126a64fd27f40b4e6911b5652da9c2ac6e1f4740258c55c86cd7823df4351acb017b799b858a3fbb2d33789fc0bee35f2278f0e1988738131104afc70bba0d1f97a203fd888e855c4dc617cb7990f12c827c3d5e5553bd69560f93151a95733a034d8781ca3e4b1e787a0a6dccfa2c5ee5732b14e60ced24431722e8a11c33c930858a79e5d322d156c83a21b1a4267427d4fdf5c20e3a84a2eab55eeef3cb274f5ac76148f1424ad9546151afbea1505cfe923aeaed6059ce5e5bc6e57f1ffc1d8288439f259f6bf8345bc60509a92bf163697add4095534540a2822956883258fc39b4cd3e5e5c014d27e93e6f59c7d1441379114c07f09c5df3d89abd8d6e50116a5106ea8ecdd8b827e9a16d8a1b56133898729620b23e17ebdbf74f874e688678008875d754aed1c51cf56d422ca284114af9715a79bc9b1873f3da5b347ac107558f44266db6d52879d44161ff5177357bdbc6b974850107c93c77c81190eebeb51726ea1e1a07e48db5dd5eadb698f65ca5504b71b6614e484f31df8344d3fd76777250c57978c125120c8ce0633240261fc37b4d939a8fd49fd6822b54e6cbf81f7aa3cbaeb5cfeba626397dc9c8d75c7a2cb9e5ee7c869e952a3f8c18c7ba5f9e8501a8f8f99ecb05f07177fea49f9226cd6d5f274d104041f50b79923a91011310863ea64149eaf599dc8b1bdf02409563d19322a2e297602feafc77f982385cd586a1c61fe4ca65cd1e87a5e1664ef59a343c16e3513b9e94272be62690140dcc1315c47615d60ee4e423e3769b9f71371ab5cc26fe1987c36955749f48272a9fb2a2954c70851b09a9440e9ad1259ba0507ba0db7ad09d600deade145e51c053d489fd1138fd7fd873b79da7a0a92f860ae372dfdea229206c3afbc5d2a31780f37814604b3caf2bab054d8a01113005516d197fad489522a128535ab6158f058f02dfab21936b8b77a43112717085839c3197e7da3ebcfdc7b500cc8b07032c3ac6498a05b30f1b4698c87bf78d9b23b61f5535390355eb15ec729573624af2113ccaf9872b2709f930eec8a5cd7abd80163d6f58a0f31bcbee4e20903cf16dbdb2adb952665ea2dba822116538755fba6a9b7513da64bfd17730eaa71b51b0b11b1a09c45bfd05cf957dfe49850533eabbe78cce648d1ca833f79044ac1733f8c4bdb7bf25aa03bf87b8d2b87b0e8fbc2cd04c05dfec3b65fad4e9a5c14da3b96f160093db884dc8f5860996d7763a8aa34e2a2bb9f9e357fd8d0c357c285947e741995a1187090d2601e1b6e080b67ef9bd229dd106090619cf4ec8768a0c48bf3d3e4bdda43ff2761a16057dd04a467b671827d05674b965cf6c20c9935d4430e21762b7335e3d52246a489a63a6277bbe3df516320bf80297292fc04c3bd17d4ee063f9eddb830d33aedd908dab0f88ac91f39195de09fa613daca331bf4667f9b680a674a4d41108dadd697a878e3b7705992cf07e9d210b092a7613d0007af029cc65dd17bc208c8d680049ba84fc7e9e7e5dac20885b393dc12d9c1455f1ffea95588518302df830f10bde7a2b46507b578e5230096a9bf19cc310157e502adea8e1def939b6dfd42777fc3172abe6d5f6b5b0ec82690898db4ced69f60f1d44243e5820bce7eab914e7c3ec5957de672ede0391a12454dcb2c5292c5312ee3e93660045c2354c4666aec253cec6ae9f2d63a92ef9065ece14e6652f7d4b4eee09fd63ecbab747e803191f7f2c15da44dcaa737415c3f4e150994778484c9ad36ec10cb27990ad7f3fa310134024e694e4e9b8d83ca4a5fb7ea452ffa8ccbf551063f6fdbe9f5070a9e547487ae211fff81e255f66bc0b59708a79c175c37cea7dc96e63b70e3e54c7b1ae074b5ff38458f93fb8a20661a60869728bfd994f1e3f0650833291eb43ae6833db26d6bcf13da4e0ec23bcb47f50120855c99e31892e9e2f5a9890a59110cd54496e2716e915d093e987c461df4383b69e40d8cae5244bbbc2d89ba1dd1ecc647db91a2ab4c7f22236eb0c5671e5f0bd16ff886bf8d2542de4a31bddfe048d8ec464fe97b129838ac242a9dd25b69a5a268</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">有东西被加密了, 请输入密码查看.</summary>
    
    
    
    <category term="面试题" scheme="http://www.sion-io.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="http://www.sion-io.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>算法-面试题</title>
    <link href="http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%AE%97%E6%B3%95/"/>
    <id>http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%AE%97%E6%B3%95/</id>
    <published>2024-05-12T08:42:17.421Z</published>
    <updated>2024-05-12T08:48:19.890Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><a href="https://labuladong.gitee.io/algo/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/LRU%E7%AE%97%E6%B3%95.html">手写 LRU（要求用泛型写）</a></p><ol><li>主要难度在于使用双向链表和hashmap实现类似LinkedhashMap的功能</li></ol></li><li><p>算法题3：堆   相关知识点：地址：<a href="https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/thinkings/heap#tiao-biao">https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/thinkings/heap#tiao-biao</a> ；二叉树的分类：<a href="https://www.cnblogs.com/-citywall123/p/11788764.html">https://www.cnblogs.com/-citywall123/p/11788764.html</a></p><ol><li>记住二叉堆进行插入和删除要进行的操作</li><li>记住二叉树的种类</li></ol></li><li><p>啥是不稳定算法？<a href="https://blog.csdn.net/xiaolangmin/article/details/88538446">https://blog.csdn.net/xiaolangmin/article/details/88538446</a></p></li><li><p>排序算法中的不稳定算法？</p><ol><li>理解各种为啥不稳定算法：<a href="https://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html">https://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html</a></li><li>归并排序，插入排序，冒泡排序是稳定的，其它不稳定</li></ol></li><li><p>排序算法的复杂度？</p><ol><li>快速排序，归并排序，堆排序为NlogN</li><li>希尔排序比N2好一点</li><li>其他为N2</li></ol><table><thead><tr><th align="center">算法</th><th align="center">稳定性</th><th align="center">时间复杂度</th><th align="center">空间复杂度</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">选择排序</td><td align="center">×</td><td align="center">N2</td><td align="center">1</td><td align="center"></td></tr><tr><td align="center">冒泡排序</td><td align="center">√</td><td align="center">N2</td><td align="center">1</td><td align="center"></td></tr><tr><td align="center">插入排序</td><td align="center">√</td><td align="center">N ~ N2</td><td align="center">1</td><td align="center">时间复杂度和初始顺序有关</td></tr><tr><td align="center">希尔排序</td><td align="center">×</td><td align="center">N 的若干倍乘于递增序列的长度</td><td align="center">1</td><td align="center">改进版插入排序</td></tr><tr><td align="center">快速排序</td><td align="center">×</td><td align="center">NlogN</td><td align="center">logN</td><td align="center"></td></tr><tr><td align="center">三向切分快速排序</td><td align="center">×</td><td align="center">N ~ NlogN</td><td align="center">logN</td><td align="center">适用于有大量重复主键</td></tr><tr><td align="center">归并排序</td><td align="center">√</td><td align="center">NlogN</td><td align="center">N</td><td align="center"></td></tr><tr><td align="center">堆排序</td><td align="center">×</td><td align="center">NlogN</td><td align="center">1</td><td align="center">无法利用局部性原理</td></tr></tbody></table></li><li><p>你知道的排序算法有哪些？</p><ol><li>选择排序</li><li>冒泡排序</li><li>插入排序</li><li>希尔排序</li><li>快速排序：三个优化：1.因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序 2.一种折中方法是取 3 个元素，并将大小居中的元素作为切分元素  3.三向切分</li><li>归并排序</li><li>堆排序</li></ol></li><li><p>JDK的Arrays.sort()使用的是哪种排序方法？JDK1.8之后对于数据量大的时候不再使用快排，回去看一下这方面的优化吧？<a href="https://blog.csdn.net/TimHeath/article/details/68930482">https://blog.csdn.net/TimHeath/article/details/68930482</a>   <a href="https://www.cnblogs.com/baichunyu/p/11935995.html">https://www.cnblogs.com/baichunyu/p/11935995.html</a></p><p><img src="/img/OIP-C.jpg" data-original="https://img2018.cnblogs.com/i-beta/1701765/201911/1701765-20191126153931611-191817306.png" alt="img"></p></li></ol><p>看过的文章</p><ol><li>动态规划解决博弈问题<a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98.md">https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98.md</a></li><li>最长上升子序列</li><li>背包问题注意如何判断状态，选择，数组和状态转移方程</li><li>子序列问题<ol><li>一个数组一般dp的定义都是以nums[i]结尾的子序列的最xxx为dp[i]</li><li>两个数组使用一维dp</li><li>一个数组但是使用二维dp</li></ol></li><li>其它dp问题一般没有上面4.1的要求</li></ol><h1 id="二叉树-递归"><a href="#二叉树-递归" class="headerlink" title="二叉树-递归"></a>二叉树-递归</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><strong>1、是否可以通过遍历一遍二叉树得到答案</strong>？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现，这叫「遍历」的思维模式。  力扣第 104 题「 <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a>」</p><p><strong>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。  力扣第 104 题「 <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a>」</p><p>确定了以上两种解题方式之后，还需要确定进行前序遍历还是中序遍历还是后序遍历。</p><p>二叉树的前序遍历和后序遍历</p><ol><li>中序位置主要用在 BST 场景中</li><li><strong>前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据</strong>。一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了 <ol><li>前序遍历：如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？与    第 543 题「 <a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">二叉树的直径</a>」</li><li>后续遍历：如何打印出每个节点的左右子树各有多少节点？</li></ol></li></ol><hr><p>**二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 <a href="https://labuladong.gitee.io/algo/4/29/105/">回溯算法核心框架</a> 和 <a href="https://labuladong.gitee.io/algo/3/23/68/">动态规划核心框架</a>**。 </p><hr><h2 id="回溯-即dfs"><a href="#回溯-即dfs" class="headerlink" title="回溯(即dfs)"></a>回溯(即dfs)</h2><p>站在回溯树的一个节点上，你只需要思考 3 个问题：</p><p>1、路径：也就是已经做出的选择。</p><p>2、选择列表：也就是你当前可以做的选择。</p><p>3、结束条件：也就是到达决策树底层，无法再做选择的条件。</p><ul><li>「路径」和「选择」是每个节点的属性</li><li>函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作。</li></ul><p>回溯算法的框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><hr><p>我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？</p><p>某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。</p><p><span style="color:red"> 什么时候使用 used 数组，什么时候使用 begin 变量</span></p><p><span style="color:red"> 有些朋友可能会疑惑什么时候使用 used 数组，什么时候使用 begin 变量。这里为大家简单总结一下：</span></p><pre><code>排列问题，讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为不同列表时），需要记录哪些数字已经使用过，此时用 used 数组；组合问题，不讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为相同列表时），需要按照某种顺序搜索，此时使用 begin 变量。</code></pre><p>作者：liweiwei1419<br>链接：<a href="https://leetcode.cn/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">https://leetcode.cn/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><span style="color:red">以上可以对比全排列和【子集、组合】</span></p><p><span style="color:red">还要注意去重！</span></p><p><span style="color:red">去重对比【组合、子集】{timu90、timu40}去重（两种方法：使用visited和不使用visited）和全排列去重的不同！<a href="https://leetcode.cn/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/225211">https://leetcode.cn/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/225211</a></span></p><hr><h3 id="递归函数需要从总体上考虑"><a href="#递归函数需要从总体上考虑" class="headerlink" title="递归函数需要从总体上考虑"></a>递归函数需要从总体上考虑</h3><h2 id="动态规划（重叠子问题、最优子结构、状态转移方程）"><a href="#动态规划（重叠子问题、最优子结构、状态转移方程）" class="headerlink" title="动态规划（重叠子问题、最优子结构、状态转移方程）"></a>动态规划（重叠子问题、最优子结构、状态转移方程）</h2><p><strong>如何列出正确的状态转移方程</strong>？</p><p>1、<strong>确定 base case</strong>，这个很简单，显然目标金额 <code>amount</code> 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p><p>2、<strong>确定「状态」，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 <code>amount</code>。</p><p>3、<strong>确定「选择」，也就是导致「状态」产生变化的行为</strong>。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</p><p>4、<strong>明确 <code>dp</code> 函数&#x2F;数组的定义</strong>。我们这里讲的是自顶向下的解法，所以会有一个递归的 <code>dp</code> 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。</p><p>当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别，<code>dp</code> 数组的定义和刚才 <code>dp</code> 函数类似，也是把「状态」，也就是目标金额作为变量。<strong>不过 <code>dp</code> 函数体现在函数参数，而 <code>dp</code> 数组体现在数组索引</strong></p><p>重叠子问题、最优子结构、状态转移方程就是动态规划三要素</p><p>找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。这也是套路，经常刷题的读者应该能体会。</p><p><strong>最优子结构</strong>：可以从子问题的最优结果推出更大规模问题的最优结果。让你算<strong>每个班</strong>的最优成绩就是子问题，你知道所有子问题的答案后，就可以借此推出<strong>全校</strong>学生的最优成绩这个规模更大的问题的答案。</p><p>按上面的套路走，最后的结果就可以套这个框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base</span><br><span class="line"><span class="comment"># 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure><p><span style = "color:red" > 子序列：分为连续（①一般定义的dp的i,j，表示所求的最大连续子序列末尾或所求的最大公共子数组末尾为num[i]或s.chart(j)）和②不连续（和连续相反）</span></p><hr><p>动态规划是一类算法问题，肯定是让你求最值的。因为动态规划问题拥有 <a href="https://labuladong.gitee.io/algo/3/23/70/">最优子结构</a>，可以通过状态转移方程从小规模的子问题最优解推导出大规模问题的最优解。</p><p>分治算法呢，可以认为是一种算法思想，通过将原问题分解成小规模的子问题，然后根据子问题的结果构造出原问题的答案。这里有点类似动态规划，所以说运用分治算法也需要满足一些条件，你的原问题结果应该可以通过合并子问题结果来计算。</p><hr><h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p>废话不多说，解决本题的关键有两点：</p><p><strong>1、不要思考整体，而是把目光聚焦局部，只看一个运算符</strong>。</p><p><strong>2、明确递归函数的定义是什么，相信并且利用好函数的定义</strong>。</p><hr><p>比如 <a href="https://labuladong.gitee.io/algo/2/20/48/">图论基础</a>， <a href="https://labuladong.gitee.io/algo/2/20/49/">环判断和拓扑排序</a> 和 <a href="https://labuladong.gitee.io/algo/2/20/50/">二分图判定算法</a> 就用到了 DFS 算法；再比如 <a href="https://labuladong.gitee.io/algo/2/20/55/">Dijkstra 算法模板</a>，就是改造版 BFS 算法加上一个类似 dp table 的数组。</p><p>好了，说的差不多了，上述这些算法的本质都是穷举二（多）叉树，有机会的话通过剪枝或者备忘录的方式减少冗余计算，提高效率，就这么点事儿。</p><p>比如， <a href="https://labuladong.gitee.io/algo/2/19/33/">东哥手把手带你刷二叉树（总纲）</a> 中说二叉树非常重要，你把这个结构掌握了，就会发现 <a href="https://labuladong.gitee.io/algo/3/23/68/">动态规划</a>， <a href="https://labuladong.gitee.io/algo/4/31/123/">分治算法</a>， <a href="https://labuladong.gitee.io/algo/4/29/105/">回溯（DFS）算法</a>， <a href="https://labuladong.gitee.io/algo/4/29/111/">BFS 算法框架</a>， <a href="https://labuladong.gitee.io/algo/2/20/51/">Union-Find 并查集算法</a>， <a href="https://labuladong.gitee.io/algo/2/21/63/">二叉堆实现优先级队列</a> 就是把二叉树翻来覆去的运用。</p><hr><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p><span style="color:red">1.图的遍历没有返回值2.拓扑排序中onpath的位置3.二分图中base case的位置</span></p><p>所以，如果图包含环，遍历框架就要一个 <code>visited</code> 数组进行辅助：</p><p><img src="/img/OIP-C.jpg" data-original="/assets/image-20220516190228714.png" alt="image-20220516190228714"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录被遍历过的节点</span></span><br><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"><span class="comment">// 记录从起点到当前节点的路径</span></span><br><span class="line"><span class="type">boolean</span>[] onPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图遍历框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Graph graph, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[s]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 经过节点 s，标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 做选择：标记节点 s 在路径上</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph.neighbors(s)) &#123;</span><br><span class="line">        traverse(graph, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销选择：节点 s 离开路径</span></span><br><span class="line">    onPath[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，你应该注意到了，这个 <code>onPath</code> 数组的操作很像 <a href="https://labuladong.gitee.io/algo/4/29/105/">回溯算法核心套路</a> 中做「做选择」和「撤销选择」，区别在于位置：回溯算法的「做选择」和「撤销选择」在 for 循环里面，而对 <code>onPath</code> 数组的操作在 for 循环外面。</p><p>在 for 循环里面和外面唯一的区别就是对根节点的处理。</p><p>比如下面两种多叉树的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;enter: &quot;</span> + root.val);</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;leave: &quot;</span> + root.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;enter: &quot;</span> + child.val);</span><br><span class="line">        traverse(child);</span><br><span class="line">        System.out.println(<span class="string">&quot;leave: &quot;</span> + child.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前者会正确打印所有节点的进入和离开信息，而后者唯独会少打印整棵树根节点的进入和离开信息。</p><p><strong>为什么回溯算法框架会用后者？因为回溯算法关注的不是节点，而是树枝</strong>。</p><hr><p>如果让你处理路径相关的问题，这个 <code>onPath</code> 变量是肯定会被用到的，比如 <a href="https://labuladong.gitee.io/algo/2/20/49/">拓扑排序</a> 中就有运用。</p><p>当然，图还会有很多其他的有趣算法，比如 <a href="https://labuladong.gitee.io/algo/2/20/50/">二分图判定</a>， <a href="https://labuladong.gitee.io/algo/2/20/49/">环检测和拓扑排序</a>（编译器循环引用检测就是类似的算法）， <a href="https://labuladong.gitee.io/algo/2/20/52/">最小生成树</a>， <a href="https://labuladong.gitee.io/algo/2/20/55/">Dijkstra 最短路径算法</a> 等等，有兴趣的读者可以去看看，本文就到这了。</p><p>不过以我的经验呢，像网络流这种问题，你又不是打竞赛的，没时间的话就没必要学了；像 <a href="https://labuladong.gitee.io/algo/2/20/52/">最小生成树</a> 和 <a href="https://labuladong.gitee.io/algo/2/20/54/">最短路径问题</a>，虽然从刷题的角度用到的不多，但它们属于经典算法，学有余力可以掌握一下；像 <a href="https://labuladong.gitee.io/algo/2/20/49/">二分图判定</a>、拓扑排序这一类，属于比较基本且有用的算法，应该比较熟练地掌握。</p><p><strong>那么本文就结合具体的算法题，来说两个图论算法：有向图的环检测、拓扑排序算法</strong>。</p><hr><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><strong>其实也不难看出来，如果把课程抽象成节点，课程之间的依赖关系抽象成有向边，那么这幅图的拓扑排序结果就是上课顺序</strong>。</p><p>首先，我们先判断一下题目输入的课程依赖是否成环，成环的话是无法进行拓扑排序的，所以我们可以复用上一道题的主函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!canFinish(numCourses, prerequisites)) &#123;</span><br><span class="line">        <span class="comment">// 不可能完成所有课程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么关键问题来了，如何进行拓扑排序？是不是又要秀什么高大上的技巧了？</p><p><strong>其实特别简单，将后序遍历的结果进行反转，就是拓扑排序的结果</strong>。</p><p>代码虽然看起来多，但是逻辑应该是很清楚的，只要图中无环，那么我们就调用 <code>traverse</code> 函数对图进行 DFS 遍历，记录后序遍历结果，最后把后序遍历结果反转，作为最终的答案。</p><p><strong>那么为什么后序遍历的反转结果就是拓扑排序呢</strong>？</p><p>我这里也避免数学证明，用一个直观地例子来解释，我们就说二叉树，这是我们说过很多次的二叉树遍历框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 前序遍历代码位置</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    <span class="comment">// 中序遍历代码位置</span></span><br><span class="line">    traverse(root.right)</span><br><span class="line">    <span class="comment">// 后序遍历代码位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉树的后序遍历是什么时候？遍历完左右子树之后才会执行后序遍历位置的代码。换句话说，当左右子树的节点都被装到结果列表里面了，根节点才会被装进去。</p><p><strong>后序遍历的这一特点很重要，之所以拓扑排序的基础是后序遍历，是因为一个任务必须等到它依赖的所有任务都完成之后才能开始开始执行</strong>。</p><p>你把二叉树理解成一幅有向图，边的方向是由父节点指向子节点，那么就是下图这样：</p><p><a href="https://labuladong.gitee.io/algo/images/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/2.jpeg"><img src="/img/OIP-C.jpg" data-original="https://labuladong.gitee.io/algo/images/%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f/2.jpeg" alt="img"></a></p><p>按照我们的定义，边的含义是「被依赖」关系，那么上图的拓扑排序应该首先是节点 <code>1</code>，然后是 <code>2, 3</code>，以此类推。</p><p>但显然标准的后序遍历结果不满足拓扑排序，而如果把后序遍历结果反转，就是拓扑排序结果了：</p><p><a href="https://labuladong.gitee.io/algo/images/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/3.jpeg"><img src="/img/OIP-C.jpg" data-original="https://labuladong.gitee.io/algo/images/%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f/3.jpeg" alt="img"></a></p><h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><p>判定二分图的算法很简单，就是用代码解决「双色问题」。</p><p><strong>说白了就是遍历一遍图，一边遍历一边染色，看看能不能用两种颜色给所有节点染色，且相邻节点的颜色都不相同</strong>。</p><p>既然说到遍历图，也不涉及最短路径之类的，当然是 DFS 算法和 BFS 皆可了，DFS 算法相对更常用些，所以我们先来看看如何用 DFS 算法判定双色图。</p><p>首先，基于 <a href="https://labuladong.gitee.io/algo/1/2/">学习数据结构和算法的框架思维</a> 写出图的遍历框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树遍历框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 多叉树遍历框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children)</span><br><span class="line">        traverse(child);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图遍历框架 */</span></span><br><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Graph graph, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="comment">// 防止走回头路进入死循环</span></span><br><span class="line">    <span class="keyword">if</span> (visited[v]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序遍历位置，标记节点 v 已访问</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode neighbor : graph.neighbors(v))</span><br><span class="line">        traverse(graph, neighbor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为图中可能存在环，所以用 <code>visited</code> 数组防止走回头路。</p><p><strong>这里可以看到我习惯把 return 语句都放在函数开头，因为一般 return 语句都是 base case，集中放在一起可以让算法结构更清晰</strong>。</p><p>其实，如果你愿意，也可以把 if 判断放到其它地方，比如图遍历框架可以稍微改改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 图遍历框架 */</span></span><br><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Graph graph, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="comment">// 前序遍历位置，标记节点 v 已访问</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph.neighbors(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            <span class="comment">// 只遍历没标记过的相邻节点</span></span><br><span class="line">            traverse(graph, neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法把对 <code>visited</code> 的判断放到递归调用之前，和之前的写法唯一的不同就是，你需要保证调用 <code>traverse(v)</code> 的时候，<code>visited[v] == false</code>。</p><p>为什么要特别说这种写法呢？因为我们判断二分图的算法会用到这种写法。</p><p><strong>回顾一下二分图怎么判断，其实就是让 <code>traverse</code> 函数一边遍历节点，一边给节点染色，尝试让每对相邻节点的颜色都不一样</strong>。</p><p>所以，判定二分图的代码逻辑可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 图遍历框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Graph graph, <span class="type">boolean</span>[] visited, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 遍历节点 v 的所有相邻节点 neighbor</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph.neighbors(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 neighbor 没有被访问过</span></span><br><span class="line">            <span class="comment">// 那么应该给节点 neighbor 涂上和节点 v 不同的颜色</span></span><br><span class="line">            traverse(graph, visited, neighbor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 neighbor 已经被访问过</span></span><br><span class="line">            <span class="comment">// 那么应该比较节点 neighbor 和节点 v 的颜色</span></span><br><span class="line">            <span class="comment">// 若相同，则此图不是二分图</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你能看懂上面这段代码，就能写出二分图判定的具体代码了，接下来看两道具体的算法题来实操一下。</p><h1 id="二叉树其它"><a href="#二叉树其它" class="headerlink" title="二叉树其它"></a>二叉树其它</h1><h2 id="BFS算法框架（最近距离）"><a href="#BFS算法框架（最近距离）" class="headerlink" title="BFS算法框架（最近距离）"></a>BFS算法框架<span style="color:red">（最近距离）</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BFS</span><span class="params">(Node start, Node target)</span> &#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dijkstra-算法（BFS加强版）"><a href="#Dijkstra-算法（BFS加强版）" class="headerlink" title="Dijkstra 算法（BFS加强版）"></a>Dijkstra 算法（BFS加强版）</h3><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>现在我们的 Union-Find 算法主要需要实现这两个 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">/* 将 p 和 q 连接 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line">    <span class="comment">/* 判断 p 和 q 是否连通 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line">    <span class="comment">/* 返回图中有多少个连通分量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：</p><p>1、自反性：节点 <code>p</code> 和 <code>p</code> 是连通的。</p><p>2、对称性：如果节点 <code>p</code> 和 <code>q</code> 连通，那么 <code>q</code> 和 <code>p</code> 也连通。</p><p>3、传递性：如果节点 <code>p</code> 和 <code>q</code> 连通，<code>q</code> 和 <code>r</code> 连通，那么 <code>p</code> 和 <code>r</code> 也连通。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// 连通分量个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 存储每个节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n 为图中节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将节点 p 和节点 q 连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        <span class="comment">// 两个连通分量合并成一个连通分量</span></span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点 p 和节点 q 是否连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = find(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图中的连通分量个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>使用数组实现的堆；</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><strong>递归算法的时间复杂度 &#x3D; 递归的次数 x 函数本身的时间复杂度</strong></p><p><strong>递归算法的空间复杂度 &#x3D; 递归堆栈的深度 + 算法申请的存储空间</strong></p><p>或者再说得直观一点：</p><p><strong>递归算法的时间复杂度 &#x3D; 递归树的节点个数 x 每个节点的时间复杂度</strong></p><p><strong>递归算法的空间复杂度 &#x3D; 递归树的高度 + 算法申请的存储空间</strong></p><hr><p>比如前文 <a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484731&idx=1&sn=f1db6dee2c8e70c42240aead9fd224e6&scene=21#wechat_redirect">动态规划核心框架</a> 中讲到的凑零钱问题的暴力递归解法</p><p>这棵树的高度有多高？不知道，那就按最坏情况来处理，假设全都是面额为 1 的硬币，这种情况下树高为<code>N</code>。</p><p>这棵树的结构是什么样的？不知道，那就按最坏情况来处理，假设它是一棵满<code>K</code>叉树好了。</p><p>那么，这棵树上共有多少节点？都按最坏情况来处理，高度为<code>N</code>的一棵满<code>K</code>叉树，其节点总数为<code>K^N - 1</code>，用 Big O 表示就是<code>O(K^N)</code></p><hr><p>对于带备忘录的动态规划算法的时间复杂度，以下几种理解方式都是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">递归的次数 x 函数本身的时间复杂度</span><br><span class="line">= 递归树节点个数 x 每个节点的时间复杂度</span><br><span class="line">= 状态个数 x 计算每个状态的时间复杂度</span><br><span class="line">= 子问题个数 x 解决每个子问题的时间复杂度</span><br><span class="line">= O(N) * O(K)</span><br><span class="line">= O(NK)</span><br></pre></td></tr></table></figure><p>像「状态」「子问题」属于动态规划类型问题特有的词汇，但时间复杂度本质上还是递归次数 x 函数本身复杂度，换汤不换药罢了。</p><hr><p><strong>先看标准全排列问题</strong>（元素无重不可复选）</p><p>再来看看<code>backtrack</code>函数递归了多少次，即这个排列树上有多少个节点。</p><p>第 0 层（根节点）有<code>P(N, 0) = 1</code>个节点。</p><p>第 1 层有<code>P(N, 1) = N</code>个节点。</p><p>第 2 层有<code>P(N, 2) = N x (N - 1)</code>个节点。</p><p>第 3 层有<code>P(N, 3) = N x (N - 1) x (N - 2)</code>个节点。</p><p>以此类推，其中<code>P</code>就是我们高中学过的排列数函数。</p><p>全排列的回溯树高度为<code>N</code>，所以节点总数为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(N, 0) + P(N, 1) + P(N, 2) + ... + P(N, N)</span><br></pre></td></tr></table></figure><p>这一堆排列数累加不好算，粗略估计一下上界吧，把它们全都扩大成<code>P(N, N) = N!</code>，**那么节点总数的上界就是<code>O(N\*N!)</code>**。</p><p>现在就可以得出算法的总时间复杂度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  递归的次数 x 函数本身的时间复杂度</span><br><span class="line">= 递归树节点个数 x 每个节点的时间复杂度</span><br><span class="line">= O(N*N!) * O(N)</span><br><span class="line">= O(N^2 * N!)</span><br></pre></td></tr></table></figure><p><code>backtrack</code>函数的递归深度为递归树的高度<code>O(N)</code>，而算法需要存储所有全排列的结果，即需要申请的空间为<code>O(N*N!)</code>。**所以总的空间复杂度为<code>O(N\*N!)</code>**。</p><hr><p><strong>标准子集问题</strong>（元素无重不可复选）</p><p>第 0 层（根节点）有<code>C(N, 0) = 1</code>个节点。</p><p>第 1 层有<code>C(N, 1) = N</code>个节点。</p><p>第 2 层有<code>C(N, 2)</code>个节点。</p><p>第 3 层有<code>C(N, 3)</code>个节点。</p><p>以此类推，其中<code>C</code>就是我们高中学过的组合数函数。</p><p>由于这棵组合树的高度为<code>N</code>，组合数求和公式是高中学过的，**所以总的节点数为<code>2^N</code>**：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C(N, 0) + C(N, 1) + C(N, 2) + ... + C(N, N) = 2^N</span><br></pre></td></tr></table></figure><p>就算你忘记了组合数求和公式，其实也可以推导出来节点总数：因为<code>N</code>个元素的所有子集（幂集）数量为<code>2^N</code>，而这棵树的每个节点代表一个子集，所以树的节点总数也为<code>2^N</code>。</p><p>那么，现在就可以得出算法的总复杂度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  递归的次数 x 函数本身的时间复杂度</span><br><span class="line">= 递归树节点个数 x 每个节点的时间复杂度</span><br><span class="line">= O(2^N) * O(N)</span><br><span class="line">= O(N*2^N)</span><br></pre></td></tr></table></figure><p>分析下该算法的空间复杂度：</p><p><code>backtrack</code>函数的递归深度为递归树的高度<code>O(N)</code>，而算法需要存储所有子集的结果，粗略估算下需要申请的空间为<code>O(N*2^N)</code>，**所以总的空间复杂度为<code>O(N\*2^N)</code>**。</p><h3 id="非递归算法分析"><a href="#非递归算法分析" class="headerlink" title="非递归算法分析"></a>非递归算法分析</h3><p><strong>其实，你只需要搞清楚代码到底在干什么，就能轻松计算出正确的复杂度了</strong>。</p><h1 id="数组-单链表系列"><a href="#数组-单链表系列" class="headerlink" title="数组&#x2F;单链表系列"></a>数组&#x2F;单链表系列</h1><hr><p><strong>单链表常考的技巧就是双指针</strong>，前文 <a href="https://labuladong.gitee.io/algo/2/17/16/">单链表六大技巧</a> 全给你总结好了，这些技巧就是会者不难，难者不会。</p><hr><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="单链表（快慢指针）"><a href="#单链表（快慢指针）" class="headerlink" title="单链表（快慢指针）"></a>单链表（快慢指针）</h3><hr><p><strong>数组常用的技巧有很大一部分还是双指针相关的技巧，说白了是教你如何聪明地进行穷举</strong>。</p><p><strong>首先说二分搜索技巧</strong>，可以归为两端向中心的双指针。如果让你在数组中搜索元素，一个 for 循环穷举肯定能搞定对吧，但如果数组是有序的，二分搜索不就是一种更聪明的搜索方式么。</p><p>前文 <a href="https://labuladong.gitee.io/algo/2/18/26/">二分搜索框架详解</a> 给你总结了二分搜索代码模板，保证不会出现搜索边界的问题。前文 <a href="https://labuladong.gitee.io/algo/2/18/28/">二分搜索算法运用</a> 给你总结了二分搜索相关题目的共性以及如何将二分搜索思想运用到实际算法中。</p><hr><h3 id="二分搜索（左右指针）"><a href="#二分搜索（左右指针）" class="headerlink" title="二分搜索（左右指针）"></a>二分搜索（左右指针）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。</p><p>2、注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。</p><p>3、如需定义左闭右开的「搜索区间」搜索左右边界，只要在 <code>nums[mid] == target</code> 时做修改即可，搜索右侧时需要减一。</p><p>4、如果将「搜索区间」全都统一成两端都闭，好记，只要稍改 <code>nums[mid] == target</code> 条件处的代码和返回的逻辑即可，<strong>推荐拿小本本记下，作为二分搜索模板</strong>。</p><hr><p>类似的两端向中心的双指针技巧还有力扣上的 N 数之和系列问题，前文 <a href="https://labuladong.gitee.io/algo/1/14/">一个函数秒杀所有 nSum 问题</a> 讲了这些题目的共性，甭管几数之和，解法肯定要穷举所有的数字组合，然后看看那个数字组合的和等于目标和嘛。比较聪明的方式是先排序，利用双指针技巧快速计算结果。</p><hr><h3 id="nsum（左右指针）"><a href="#nsum（左右指针）" class="headerlink" title="nsum（左右指针）"></a>nsum（左右指针）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">twoSumTarget</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="comment">// nums 数组必须有序</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> lo = <span class="number">0</span>, hi = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="type">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">        <span class="type">int</span> left = nums[lo], right = nums[hi];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个通用化的 <code>twoSum</code> 函数就写出来了</p><hr><p>**再说说 <a href="https://labuladong.gitee.io/algo/2/18/25/">滑动窗口算法技巧</a>**，典型的快慢双指针，快慢指针中间就是滑动的「窗口」，主要用于解决子串问题。</p><p>文中最小覆盖子串这道题，让你寻找包含特定字符的最短子串，常规拍脑袋解法是什么？那肯定是类似字符串暴力匹配算法，用嵌套 for 循环穷举呗，平方级的复杂度。</p><p>而滑动窗口技巧告诉你不用这么麻烦，可以用快慢指针遍历一次就求出答案，这就是教你聪明的穷举技巧。</p><p>但是，就好像二分搜索只能运用在有序数组上一样，滑动窗口也是有其限制的，就是你必须明确的知道什么时候应该扩大窗口，什么时候该收缩窗口。</p><hr><h3 id="滑动窗口（快慢指针）"><a href="#滑动窗口（快慢指针）" class="headerlink" title="滑动窗口（快慢指针）"></a>滑动窗口（快慢指针）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 增大窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>滑动窗口算法的思路是这样</strong>：</p><p>1、我们在字符串 <code>S</code> 中使用双指针中的左右指针技巧，初始化 <code>left = right = 0</code>，把索引<strong>左闭右开</strong>区间 <code>[left, right)</code> 称为一个「窗口」。</p><blockquote><p>PS：理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 <code>left = right = 0</code> 时区间 <code>[0, 0)</code> 中没有元素，但只要让 <code>right</code> 向右移动（扩大）一位，区间 <code>[0, 1)</code> 就包含一个元素 <code>0</code> 了。如果你设置为两端都开的区间，那么让 <code>right</code> 向右移动一位后开区间 <code>(0, 1)</code> 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 <code>[0, 0]</code> 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。</p></blockquote><p>2、我们先不断地增加 <code>right</code> 指针扩大窗口 <code>[left, right)</code>，直到窗口中的字符串符合要求（包含了 <code>T</code> 中的所有字符）。</p><p>3、此时，我们停止增加 <code>right</code>，转而不断增加 <code>left</code> 指针缩小窗口 <code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含 <code>T</code> 中的所有字符了）。同时，每次增加 <code>left</code>，我们都要更新一轮结果。</p><p>4、重复第 2 和第 3 步，直到 <code>right</code> 到达字符串 <code>S</code> 的尽头。</p><hr><p><strong>还有回文串相关技巧</strong>，如果判断一个串是否是回文串，使用双指针从两端向中心检查，如果寻找回文子串，就从中心向两端扩散。前文 <a href="https://labuladong.gitee.io/algo/2/18/23/">最长回文子串</a> 使用了一种技巧同时处理了回文串长度为奇数或偶数的情况。</p><hr><h3 id="回文串（左右指针）"><a href="#回文串（左右指针）" class="headerlink" title="回文串（左右指针）"></a><strong>回文串</strong>（左右指针）</h3><hr><p>**最后说说 <a href="https://labuladong.gitee.io/algo/2/18/21/">前缀和技巧</a> 和 <a href="https://labuladong.gitee.io/algo/2/18/22/">差分数组技巧</a>**。</p><p>如果频繁地让你计算子数组的和，每次用 for 循环去遍历肯定没问题，但前缀和技巧预计算一个 <code>preSum</code> 数组，就可以避免循环。</p><p>类似的，如果频繁地让你对子数组进行增减操作，也可以每次用 for 循环去操作，但差分数组技巧维护一个 <code>diff</code> 数组，也可以避免循环。</p><hr><h3 id="前缀和技巧-和-差分数组技巧-。"><a href="#前缀和技巧-和-差分数组技巧-。" class="headerlink" title="**前缀和技巧 和 差分数组技巧**。"></a>**<a href="https://labuladong.gitee.io/algo/2/18/21/">前缀和技巧</a> 和 <a href="https://labuladong.gitee.io/algo/2/18/22/">差分数组技巧</a>**。</h3><p>先看一道例题，力扣第 303 题「 <a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">区域和检索 - 数组不可变</a>」，让你计算数组区间内元素的和，这是一道标准的前缀和问题：</p><p>题目要求你实现这样一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 查询闭区间 [left, right] 的累加和 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接看代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    <span class="comment">// 前缀和数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] preSum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输入一个数组，构造前缀和 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// preSum[0] = 0，便于计算累加和</span></span><br><span class="line">        preSum = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 计算 nums 的累加和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; preSum.length; i++) &#123;</span><br><span class="line">            preSum[i] = preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 查询闭区间 [left, right] 的累加和 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> preSum[right + <span class="number">1</span>] - preSum[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思路是我们 new 一个新的数组 <code>preSum</code> 出来，<code>preSum[i]</code> 记录 <code>nums[0..i-1]</code> 的累加和</p><p>本文讲一个和前缀和思想非常类似的算法技巧「差分数组」，<strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</strong>。</p><p>比如说，我给你输入一个数组 <code>nums</code>，然后又要求给区间 <code>nums[2..6]</code> 全部加 1，再给 <code>nums[3..9]</code> 全部减 3，再给 <code>nums[0..4]</code> 全部加 2，再给…</p><p>一通操作猛如虎，然后问你，最后 <code>nums</code> 数组的值是什么？</p><p>常规的思路很容易，你让我给区间 <code>nums[i..j]</code> 加上 <code>val</code>，那我就一个 for 循环给它们都加上呗，还能咋样？这种思路的时间复杂度是 O(N)，由于这个场景下对 <code>nums</code> 的修改非常频繁，所以效率会很低下。</p><p>这里就需要差分数组的技巧，类似前缀和技巧构造的 <code>prefix</code> 数组，我们先对 <code>nums</code> 数组构造一个 <code>diff</code> 差分数组，**<code>diff[i]</code> 就是 <code>nums[i]</code> 和 <code>nums[i-1]</code> 之差**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line"><span class="comment">// 构造差分数组</span></span><br><span class="line">diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样构造差分数组 <code>diff</code>，就可以快速进行区间增减的操作</strong>，如果你想对区间 <code>nums[i..j]</code> 的元素全部加 3，那么只需要让 <code>diff[i] += 3</code>，然后再让 <code>diff[j+1] -= 3</code> 即可：</p><p>现在我们把差分数组抽象成一个类，包含 <code>increment</code> 方法和 <code>result</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差分数组工具类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Difference</span> &#123;</span><br><span class="line">    <span class="comment">// 差分数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] diff;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 输入一个初始数组，区间操作将在这个数组上进行 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Difference</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> nums.length &gt; <span class="number">0</span>;</span><br><span class="line">        diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 根据初始数组构造差分数组</span></span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 给闭区间 [i, j] 增加 val（可以是负数）*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.length) &#123;</span><br><span class="line">            diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回结果数组 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] result() &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[diff.length];</span><br><span class="line">        <span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; diff.length; i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><p>优先级队列这种数据结构有一个很有用的功能，你插入或者删除元素的时候，元素会自动排序，这底层的原理就是二叉堆的操作。</p><p>数据结构的功能无非增删查改，优先级队列有两个主要 API，分别是 <code>insert</code> 插入一个元素和 <code>delMax</code> 删除最大元素（如果底层用最小堆，那么就是 <code>delMin</code>）。</p><p>下面我们实现一个简化的优先级队列，先看下代码框架：</p><blockquote><p>PS：这里用到 Java 的泛型，<code>Key</code> 可以是任何一种可比较大小的数据类型，比如 Integer 等类型。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span></span><br><span class="line">    &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="comment">// 当前 Priority Queue 中的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxPQ</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="comment">// 索引 0 不用，所以多分配一个空间</span></span><br><span class="line">        pq = (Key[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[cap + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回当前队列中最大元素 */</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">max</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 插入元素 e */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Key e)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除并返回当前队列中最大元素 */</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">delMax</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 上浮第 x 个元素，以维护最大堆性质 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> x)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下沉第 x 个元素，以维护最大堆性质 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> x)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 交换数组的两个元素 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Key</span> <span class="variable">temp</span> <span class="operator">=</span> pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pq[i] 是否比 pq[j] 小？ */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 还有 left, right, parent 三个方法 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上浮的代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果浮到堆顶，就不能再上浮了</span></span><br><span class="line">    <span class="keyword">while</span> (node &gt; <span class="number">1</span> &amp;&amp; less(parent(x), x)) &#123;</span><br><span class="line">        <span class="comment">// 如果第 x 个元素比上层大</span></span><br><span class="line">        <span class="comment">// 将 x 换上去</span></span><br><span class="line">        exch(parent(x), x);</span><br><span class="line">        x = parent(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下沉比上浮略微复杂一点，因为上浮某个节点 A，只需要 A 和其父节点比较大小即可；但是下沉某个节点 A，需要 A 和其<strong>两个子节点</strong>比较大小，如果 A 不是最大的就需要调整位置，要把较大的那个子节点和 A 交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果沉到堆底，就沉不下去了</span></span><br><span class="line">    <span class="keyword">while</span> (left(x) &lt;= size) &#123;</span><br><span class="line">        <span class="comment">// 先假设左边节点较大</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">older</span> <span class="operator">=</span> left(x);</span><br><span class="line">        <span class="comment">// 如果右边节点存在，比一下大小</span></span><br><span class="line">        <span class="keyword">if</span> (right(x) &lt;= N &amp;&amp; less(older, right(x)))</span><br><span class="line">            older = right(x);</span><br><span class="line">        <span class="comment">// 结点 x 比俩孩子都大，就不必下沉了</span></span><br><span class="line">        <span class="keyword">if</span> (less(older, x)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 否则，不符合最大堆的结构，下沉 x 结点</span></span><br><span class="line">        exch(x, older);</span><br><span class="line">        x = older;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://labuladong.gitee.io/algo/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/LRU%E7%AE%97%E6%B3%95.html&quot;&gt;手写 </summary>
      
    
    
    
    <category term="面试题" scheme="http://www.sion-io.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="算法" scheme="http://www.sion-io.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql-面试题</title>
    <link href="http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98/"/>
    <id>http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98/</id>
    <published>2024-05-12T08:42:17.418Z</published>
    <updated>2024-05-12T08:48:19.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql面试题"><a href="#mysql面试题" class="headerlink" title="mysql面试题"></a>mysql面试题</h1><h2 id="记住数据库的几个大的模块"><a href="#记住数据库的几个大的模块" class="headerlink" title="记住数据库的几个大的模块"></a>记住数据库的几个大的模块</h2><ol><li>sql和关系代数之间的实现关系，sql怎么实现关系代数的θ连接和外连接的（inner join 和 其它join）</li><li>安全性和完整性</li><li>数据库优化：物理优化和逻辑优化</li><li>数据库索引</li><li>数据库的事务处理：并发控制和故障恢复</li></ol><h2 id="InnoDB-和-MyISAM-区别？"><a href="#InnoDB-和-MyISAM-区别？" class="headerlink" title="InnoDB 和 MyISAM 区别？"></a>InnoDB 和 MyISAM 区别？</h2><ol><li><p>（答案来自看深入浅出mysql的笔记）  1.只有innodb支持外键（外键必须创建索引，这个会自动创建） 和 事务    2.MyISAM 支持全文索引，前缀压缩索引，innodb支持聚簇索引  3.innodb支持行锁，MVCC，间隙锁(next-key locking)，MyISAM 不支持    </p><h2 id="说说-MySQL-的架构？"><a href="#说说-MySQL-的架构？" class="headerlink" title="说说 MySQL 的架构？"></a>说说 MySQL 的架构？</h2></li><li><p>0.mysql执行前会进行查询缓存-&gt;解析-&gt;优化-&gt;执行   1.连接层：连接处理、授权认证、安全  2.大多数 <code>MYSQL</code>的核心服务功能都在这一层，包括査询解析、分析、优化、缓存以及所有的内置函数(例如日期、时间、数学和加密函数)，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。  3.引擎层，负责<code>MYSQL</code>中数据的储存和提取，提供了各种数据储存方法</p></li></ol><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ol><li><p>一些树的概念：二叉搜索树（左边节点比根节点小，右边比根节点大），平衡二叉树（不一定是二叉搜索树），红黑树（属于平衡二叉树的一种，红黑树放弃了追求完全平衡，追求大致平衡；也属于二叉搜索树），b树（是多路搜索树），b+树</p></li><li><p>b树漫画入门：<a href="https://mp.weixin.qq.com/s?__biz=MzI2NjA3NTc4Ng==&mid=2652079363&idx=1&sn=7c2209e6b84f344b60ef4a056e5867b4&chksm=f1748ee6c60307f084fe9eeff012a27b5b43855f48ef09542fe6e56aab6f0fc5378c290fc4fc&scene=0&pass_ticket=75GZ52L7yYmRgfY0HdRdwlWLLEqo5BQSwUcvb44a7dDJRHFf49nJeGcJmFnj0cWg#rd">地址</a></p></li><li><p>b+树漫画入门：<a href="https://blog.csdn.net/qq_29373285/article/details/88610654">地址</a>   1.b+树和b树的区别？  （1.尾端有链表直接相连，方便读取多条数据，2.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），3.所有的中间节点元素都同时存在于子节点，4.只有叶子节点有卫星数据）</p></li><li><p>加上这个b+树：<a href="https://mp.weixin.qq.com/s/jRZMMONW3QP43dsDKIV9VQ">地址</a>  <a href="https://mp.weixin.qq.com/s/YMbRJwyjutGMD1KpI_fS0A">地址</a></p></li><li><p>知道聚簇索引和非聚簇索引吗？  1.什么是聚簇索引，什么是非聚簇索引  2.什么引擎才有聚簇索引   3.非聚簇索引的二次查找  （感觉这个回答还是少了点，以后找找具体的回答）</p></li><li><p>索引失效的情况？和explain的参数区别？</p><ol><li><p>索引失效的情况</p><ol><li><p>最佳左前缀</p></li><li><p>不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致做了操作的索引列和后面的索引列都失效</p></li><li><p>存储引擎不能使用索引中范围条件右边的列（即右边索引列失效），使用范围的那一列还是可以使用的</p></li><li><p>mysq在使用不等于(&#x3D;或者&lt;&gt;)的时候无法使用整个索引会导致全表扫描</p></li><li><p>会导致使用了和 is not null 的列和后面的索引列都失效</p></li><li><p>要注使用like列及其后面的索引列会失效</p></li><li><p>使用or导致索引失效，无法使用整个索引会导致全表扫描</p></li><li><p>字符串不加单引号索引失效，会导致该索引列及后面的索引列失效</p><p><img src="/img/OIP-C.jpg" data-original="/assets/image-20210305230639719.png" alt="image-20210305230639719"></p><p>需要注意的几点</p><ol><li>order的&lt;号之前的字段的可以和where的const合在一起组成最左前缀</li><li>以下的这种四个都有的随便排列组合都是可以使用到全部索引列的<br>explain select * from test03 where c4&#x3D;’a4’ and c3&#x3D;’a3’ and c2&#x3D;’a2’ and c1&#x3D;’a1’\G;</li></ol></li><li><p>如何尽量使用到索引？ <a href="https://mp.weixin.qq.com/s/3xkLTe7r388lRq-SBQllXw">https://mp.weixin.qq.com/s/3xkLTe7r388lRq-SBQllXw</a>  </p></li><li><p>索引相关知识：<a href="https://mp.weixin.qq.com/s/woz5lkQwyJZNmoiiJZy7NA">https://mp.weixin.qq.com/s/woz5lkQwyJZNmoiiJZy7NA</a></p></li></ol></li><li><p>explain的参数区别：参考自己写的数据库的笔记</p></li></ol></li><li><p>慢查询分析：<a href="https://blog.csdn.net/qq_40884473/article/details/89455740">地址</a>  主要是了解慢查询分析的各种参数 一：（ 1.slow_query_log用来开启，2.long_query_time设置慢查询的阈值，3.slow_query_log_file设置日志文件的存放路径等等   ） 二：mysqldumpslow工具用来分析日志，查找、分析SQL</p></li><li><p>mybatis防止注入？这个看了两篇文章，<a href="https://mp.weixin.qq.com/s/TnODauaU3y3GdT7zTjWkGw">文章1</a>，<a href="https://www.freebuf.com/vuls/240578.html">文章2</a>，重点关注在三个方面like，in和order by。—————-1.order必须的使用$，设置白名单进行解决，2.like使用 SQL concat() 函数解决，3.in使用foreach进行解决</p></li><li><p>数据库的事务可能出现的四种错误：1.丢失更新 ，2.脏读（读到别人没提交的数据） ，3.不可重复读（两次都出现不一样），4.幻读（两次都出来新增加了数据）</p></li><li><p>数据库的隔离级别和传播行为：1.读未提交，2.读已提交，3.可重复读，4.可串行化  ；InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读） </p><ol start="7"><li><p>TransactionDefinition.PROPAGATION_REQUIRED：使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p></li><li><p>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p></li><li><p>TransactionDefinition.PROPAGATION_NESTED:如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p><ol><li>在外部方法未开启事务的情况下<code>Propagation.NESTED</code>和<code>Propagation.REQUIRED</code>作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。</li><li>如果外部方法开启事务的话，<code>Propagation.NESTED</code>修饰的内部方法属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务。</li></ol></li><li><p>TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p></li><li><p>TransactionDefinition.PROPAGATION_SUPPORTS: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p></li><li><p>TransactionDefinition.PROPAGATION_NOT_SUPPORTED: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p></li><li><p>TransactionDefinition.PROPAGATION_NEVER: 以非事务方式运行，如果当前存在事务，则抛出异常。</p></li></ol></li><li><p>InnoDB的行锁？</p><p><code>InnoDB</code> 实现了以下两种类型的行锁。</p><ul><li>共享锁（<code>S</code>）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排他锁（<code>X</code>)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li></ul><p>另外，为了允许行锁和表锁共存，实现多粒度锁机制，<code>InnoDB</code> 还有两种内部使用的意向锁（<code>Intention Locks</code>），这两种意向锁都是<strong>表锁</strong>。</p><ul><li>意向共享锁（<code>IS</code>）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该<strong>表</strong>的 <code>IS</code>锁。</li><li>意向排他锁（<code>IX</code>）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该<strong>表</strong>的 <code>IX</code>锁。</li></ul><ol><li>意向锁是 <code>InnoDB</code> 自动加的，不需用户干预。对于 <code>UPDATE</code>、<code>DELETE</code> 和 <code>INSERT</code> 语句，<code>InnoDB</code>会自动给涉及数据集加排他锁（X)；<strong>对于普通 SELECT 语句，<code>InnoDB</code> 不会加任何锁</strong>；事务可以通过以下语句显式给记录集加共享锁或排他锁。<ol><li>共享锁（S）：<code>SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</code>。</li><li>排他锁（X)：<code>SELECT * FROM table_name WHERE ... FOR UPDATE</code>。</li></ol></li><li><strong>InnoDB行锁</strong>不是一次性上锁并且支持锁升级</li><li><strong>InnoDB 行锁</strong>是通过给索引上的索引项加锁来实现的<ol><li>在不通过索引条件查询的时候，<code>InnoDB</code> 确实使用的是表锁</li><li>由于 <code>MySQL</code> 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的</li><li>当表有多个索引的时候，不同的事务可以使用不同的索引锁定<strong>不同的行，并不是相同的行！！！</strong></li></ol></li></ol></li><li><p>mysql的七种锁：<a href="https://mp.weixin.qq.com/s/pWHCieOwAdCrz8cauduWlQ">地址</a></p><ol><li><p>(1)共享&#x2F;排它锁(Shared and Exclusive Locks)：分为表锁和行锁<br>(2)意向锁(Intention Locks)：是表级锁<br>(3)记录锁(Record Locks)：<strong>它封锁索引记录</strong>，例如：select * from t where id&#x3D;1 for update;</p><p>(4)间隙锁(Gap Locks)：<strong>它封锁索引记录中的间隔</strong>，或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围；间隙锁的主要目的，就是为了防止其他事务在间隔中插入数据<br>(5)临键锁(Next-key Locks)：<strong>是记录锁与间隙锁的组合</strong>，它的封锁范围，既包含索引记录，又包含索引区间<br>(6)插入意向锁(Insert Intention Locks)：<strong>是间隙锁(Gap Locks)的一种</strong>（所以，也是实施在索引上的），它是专门针对insert操作的；多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此<br>(7)自增锁(Auto-inc Locks)：是表锁，自增锁是一种特殊的表级别锁</p></li></ol></li><li><p>不同隔离级别上使用的锁</p><ol><li>三，可重复读(Repeated Read, RR)<ol><li>普通的select使用快照读(snapshot read)</li><li>加锁的select(select … in share mode &#x2F; select … for update), update, delete等语句；在唯一索引上使用唯一的查询条件，会使用记录锁(record lock)；范围查询条件，会使用间隙锁与临键锁</li></ol></li><li>四，读提交(Read Committed, RC)<ol><li>普通读是快照读；</li><li>加锁的select, update, delete等语句，除了在外键约束检查(foreign-key constraint checking)以及重复键检查(duplicate-key checking)时会封锁区间，其他时刻都只使用记录锁</li></ol></li></ol></li><li><p>MVCC？<a href="https://mp.weixin.qq.com/s/Jeg8656gGtkPteYWrG5_Nw">地址</a>  <a href="https://mp.weixin.qq.com/s/R3yuitWpHHGWxsUcE0qIRQ">地址二</a> <a href="https://mp.weixin.qq.com/s/qHzb6oPrrbAPoIlfLJVNAg">地址三，主要是搞懂一致性读也叫快照读，其他读为当前读</a></p><ol><li><p><code>MVCC</code>只在 <code>REPEATABLE READ</code>和 <code>READ COMMITTED</code>两个隔离级别下工作。其他两个隔离级别都和<code>MVCC</code>不兼容，因为 <code>READ UNCOMMITTED</code>总是读取最新的数据行，而不是符合当前事务版本的数据行。而 <code>SERIALIZABLE</code>则会对所有读取的行都加锁。</p></li><li><p><code>READ COMMITTD</code>在每一次进行普通<code>SELECT</code>操作前都会生成一个<code>ReadView</code>，而<code>REPEATABLE READ</code>只在第一次进行普通<code>SELECT</code>操作前生成一个<code>ReadView</code>，之后的查询操作都重复这个<code>ReadView</code>就好了。</p></li><li><p>隐藏字段（<code>trx_id</code>列：<strong>mysql5.7中，有写入操作的时候才分配trx_id</strong>和roll_pointer列），Undo日志</p></li><li><p>在事务生成<code>readview</code>时，会把当前系统中正在执行的读写事务写入到<code>m_ids</code>列表中，另外还会存储两个值：</p><ul><li><code>min_trx_id</code>：该值代表生成<code>readview</code>时<code>m_ids</code>中的最小值。</li><li><code>max_trx_id</code>：该值代表生成<code>readview</code>时系统中应该分配给下一个事务的id值。</li></ul><p>所以判断可见性的步骤就是：</p><ul><li>如果记录的<code>trx_id</code>列小于<code>min_trx_id</code>，说明肯定可见。</li><li>如果记录的<code>trx_id</code>列大于<code>max_trx_id</code>，说明肯定不可见。<ul><li>如果记录的<code>trx_id</code>列在<code>min_trx_id</code>和<code>max_trx_id</code>之间，就要看一下该<code>trx_id</code>在不在<code>m_ids</code>列表中，如果在，说明不可见，否则可见。</li></ul></li></ul></li></ol></li><li><p>数据库连接池怎么设计？<a href="https://blog.csdn.net/shuaihj/article/details/14223015">地址</a>  2、多数据库服务器和多用户，  1、并发问题，3、事务处理，    4、连接池的分配与释放，5、连接池的配置与维护</p></li><li><p>drop、delete与truncate的区别？用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate —-<a href="https://www.cnblogs.com/zhizhao/p/7825469.html">地址</a></p></li><li><p>复杂SQL</p><ol><li><p>Order by，Group by， Like</p></li><li><p>子查询（分清相关子查询和非相关子查询，not的话理解not in和not exist就行了）</p><ol><li><p>not in</p><p><img src="/img/OIP-C.jpg" data-original="/assets/image-20210316201158101.png" alt="image-20210316201158101"></p></li><li><p>Some与 All子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>找出工资最低的教师姓名 <span class="keyword">Select</span> Tname <span class="keyword">From</span> Teacher <span class="keyword">Where</span> Salary <span class="operator">&lt;=</span> <span class="keyword">all</span> ( <span class="keyword">Select</span> Salary <span class="keyword">From</span> Teacher ); </span><br><span class="line"><span class="number">2.</span>找出<span class="number">001</span>号课成绩不是最高的所有学生的学号</span><br><span class="line"><span class="keyword">Select</span> S# <span class="keyword">From</span> SC</span><br><span class="line"><span class="keyword">Where</span> C# <span class="operator">=</span> “<span class="number">001</span>” <span class="keyword">and</span> </span><br><span class="line">Score <span class="operator">&lt;</span> <span class="keyword">some</span> ( <span class="keyword">Select</span> Score <span class="keyword">From</span> SC <span class="keyword">Where</span> C# <span class="operator">=</span> “<span class="number">001</span>” );</span><br><span class="line"><span class="number">3.</span>找出所有课程都不及格的学生姓名(相关子查询)</span><br><span class="line"><span class="keyword">Select</span> Sname <span class="keyword">From</span> Student</span><br><span class="line"><span class="keyword">Where</span> <span class="number">60</span> <span class="operator">&gt;</span> <span class="keyword">all</span> ( <span class="keyword">Select</span> Score <span class="keyword">From</span> SC</span><br><span class="line"><span class="keyword">Where</span> S# <span class="operator">=</span> Student.S# );</span><br></pre></td></tr></table></figure></li><li><p>NOT Exist</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>检索学过<span class="number">001</span>号教师主讲的所有课程的所有同学的姓名</span><br><span class="line"><span class="keyword">Select</span> Sname <span class="keyword">From</span> Student</span><br><span class="line"><span class="keyword">Where</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="operator">/</span><span class="operator">/</span>不存在</span><br><span class="line">( <span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">From</span> Course <span class="operator">/</span><span class="operator">/</span>有一门<span class="number">001</span>教师主讲课程</span><br><span class="line"><span class="keyword">Where</span> Course.T# <span class="operator">=</span> ‘<span class="number">001</span>’ <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="operator">/</span><span class="operator">/</span>该同学没学过</span><br><span class="line">( <span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">From</span> SC</span><br><span class="line"><span class="keyword">Where</span> S# <span class="operator">=</span> Student.S# <span class="keyword">and</span> C# <span class="operator">=</span> Course.C# ) );</span><br><span class="line">上述语句的意思：不存在有一门<span class="number">001</span>号教师主讲的课程该同学没学过</span><br><span class="line"><span class="number">2.</span>列出至少学过<span class="number">98030101</span>号同学学过所有课程的同学的学号</span><br><span class="line"><span class="keyword">Select</span> DISTINC S# <span class="keyword">From</span> SC SC1</span><br><span class="line"><span class="keyword">Where</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="operator">/</span><span class="operator">/</span>不存在</span><br><span class="line">( <span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">From</span> SC SC2 <span class="operator">/</span><span class="operator">/</span>有一门课程</span><br><span class="line"><span class="keyword">Where</span> SC2.S# <span class="operator">=</span> ‘<span class="number">98030101</span>’ <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="operator">/</span><span class="operator">/</span>该同学没学过</span><br><span class="line">( <span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">From</span> SC</span><br><span class="line"><span class="keyword">Where</span> C# <span class="operator">=</span> SC2.C# <span class="keyword">and</span> S# <span class="operator">=</span> SC1.S# ) );</span><br><span class="line"><span class="number">3.</span>已知SPJ(Sno, Pno, Jno, Qty), 其中Sno供应商号，Pno零件号，</span><br><span class="line">Jno工程号，Qty数量，列出至少用了供应商S1供应的全部零件的工程号</span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">DISTINCT</span> Jno <span class="keyword">From</span> SPJ SPJ1</span><br><span class="line"><span class="keyword">Where</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="operator">/</span><span class="operator">/</span>不存在</span><br><span class="line">( <span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">From</span> SPJ SPJ2 <span class="operator">/</span><span class="operator">/</span>有一种S1的零件</span><br><span class="line"><span class="keyword">Where</span> SPJ2.Sno <span class="operator">=</span> ‘S1’ <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="operator">/</span><span class="operator">/</span>该工程没用过</span><br><span class="line">( <span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">From</span> SPJ SPJ3</span><br><span class="line"><span class="keyword">Where</span> SPJ3.Pno <span class="operator">=</span> SPJ2.Pno </span><br><span class="line"><span class="keyword">and</span> SPJ3.Jno <span class="operator">=</span> SPJ1.Jno ) );</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>mysql架构？</p><ol><li><p>单节点的可用性？单点系统存在的问题：可用性问题，性能瓶颈问题  <a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959480&idx=1&sn=337bd74410a6bef616128fd17abd08a8&scene=21#wechat_redirect">文章</a></p><ol><li>shadow-master是一种常见的解决单点系统可用性问题的方案</li><li>减少与单点的交互，是存在单点的系统优化的核心方向，常见方法有批量写，客户端缓存</li><li>水平扩展也是提升单点系统性能的好方案</li></ol></li><li><p>如何保证主库写高可用？和主库一致性问题？2020 <a href="https://mp.weixin.qq.com/s/_tT4L3ukmktUV3K8g7ZmeQ">https://mp.weixin.qq.com/s/_tT4L3ukmktUV3K8g7ZmeQ</a></p><ol><li>保证高可用：通过双主架构，并设置双向同步，以冗余写库的方式，保证写库的高可用</li><li>主库一致性问题：<ol><li>两个主库同时提供服务—-&gt;使用相同步长，不同初始值   或者    业务自己生成id</li><li>只有一个写库提供服务—-&gt;shadow-master（keepalived+vip）内网DNS探测</li></ol></li></ol></li><li><p>数据库的架构2019 <a href="https://mp.weixin.qq.com/s/3Q_ODwpbpCf3zcH57xUf4g">https://mp.weixin.qq.com/s/3Q_ODwpbpCf3zcH57xUf4g</a>   <a href="https://mp.weixin.qq.com/s/6zMc-IVBGRI788694ZKQig">https://mp.weixin.qq.com/s/6zMc-IVBGRI788694ZKQig</a></p><ol><li>数据库分组架构（主从同步）究竟解决什么问题？<ol><li>线性提升数据库读性能</li><li>通过消除读写锁冲突提升数据库写性能</li><li>通过冗余从库实现数据的“读高可用”</li></ol></li><li>分片架构（水平切分，这里特指进行分库）究竟解决什么问题？<ol><li>线性提升数据库写性能，需要注意的是，分组架构是不能线性提升数据库写性能的</li><li>降低单库数据容量</li></ol></li><li>垂直切分（这里特指进行分库）解决什么问题？<ol><li>垂直切分即可以降低单库的数据量，还可以降低磁盘IO从而提升吞吐量，但它与业务结合比较紧密，并不是所有业务都能够进行垂直切分的。</li></ol></li></ol></li><li><p>数据库主从一致性问题2018 <a href="https://mp.weixin.qq.com/s/c1mOxGeoJzlWC1YkkbDRgA">https://mp.weixin.qq.com/s/c1mOxGeoJzlWC1YkkbDRgA</a> <a href="https://mp.weixin.qq.com/s/5JYtta9aMGcic7o_ejna-A">https://mp.weixin.qq.com/s/5JYtta9aMGcic7o_ejna-A</a>  2016 <a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959442&idx=1&sn=feb8ff75385d8031386e120ef3535329&scene=21#wechat_redirect">文章</a></p><ol><li><p>方案一：忽略</p></li><li><p>方案二：强制读主</p></li><li><p>方案三：进行选择性读主</p><p>（1）写主库</p><p>（2）将哪个库，哪个表，哪个主键三个信息拼装一个key设置到cache里，这条记录的超时时间，设置为“主从同步时延”</p></li><li><p>方案四：使用数据库中间件</p></li></ol></li><li><p>缓存和数据库一致性问题 2016- <a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=404202261&idx=1&sn=1b8254ba5013952923bdc21e0579108e&scene=21#wechat_redirect">文章</a>  2016- <a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=404308725&idx=1&sn=1a25ce76dd1956014ceb8a011855268e&scene=21#wechat_redirect">文章</a></p><ol><li><p>由于数据库层面的读写并发，引发的数据库与缓存数据不一致的问题（本质是后发生的读请求先返回了），可能通过两个小的改动解决：</p><p>（1）修改服务Service连接池，id取模选取服务连接，能够保证同一个数据的读写都落在同一个后端服务上</p><p>（2）修改数据库DB连接池，id取模选取DB连接，能够保证同一个数据的读写在数据库层面是串行的</p></li></ol></li><li><p>主从DB与cache一致性   <a href="https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453149368&idx=2&sn=75d6ba3523303d9cac1f1c367209ef89&scene=21#wechat_redirect">别人的文章</a></p><ol><li><p>在“异常时序”或者“读从库”导致脏数据入缓存时，可以用<strong>二次异步淘汰</strong>的“<strong>缓存双淘汰</strong>”法来解决缓存与数据库中数据不一致的问题，具体实施至少有三种方案：</p><p>（1）timer异步淘汰（本文没有细讲，本质就是起个线程专门异步二次淘汰缓存）</p><p>（2）总线异步淘汰</p><p>（3）读binlog异步淘汰</p></li></ol></li><li></li><li></li><li></li><li><p>InnoDB的架构？</p></li><li><p><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOzxNhju1kPZoibDic1QZmOQRaBA28XrpWh8F5YQQmvct0jVhQxF1PrGAXukiaKpE1gFnbibibUgiayJBH1A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p></li><li><p>InnoDB整体也分为三层：</p><p>（1）<strong>内存结构</strong>(In-Memory Structure)，这一层在MySQL服务进程内；</p><p>（2）<strong>OS Cache</strong>，这一层属于内核态内存；</p><p>（3）<strong>磁盘结构</strong>(On-Disk Structure)，这一层在文件系统上；</p></li><li><p>下面介绍的都是内存结构，不是磁盘结构</p></li><li><p>缓冲池(buffer pool)技术？ <a href="https://mp.weixin.qq.com/s/zKHNaWY5AS0OMmag1mQTKQ">https://mp.weixin.qq.com/s/zKHNaWY5AS0OMmag1mQTKQ</a></p><ol><li>InnoDB的缓冲池缓存什么？有什么用？（时间）缓存<strong>表数据与索引数据</strong>，把磁盘上的数据加载到缓冲池，避免每次访问都进行磁盘IO，起到加速访问的作用。</li><li>什么是预读？（空间）磁盘读写，并不是按需读取，而是按页读取，一次至少读一页数据（一般是4K），如果未来要读取的数据就在页中，就能够省去后续的磁盘IO，提高效率</li></ol></li><li><p>可能存在的问题？</p><p>（1）预读失效：由于预读(Read-Ahead)，提前把页放入了缓冲池，但最终MySQL并没有从页中读取数据，称为预读失效</p><p>（2）缓冲池污染：当某一个SQL语句，要批量扫描大量数据时，可能导致把缓冲池的所有页都替换出去，导致大量热数据被换出，MySQL性能急剧下降，这种情况叫缓冲池污染</p></li><li><p>怎么解决？</p><ol><li>预读失效：将缓冲池分为<strong>老生代和新生代</strong>，入缓冲池的页，优先进入老生代，页被访问，才进入新生代，以解决预读失效的问题</li><li>）缓冲池污染：页被访问，且在老生代<strong>停留时间超过配置阈值</strong>的，才进入新生代，以解决批量数据访问，大量热数据淘汰的问题</li></ol></li><li><p>什么是InnoDB的写缓冲？</p><ol><li>它是一种应用在<strong>非唯一普通索引页</strong>(non-unique secondary index page)不在缓冲池中，对页进行了写操作，并不会立刻将磁盘页加载到缓冲池，而仅仅记录缓冲变更(buffer changes)，等未来数据被读取时，再将数据合并(merge)恢复到缓冲池中的技术。写缓冲的<strong>目的</strong>是降低写操作的磁盘IO，提升数据库性能。适用于业务是写多读少，或者不是写后立刻读取</li></ol></li><li><p>为什么写缓存仅适用于非唯一普通索引？</p><ol><li>如果索引设置了唯一(unique)属性，在进行修改操作时，InnoDB必须进行唯一性检查。也就是说，索引页即使不在缓冲池，磁盘上的页读取无法避免(否则怎么校验是否唯一？)，此时就应该直接把相应的页放入缓冲池再进行修改，而不应该再整写缓冲这个幺蛾子。</li></ol></li><li><p>除了数据页被访问，还有哪些场景会触发刷写缓冲中的数据呢？</p><ol><li><p>（1）有一个后台线程，会认为数据库空闲时；</p><p>（2）数据库缓冲池不够用时；</p><p>（3）数据库正常关闭时；</p><p>（4）redo log写满时；</p></li></ol></li><li></li><li></li><li><p>redo log的三层架构：</p><ol><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxw2ks1ClNK3j3mIPIj9PyHBXPvbHWwGKhZEyw7zajPz7ibL43l2CpZVoeicQMWLiaKxCicb5oODk6KSQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li><li><strong>粉色</strong>，是InnoDB的一项很重要的内存结构(In-Memory Structure)，日志缓冲区(Log Buffer)，这一层，是MySQL应用程序用户态</li><li><strong>屎黄色</strong>，是操作系统的缓冲区(OS cache)，这一层，是OS内核态</li><li><strong>蓝色</strong>，是落盘的日志文件</li></ol></li><li><p>各种缓存的意义？</p><ol><li>操作系统为什么要缓冲数据到OS cache里，而不直接刷盘（flush，fsync）呢？这里就是将“每次写”优化为“批量写”，以提高操作系统性能。</li><li>数据库为什么要缓冲数据到Log Buffer里，而不是直接write呢？这也是“每次写”优化为“批量写”思路的体现，以提高数据库性能。</li></ol></li><li><p>MySQL事务提交时刷redo log有三种策略：</p><ol><li>（1）0：每秒write一次OS cache，同时fsync刷磁盘，性能好；<br>（2）1：每次都write入OS cache，同时fsync刷磁盘，一致性好；<br>（3）2：每次都write入OS cache，每秒fsync刷磁盘，折衷；</li></ol></li><li></li><li></li><li><p>RedoLog 和UndoLog的区别？ <a href="https://mp.weixin.qq.com/s/R3yuitWpHHGWxsUcE0qIRQ">https://mp.weixin.qq.com/s/R3yuitWpHHGWxsUcE0qIRQ</a></p><ol><li><code>redo log</code>的作用是为<strong>持久化</strong>而生的。写完内存，如果数据库挂了，那我们可以通过<code>redo log</code>来恢复内存还没来得及刷到磁盘的数据，将<code>redo log</code>加载到内存里边，那内存就能恢复到挂掉之前的数据了。（具体怎么恢复还不懂）</li><li><code>undo log</code>主要有两个作用：回滚和多版本控制(MVCC)</li><li>一句话，redo日志用于保障，已提交事务的ACID特性。</li><li>一句话，undo日志用于保障，未提交事务不会对数据库的ACID特性产生影响。</li></ol></li><li><p>为什么要有undo日志？</p><ol><li>数据库事务未提交时，会将事务修改数据的镜像（即修改前的旧版本）存放到undo日志里，当事务回滚时，或者数据库奔溃时，可以利用undo日志，即旧版本数据，撤销未提交事务对数据库产生的影响。</li></ol></li><li><p>什么是回滚段？</p><p>存储undo日志的地方，是回滚段。undo日志和回滚段和InnoDB的MVCC密切相关，回滚段里的数据，其实是历史数据的快照（snapshot），这些数据是不会被修改，select可以肆无忌惮的并发读取他们</p></li><li></li><li></li><li></li><li><p>主从复制的原理？<a href="https://mp.weixin.qq.com/s/eEWMSTAUF1H-gFBx26jujw">https://mp.weixin.qq.com/s/eEWMSTAUF1H-gFBx26jujw</a></p><ol><li>原理<ol><li>MySql主库在事务提交时会把数据变更作为事件记录在二进制日志Binlog中；<ol start="2"><li>主库推送二进制日志文件Binlog中的事件到从库的中继日志Relay Log中，之后从库根据中继日志重做数据变更操作，通过逻辑复制来达到主库和从库的数据一致性；</li></ol></li></ol></li><li>主从复制的并发重放Relay Log  <a href="https://mp.weixin.qq.com/s/pP2f7CYbT7ftM0tvk9c4mQ">https://mp.weixin.qq.com/s/pP2f7CYbT7ftM0tvk9c4mQ</a><ol><li>mysql5.6：按照库并行复制，建议使用“多库”架构；</li><li>mysql5.7：按照GTID并行复制：将主库上同时并行执行的事务，分为一组，编一个号，这些事务在从库上的回放可以并行执行 ，和原来的日志相比，多了last_committed和sequence_number，last_committed是事务提交时，上次事务提交的编号，如果具备相同的last_committed，说明它们在一个组内，可以并发回放执行</li></ol></li></ol></li><li><p>主从复制的三个线程？</p><ol><li>MySql通过三个线程来完成主从库间的数据复制，其中Binlog Dump线程跑在主库上，I&#x2F;O线程和SQL线程跑着从库上；</li><li>当在从库上启动复制时，首先创建I&#x2F;O线程连接主库，主库随后创建Binlog Dump线程读取数据库事件并发送给I&#x2F;O线程，I&#x2F;O线程获取到事件数据后更新到从库的中继日志Relay Log中去，之后从库上的SQL线程读取中继日志Relay Log中更新的数据库事件并应用，如下图所示。</li><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/CKvMdchsUwlc9vLQe9Ugu4Q3ZUQu9ezDKRmmK2hsjoicDbdDF7PTgTxAqZy9CD3mow4wOhlMK4JTVRBVFygSnWg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol></li><li><p>BinLog的日志格式？<a href="https://blog.csdn.net/ouyang111222/article/details/50300851">https://blog.csdn.net/ouyang111222/article/details/50300851</a></p><ol><li><p>Statement：每一条会修改数据的sql都会记录在binlog中。</p><ol><li>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。</li><li>缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。另外mysql 的复制,像一些特定函数功能，slave可与master上要保持一致会有很多相关问题。</li></ol></li><li><p>Row：</p><ol start="3"><li>优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题.<ol start="2"><li>缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。</li></ol></li></ol></li><li><p>Mixed</p></li></ol></li></ol></li></ol><p>故障恢复</p><p>故障恢复涉及到如何保证原子性和持久性—看了一个多小时没看懂</p><ol><li><p>Undo型日志：“将事务改变的所有数据写到磁盘前不能提交该事务”</p><p><img src="/img/OIP-C.jpg" data-original="/assets/image-20210328103835597.png" alt="image-20210328103835597"></p><p><img src="/img/OIP-C.jpg" data-original="/assets/image-20210328103941276.png" alt="image-20210328103941276"></p><p><img src="/img/OIP-C.jpg" data-original="/assets/image-20210328104654489.png" alt="image-20210328104654489"></p></li><li><p><img src="/img/OIP-C.jpg" data-original="/assets/image-20210328105037518.png" alt="image-20210328105037518"></p><p><img src="/img/OIP-C.jpg" data-original="/assets/image-20210328145951596.png" alt="image-20210328145951596"></p><p><img src="/img/OIP-C.jpg" data-original="/assets/image-20210328150247001.png" alt="image-20210328150247001"></p><p><img src="/img/OIP-C.jpg" data-original="/assets/image-20210328150420149.png" alt="image-20210328150420149"></p></li></ol><h1 id="文章汇总"><a href="#文章汇总" class="headerlink" title="文章汇总"></a>文章汇总</h1><ol><li>SQL与索引优化合集  <a href="https://mp.weixin.qq.com/s/3xkLTe7r388lRq-SBQllXw">https://mp.weixin.qq.com/s/3xkLTe7r388lRq-SBQllXw</a></li><li>索引，一文搞定   <a href="https://mp.weixin.qq.com/s/woz5lkQwyJZNmoiiJZy7NA">https://mp.weixin.qq.com/s/woz5lkQwyJZNmoiiJZy7NA</a></li><li>MySql 的各种锁   <a href="https://mp.weixin.qq.com/s/pWHCieOwAdCrz8cauduWlQ">https://mp.weixin.qq.com/s/pWHCieOwAdCrz8cauduWlQ</a></li><li>InnoDB的各种缓存    <a href="https://mp.weixin.qq.com/s/zKHNaWY5AS0OMmag1mQTKQ">https://mp.weixin.qq.com/s/zKHNaWY5AS0OMmag1mQTKQ</a></li></ol><p>​    </p><p>​    </p><p>​    </p><p>​    </p><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mysql面试题&quot;&gt;&lt;a href=&quot;#mysql面试题&quot; class=&quot;headerlink&quot; title=&quot;mysql面试题&quot;&gt;&lt;/a&gt;mysql面试题&lt;/h1&gt;&lt;h2 id=&quot;记住数据库的几个大的模块&quot;&gt;&lt;a href=&quot;#记住数据库的几个大的模块&quot; cla</summary>
      
    
    
    
    <category term="面试题" scheme="http://www.sion-io.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="mysql" scheme="http://www.sion-io.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-面试题</title>
    <link href="http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-05-12T08:42:17.416Z</published>
    <updated>2024-05-12T08:48:19.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h2><p><a href="https://mp.weixin.qq.com/s/yDiIZW3TQENLOFmzYH7NOw">https://mp.weixin.qq.com/s/yDiIZW3TQENLOFmzYH7NOw</a></p><p><a href="https://mp.weixin.qq.com/s/nlyc9jhriCGyt92WRoBZFw">https://mp.weixin.qq.com/s/nlyc9jhriCGyt92WRoBZFw</a></p><p><a href="https://mp.weixin.qq.com/s/Hv-pV9PvIrHQgM6ayg33bQ">https://mp.weixin.qq.com/s/Hv-pV9PvIrHQgM6ayg33bQ</a></p><p><a href="https://www.jianshu.com/p/807bc228dbc2">https://www.jianshu.com/p/807bc228dbc2</a></p><ol><li><p>单一职责原则：问题描述：定义是一个类应该只有一个发生变化的原因，比如一个类A负责两个职责，a1,a2，如果a1发生需求的变化，要修改类A的a1职责的变动，<strong>有可能</strong>引起a2的功能也发生故障，这样就耦合了</p><ol><li><pre><code class="java">//  以下是不对的public class Animal &#123;    public void eat() &#123;         if (kind.equals(&quot;rabbit&quot;)) &#123;        System.out.println(&quot;eat some carmine&quot;);    &#125;    if (kind.equals(&quot;tigger&quot;)) &#123;        System.out.println(&quot;eat some meat&quot;);    &#125;    &#125;    public void sleep() &#123;        System.out.println(&quot;sleeping ~~&quot;);    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 接口隔离原则：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</span><br><span class="line"></span><br><span class="line">3. 依赖倒置原则：他是这么定义的，高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      public class Cooker &#123;</span><br><span class="line">          public void cook(Potato potato) &#123;</span><br><span class="line">              System.out.println(&quot;开始做菜了&quot;);</span><br><span class="line">              System.out.println(potato.getFood());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      class Potato &#123;</span><br><span class="line">          public String getFood() &#123;</span><br><span class="line">              return &quot;酸辣土豆丝&quot;;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 改为</span><br><span class="line">      public interface FoodMaterial &#123;</span><br><span class="line">         String getFood();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      class Potato implements FoodMaterial&#123;</span><br><span class="line">         @Override</span><br><span class="line">         public String getFood() &#123;</span><br><span class="line">             return &quot;酸辣土豆丝&quot;;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      class Chicken implements FoodMaterial&#123;</span><br><span class="line">         @Override</span><br><span class="line">         public String getFood() &#123;</span><br><span class="line">             return &quot;可乐鸡翅&quot;;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      public class Cooker &#123;</span><br><span class="line">      </span><br><span class="line">         public void cook(FoodMaterial foodMaterial) &#123;</span><br><span class="line">             System.out.println(&quot;开始做菜了&quot;);</span><br><span class="line">             System.out.println(foodMaterial.getFood());</span><br><span class="line">         &#125;</span><br><span class="line">         public static void main (String []args) &#123;</span><br><span class="line">             Cooker cooker = new Cooker();</span><br><span class="line">             cooker.cook(new Potato());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol></li><li><p>开闭原则：对于扩展是开放的，对于修改是关闭的，比如通过继承重写某个方法来得到想要的结果</p></li><li><p>里氏替换原则：所有引用基类的地方都必须能透明地使用其子类的对象，</p></li><li><p>迪米特原则：一个对象应当对其他对象有尽可能少的了解，不和陌生人说话，一个类尽可能的少的暴露public的方法和属性。权限控制关键字也要做好控制，两个类的耦合太牢固，随着业务的复杂度的提升，越改越麻烦，也越容易出错</p></li></ol><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><ol><li>Strategy角色：负责决定实现策略所必需的接口(API)。在示例程序中,由 Strategy接口扮演此角色</li><li>Concrete Strategy角色：负责实现 Strategy角色的接口(API),即负责实现具体的策略(战略、方向、方法和算法)。在示例程序中,由 Winningstrategy类和 Probstrategy类扮演此角色。</li><li>Context角色：负责使用 Strategy角色。 Context角色保存了 Concrete Strategy角色的实例,并使用Concretestrategy角色去实现需求(总之,还是要调用 Strategy角色的接口(API))在示例程序中由 Player类扮演此角色。</li></ol><p>这样看起来程序好像变复杂了,其实不然。例如,当我们想要通过改善算法来提高算法的处理速度时,如果使用了 Strategy模式,就不必修改 Strategy 角色的接口(API)了,仅仅修改Concrete Strategy角色即可。而且,使用委托这种弱关联关系可以很方便地整体替换算法。例如,如果想比较原来的算法与改进后的算法的处理速度有多大区别,简单地替换下算法即可进行测试。</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><img src="/img/OIP-C.jpg" data-original="assets/image-20210321170330365.png" alt="image-20210321170330365" style="zoom:50%;" /><img src="/img/OIP-C.jpg" data-original="assets/image-20210321170335316.png" alt="image-20210321170335316" style="zoom:50%;" /><img src="/img/OIP-C.jpg" data-original="assets/image-20210321170342967.png" alt="image-20210321170342967" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计模式六大原则&quot;&gt;&lt;a href=&quot;#设计模式六大原则&quot; class=&quot;headerlink&quot; title=&quot;设计模式六大原则&quot;&gt;&lt;/a&gt;设计模式六大原则&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/yDiIZW3TQE</summary>
      
    
    
    
    <category term="面试题" scheme="http://www.sion-io.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="http://www.sion-io.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java框架</title>
    <link href="http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%A1%86%E6%9E%B6/</id>
    <published>2024-05-12T08:42:17.413Z</published>
    <updated>2024-05-12T10:11:14.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><h2 id="各种循环依赖的解决？"><a href="#各种循环依赖的解决？" class="headerlink" title="各种循环依赖的解决？"></a>各种循环依赖的解决？</h2><ol><li><p>singletonsCurrentlyInCreation：解决<strong>构造方法</strong>循环依赖的问题</p></li><li><p>prototypesCurrentlyInCreation：解决<strong>原型循环</strong>依赖的问题</p></li><li><p>Map&lt;String, Object&gt; singletonObjects； Map&lt;String, Object&gt; earlySingletonObjects； Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories：<strong>解决setter和Filed注入</strong>的循环依赖问题</p><ol><li><p>addSingleton  <strong>其中一次</strong>会在getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) <strong>两个参数</strong>中被调用</p></li><li><p>二级缓存：添加：向里面添加数据只有一个地方，就是上面说的<code>getSingleton(beanName)</code> <strong>一个参数</strong>里从三级缓存里挪过来<br> 移除：<code>addSingleton、addSingletonFactory、removeSingleton</code>从代码中可以看出添加单例、添加单例工厂<code>ObjectFactory</code>的时候都会删除二级缓存里面对应的缓存值，是互斥的</p></li><li><p>addSingletonFactory会在doCreateBean中被调用：<strong>三级缓存中存的是对象的相关的ObjectFactory，如果被代理并且产生了循环依赖，那么就会提前进行aop的织入操作，doCreateBean里面的织入就不用再次进行了</strong></p><ol><li><p>上面实现提前织入的代码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是doCreateBean方法initializeBean里面的</span></span><br><span class="line"><span class="comment">/** bean 初始化后置处理方法 */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="comment">// 如果需要，为 bean 生成代理对象</span></span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是doCreateBean方法里面的</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; &#123;</span><br><span class="line"><span class="comment">// 获取早期 bean 的引用，如果 bean 中的方法被 AOP 切点所匹配到，此时 AOP 相关逻辑会介入</span></span><br><span class="line"><span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean); <span class="comment">// 看下面的函数</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);<span class="comment">// 看AbstractAutoProxyCreator类，它实现了smartInstantiationAware接口</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其中的AbstractAutoProxyCreator.getEarlyBeanReference方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">   <span class="built_in">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">   <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h2 id="为什么需要三级缓存？"><a href="#为什么需要三级缓存？" class="headerlink" title="为什么需要三级缓存？"></a>为什么需要三级缓存？</h2><ol><li>为什么需要三级缓存？3级缓存在这里有什么目的呢？<ol><li>3级缓存里面保存的是对象工厂，这个对象工厂内部保留着最原生的对象引用，ObjectFactory的实现类，getObject()方法，它需要考虑一个问题。它到底要返回原生的，还是增强后的。getObject会判断当前这个早期实例 是否需要被增强，如果是，那么提前完成动态代理增强，返回代理对象。否则，返回原生对象。</li></ol></li></ol><h2 id="springioc的步骤？"><a href="#springioc的步骤？" class="headerlink" title="springioc的步骤？"></a>springioc的步骤？</h2><ol><li>getBean-&gt;doGetBean<ol><li>尝试获取缓存</li><li>解决原型依赖</li><li>合并beanDefinition</li><li>解决depend-on依赖</li></ol></li><li>getSingleton<ol><li>beforeSingletonCreation</li><li>afterSingletonCreation</li><li>addSingleton</li></ol></li><li>createBean<ol><li>处理 lookup-method 和 replace-method 配置</li><li>在 bean 初始化前应用后置处理resolveBeforeInstantiation（注意applyBeanPostProcessorsBeforeInstantiation和applyBeanPostProcessorsAfterInitialization的区别，前一个是InstantiationAwareBeanPostProcessor接口的，后一个是BeanPostProcessor接口的）</li></ol></li><li>doGetBean<ol><li>createBeanInstance</li><li>添加到三级缓存</li><li>populateBean</li><li>initializeBean<ol><li>若 bean 实现了 BeanNameAware、BeanFactoryAware、BeanClassLoaderAware 等接口，则向 bean 中注入相关对象</li><li>执行 bean 初始化前置操作</li><li>调用初始化方法invokeInitMethods</li><li>执行 bean 初始化后置操作</li></ol></li></ol></li></ol><h2 id="Spring生命周期详细描述"><a href="#Spring生命周期详细描述" class="headerlink" title="Spring生命周期详细描述?"></a>Spring生命周期详细描述?</h2><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93?id=_55-spring-%E4%B8%AD%E7%9A%84-bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">5.5 Spring 中的 bean 生命周期?</a></p><p>这部分网上有很多文章都讲到了，下面的内容整理自：<a href="https://yemengying.com/2016/07/14/spring-bean-life-cycle/">https://yemengying.com/2016/07/14/spring-bean-life-cycle/</a> ，除了这篇文章，再推荐一篇很不错的文章 ：<a href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a> 。</p><ul><li>Bean 容器找到配置文件中 Spring Bean 的定义。</li><li>Bean 容器利用 Java Reflection API 创建一个Bean的实例。</li><li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li><li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入Bean的名字。</li><li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li><li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li><li>如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含  init-method 属性，执行指定的方法。</li><li>如果有和加载这个 Bean的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li><li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ul><p>图示：</p><p><img src="/img/OIP-C.jpg" data-original="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/48376272.jpg" alt="Spring Bean 生命周期"></p><p>与之比较类似的中文版本:</p><p><img src="/img/OIP-C.jpg" data-original="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/5496407.jpg" alt="Spring Bean 生命周期"></p><h2 id="如何保证Bean的线程安全"><a href="#如何保证Bean的线程安全" class="headerlink" title="如何保证Bean的线程安全?"></a>如何保证Bean的线程安全?</h2><p><a href="https://blog.csdn.net/weixin_43727372/article/details/100324678">https://blog.csdn.net/weixin_43727372/article/details/100324678</a></p><ol><li>threadlocal </li><li>使用多例</li><li>设计时避免有状态</li></ol><h2 id="Spring中的AOP是如何实现的，jdk和CGLIB方法的区别"><a href="#Spring中的AOP是如何实现的，jdk和CGLIB方法的区别" class="headerlink" title="Spring中的AOP是如何实现的，jdk和CGLIB方法的区别?"></a>Spring中的AOP是如何实现的，jdk和CGLIB方法的区别?</h2><ol><li>AbstractAdvisorAutoProxyCreator实现了BeanFactoryAware接口，ioc容器为它做了啥？</li><li>AbstractAdvisorAutoProxyCreator作为InstantiationAwareBeanPostProcessor接口做了啥？<ol><li>解析 @Aspect 注解，并构建通知器aspectJAdvisorsBuilder.buildAspectJAdvisors<ol><li>beanType 判断当前 bean 是否是一个的 Aspect 注解类<ol><li>getAdvisorMethods 用于返回不包含 @Pointcut 注解的方法，为每个方法分别调用 getAdvisor 方法</li></ol></li></ol></li><li>createAopProxy<ol><li>获取适合当前方法的拦截器getInterceptorsAndDynamicInterceptionAdvice<ol><li>对于 PointcutAdvisor 类型的通知器，这里要调用通知器所持有的切点（Pointcut）对类和方法进行匹配，匹配成功说明应向当前方法织入通知逻辑</li></ol></li><li>invocation.proceed()执行拦截器链</li></ol></li></ol></li></ol><h2 id="spring怎么实现事务的？"><a href="#spring怎么实现事务的？" class="headerlink" title="spring怎么实现事务的？"></a>spring怎么实现事务的？</h2><p><a href="https://developer.ibm.com/zh/articles/j-master-spring-transactional-use/">https://developer.ibm.com/zh/articles/j-master-spring-transactional-use/</a></p><ol><li><p>步骤：</p><ol><li><blockquote><ol><li>编程式事务，在代码中硬编码。(不推荐使用)</li><li>声明式事务，在配置文件中配置（推荐使用）</li></ol><p><strong>声明式事务又分为两种：</strong></p><ol><li>基于XML的声明式事务</li><li>基于注解的声明式事务</li></ol></blockquote></li></ol></li><li><p>原理：</p><ol><li>AutoProxyRegistrar的InfrastructureAdvisorAutoProxyCreator 接口做了啥？Infrastructure（基础设施）</li><li>ProxyTransactionManagementConfiguration 做了啥？<ol><li>transactionAttributeSource：解析事务注解，就是获取注解中各种属性的值</li><li>transactionInterceptor：保存了事务属性信息transactionAttributeSource，事务管理器 txManager<ol><li>看看拦截器的invoke方法<ol><li>先获取事务相关的属性  transactionAttributeSource</li><li>再获取PlatformTransactionManager，如果事先没有添加指定任何transactionmanger （在@Transactional注解中可以指定）；最终会从容器中按照类型获取一个PlatformTransactionManager； </li><li>执行目标方法；；如果异常，获取到事务管理器，利用事务管理回滚操作；；如果正常，利用事务管理器，提交事务</li></ol></li></ol></li></ol></li></ol></li></ol><h2 id="Spring事务失效和解决方案？"><a href="#Spring事务失效和解决方案？" class="headerlink" title="Spring事务失效和解决方案？"></a>Spring事务失效和解决方案？</h2><ol><li>正确的设置 @Transactional 的 propagation 属性<ol><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。</li></ol></li><li>正确的设置 @Transactional 的 rollbackFor 属性</li><li>@Transactional 只能应用到 public 方法才有效</li><li>避免 Spring 的 AOP 的自调用问题</li></ol><h2 id="说说IOC和AOP？"><a href="#说说IOC和AOP？" class="headerlink" title="说说IOC和AOP？"></a>说说IOC和AOP？</h2><p>自己的总结：</p><ol><li>IoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个  Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC  的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</li><li>aop：AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度。Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib</li></ol><h4 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93?id=ioc">IoC</a></h4><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong>  IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体，  IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。  <strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</strong> 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个  Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC  的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p><p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p><p>推荐阅读：<a href="https://www.zhihu.com/question/23277575/answer/169698662">https://www.zhihu.com/question/23277575/answer/169698662</a></p><p><strong>Spring IoC的初始化过程：</strong> </p><p><img src="/img/OIP-C.jpg" data-original="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/SpringIOC%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="Spring IoC的初始化过程"></p><p>IoC源码阅读</p><ul><li><a href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></li></ul><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93?id=aop">AOP</a></h4><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p><p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img src="/img/OIP-C.jpg" data-original="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/SpringAOPProcess.jpg" alt="SpringAOPProcess"></p><p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p><h2 id="Spring-MVC容器的创建过程"><a href="#Spring-MVC容器的创建过程" class="headerlink" title="Spring MVC容器的创建过程"></a>Spring MVC容器的创建过程</h2><ol><li>一般情况下，我们会在一个 Web 应用中配置两个容器。一个容器用于加载 Web 层的类，比如我们的接口  Controller、HandlerMapping、ViewResolver 等。我们把这个容器叫做 web  容器。另一个容器用于加载业务逻辑相关的类，比如 service、dao  层的一些类。我们把这个容器叫做业务容器。在容器初始化的过程中，业务容器会先于 web 容器进行初始化。web  容器初始化时，会将业务容器作为父容器。<ol><li>业务容器的创建入口是 ContextLoaderListener 的 contextInitialized  方法。顾名思义，ContextLoaderListener 是用来监听 ServletContext 加载事件的。当  ServletContext 被加载后，监听器的 contextInitialized 方法就会被 Servlet 容器调用。 流程并不复杂，可简单总结为   创建容器 → 配置并刷新容器 → 设置容器到 ServletContext 中</li><li>业务容器是通过 ContextLoaderListener。那 Web 容器是通过什么创建的呢？答案是通过 DispatcherServlet，HttpServletBean 抽象类时，说过该类覆写了父类 HttpServlet 中的 init 方法。这个方法就是创建 Web 容器的入口。我们并未从上面的源码中发现创建容器的痕迹，我们发现 initServletBean 这个方法稍显奇怪，是个空方法。这个方法的访问级别为 protected，子类可进行覆盖。HttpServletBean 子类 FrameworkServlet 覆写了这个方法<ol><li>从 ServletContext 中获取 ContextLoaderListener 创建的容器</li><li>若 this.webApplicationContext !&#x3D; null 条件成立，仅设置父容器和刷新容器即可</li><li>尝试从 ServletContext 中获取容器，若容器不为空，则无需执行步骤4</li><li>创建容器，并将 rootContext 作为父容器</li><li>设置容器到 ServletContext 中</li></ol></li></ol></li></ol><h2 id="Spring-MVC-的各个相关Servlet类？"><a href="#Spring-MVC-的各个相关Servlet类？" class="headerlink" title="Spring MVC 的各个相关Servlet类？"></a>Spring MVC 的各个相关Servlet类？</h2><p>​<img src="/img/OIP-C.jpg" data-original="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15302319955704.jpg" alt="img"></p><ol><li>Http服务器相关，Servlet容器和spring的容器的区别：如果我们基于 Servlet 规范实现 Web 应用的话，HTTP 协议的处理过程就不需要我们参与了。这些工作交给 Servlet 容器就行了，我们只需要关心业务逻辑怎么实现即可</li><li>Servlet 与 ServletConfig：init 方法会在容器启动时由容器调用，也可能会在 Servlet 第一次被使用时调用，调用时机取决 load-on-start  的配置。容器调用 init 方法时，会向其传入一个 ServletConfig 参数。ServletConfig  是什么呢？顾名思义，ServletConfig 是一个和 Servlet 配置相关的接口。举个例子说明一下，我们在配置 Spring MVC 的  DispatcherServlet 时，会通过 ServletConfig 将配置文件的位置告知 DispatcherServlet</li><li>GenericServlet 实现了 Servlet 和 ServletConfig 两个接口，为这两个接口中的部分方法提供了简单的实现。</li><li>一般情况下，我们都是继承 GenericServlet 的子类 HttpServlet，该类是一个和 HTTP 协议相关的 Servlet。该类的关注点在于怎么处理 HTTP 请求，比如其定义了 doGet 方法处理 GET 类型的请求，定义了 doPost 方法处理 POST 类型的请求等。我们若需要基于 Servlet 写 Web 应用，应继承该类，并覆盖指定的方法。</li><li>FrameworkServlet：在HttpServlet中，其对不同方式的请求进行了分发，但是在DispatcherServlet中，由于需要使用同一的方式对不同的请求进行处理，因而其对各个请求方式进行了整合，FrameworkServlet重写了Service() 和 Doget，DoPost，等方法，这些方法会最终调用 DispatcherServlet 的 doService(request, response);–&gt; doDispatch(request, response);  最终所有都到达doDispatch方法</li><li>DispatcherServlet：DispatcherServlet 主要的职责相信大家都比较清楚了，即协调各个组件工作。除此之外，DispatcherServlet 还有一个重要的事情要做，即初始化各种组件，比如 HandlerMapping、HandlerAdapter 等</li></ol><h2 id="Spring-MVC-的接受请求的过程"><a href="#Spring-MVC-的接受请求的过程" class="headerlink" title="Spring MVC 的接受请求的过程"></a>Spring MVC 的接受请求的过程</h2><p><img src="/img/OIP-C.jpg" data-original="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15300766829012.jpg" alt="img"></p><ol><li>首先，用户的浏览器发出了一个请求，这个请求经过互联网到达了我们的服务器。Servlet  容器首先接待了这个请求，并将该请求委托给 DispatcherServlet 进行处理。</li><li>接着 DispatcherServlet  将该请求传给了处理器映射组件  HandlerMapping，并获取到适合该请求的拦截器和处理器。在获取到处理器后，DispatcherServlet  还不能直接调用处理器的逻辑，需要进行对处理器进行适配。<ol><li>这里getHandler()方法就是通过遍历当前Spring容器中所有定义的HandlerMapping对象，通过调用它们的getHandler()方法，看当前的HandlerMapping能否将当前request映射到某个handler，也就是某个Controller方法上，如果能够映射到，则说明该handler能够处理当前请求</li></ol></li><li>对处理器进行适配，根据获取到的handler，查找当前容器中支持将当前request适配到该handler的HandlerAdapter；<ol><li>MVC中适配器模式解释：<a href="https://blog.csdn.net/u010288264/article/details/53835185">地址</a>    <a href="https://blog.csdn.net/a362212624/article/details/80431499">地址2</a></li><li>通过找到的handler，然后在当前Spring容器中找到能够支持将当前request请求适配到找到的handler上的HandlerAdapter。这里需要找到这样的适配器的原因是， 可以看到处理器（宽泛的概念Controller，以及HttpRequestHandler，Servlet，等等）的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用Controller方法，需要调用的时候就得不断是使用if else来进行判断是哪一种子类然后执行。那么如果后面要扩展（宽泛的概念Controller，以及HttpRequestHandler，Servlet，等等）Controller，就得修改原来的代码，这样违背了开闭原则（对修改关闭，对扩展开放）</li></ol></li><li>应用容器中所有拦截器的preHandle()方法，只有在所有的preHandle()方法都通过之后才会将当前请求交由具体的handler进行处理；</li><li>DispatcherServlet 通过处理器适配器  HandlerAdapter 调用处理器的逻辑，并获取返回值 ModelAndView。</li><li>应用容器中所有拦截器的postHandle()方法，以对当前请求进行后置处理；</li><li>之后，DispatcherServlet 需要根据  ModelAndView 解析视图。解析视图的工作由 ViewResolver 完成，若能解析成功，ViewResolver  会返回相应的视图对象 View。</li><li>在获取到具体的 View 对象后，最后一步要做的事情就是由 View 渲染视图，并将渲染结果返回给用户。</li></ol><h2 id="Spring用到了哪些设计模式"><a href="#Spring用到了哪些设计模式" class="headerlink" title="Spring用到了哪些设计模式"></a>Spring用到了哪些设计模式</h2><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring-Design-Patterns?id=%e6%80%bb%e7%bb%93">地址</a></p><ol><li><p>工厂设计模式 : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</p></li><li><p>代理设计模式 : Spring AOP 功能的实现。</p></li><li><p>单例设计模式 : Spring 中的 Bean 默认都是单例的。</p></li><li><p>适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式，具体看这个（在每个类型Advice（通知）都有对应的拦截器，MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor、ThrowsAdviceInterceptor。</p><p>Spring需要将每个Advice（通知）都封装成对应的拦截器类型，返回给容器，所以需要使用适配器模式对Advice进行转换。）：<a href="https://blog.csdn.net/adoocoke/article/details/8286902">地址</a>、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。   </p></li><li><p>模板方法模式 : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</p></li><li><p>包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</p></li><li><p>观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。</p></li></ol><h2 id="Spring-初始化过程"><a href="#Spring-初始化过程" class="headerlink" title="Spring 初始化过程"></a>Spring 初始化过程</h2><h2 id="SpringBoot核心自动装配原理"><a href="#SpringBoot核心自动装配原理" class="headerlink" title="SpringBoot核心自动装配原理"></a>SpringBoot核心自动装配原理</h2><p><a href="https://mp.weixin.qq.com/s/bSY_LdiDs1339lL9zEGl9Q">Guide</a></p><ol><li>什么是SpringBoot自动装配？SpringBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</li><li><code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合<ol><li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li><li><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类</li><li><code>@ComponentScan</code>：扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除<code>TypeExcludeFilter</code>和<code>AutoConfigurationExcludeFilter</code>。</li></ol></li><li>@EnableAutoConfiguration:实现自动装配的核心注解<ol><li><code>EnableAutoConfiguration</code> 只是一个简单地注解，自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类。<code>AutoConfigurationImportSelector</code> 类实现了 <code>ImportSelector</code>接口，也就实现了这个接口中的 <code>selectImports</code>方法，该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中<ol><li>第 1 步：用于获取<code>EnableAutoConfiguration</code>注解中的 <code>exclude</code> 和 <code>excludeName</code></li><li>第 2 步：获取需要自动装配的所有配置类，读取<code>META-INF/spring.factories</code></li><li>第 3 步：<code>@ConditionalOnXXX</code> 中的所有条件都满足，该类才会生效</li></ol></li></ol></li><li>其它：springboot的注解？<ol><li><img src="/img/OIP-C.jpg" data-original="/assets/image-20210322175315063.png" alt="image-20210322175315063"></li></ol></li></ol><h2 id="spring-security-认证流程"><a href="#spring-security-认证流程" class="headerlink" title="spring security 认证流程"></a>spring security 认证流程</h2><p><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200801190101-898185.png" alt="1595941718976"></p><p>让我们仔细分析认证过程：</p><ol><li>用户提交用户名、密码被SecurityFilterChain中的 UsernamePasswordAuthenticationFilter 过滤器获取到，<br>封装为请求Authentication，通常情况下是UsernamePasswordAuthenticationToken这个实现类。</li><li>然后过滤器将Authentication提交至认证管理器（AuthenticationManager）进行认证</li><li>认证成功后， AuthenticationManager 身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，<br>身份信息，细节信息，但密码通常会被移除） Authentication 实例。</li><li>SecurityContextHolder 安全上下文容器将第3步填充了信息的 Authentication ，通过<br>SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。</li><li>可以看出AuthenticationManager接口（认证管理器）是认证相关的核心接口，也是发起认证的出发点，它<br>的实现类为ProviderManager。而Spring Security支持多种认证方式，因此ProviderManager维护着一个<br>List 列表，存放多种认证方式，最终实际的认证工作是由<br>AuthenticationProvider完成的。咱们知道web表单的对应的AuthenticationProvider实现类为AbstractUserDetailsAuthenticationProvider，AbstractUserDetailsAuthenticationProvider的实现类为<br>DaoAuthenticationProvider，它的内部又维护着一个UserDetailsService负责UserDetails的获取。最终<br>AuthenticationProvider将UserDetails填充至Authentication。</li></ol><h2 id="spring-security-授权流程"><a href="#spring-security-授权流程" class="headerlink" title="spring security 授权流程"></a>spring security 授权流程</h2><p>通过快速上手我们知道，Spring Security可以通过 http.authorizeRequests() 对web请求进行授权保护。Spring<br>Security使用标准Filter建立了对web请求的拦截，最终实现对资源的授权访问。Spring Security的授权流程如下：</p><p><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200729110616-776834.png" alt="1595991975664"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;spring&quot;&gt;&lt;a href=&quot;#spring&quot; class=&quot;headerlink&quot; title=&quot;spring&quot;&gt;&lt;/a&gt;spring&lt;/h1&gt;&lt;h2 id=&quot;各种循环依赖的解决？&quot;&gt;&lt;a href=&quot;#各种循环依赖的解决？&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="面试题" scheme="http://www.sion-io.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="http://www.sion-io.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-面试题</title>
    <link href="http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2024-05-12T08:42:17.410Z</published>
    <updated>2024-05-12T08:48:19.925Z</updated>
    
    <content type="html"><![CDATA[<p>快速入门：<a href="https://blog.csdn.net/weixin_43914604/article/details/105516090">https://blog.csdn.net/weixin_43914604/article/details/105516090</a></p><ol><li><p><a href="https://www.jianshu.com/p/e45f5ed1bc0a">能否说：“电路交换就是面向连接，而分组交换就是无连接”</a></p><ol><li>记住各层的协议以及是不是面向连接的！</li></ol></li><li><p>OSI七层模型  <a href="https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=%E4%B8%80-osi%E4%B8%8Etcpip%E5%90%84%E5%B1%82%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8A%9F%E8%83%BD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE">地址</a></p><ol><li>应用层：各种应用程序协议，如http，ftp，smtp</li><li>表示层：1.数据格式的转换，2.数据的加密和解密，3.数据的压缩和恢复</li><li>会话层：会话层允许不同主机上的各个进程进行会话；  建立，管理，中止会话；</li><li>传输层：传输层负责主机中两个进程之间的通信，功能是为<code>端到端</code>连接提供可靠的传输服务</li><li>网络层：因为因特网的主要网络层协议是<code>无连接</code>的网际协议（Internet Protocol，IP）和许多<code>路由</code>选择协议</li><li>数据链路层：将网络层传下来的数据包组装成帧</li><li>物理层：在物理媒介上的比特流的透明传输</li></ol></li><li><p>三次握手的过程：1.客户端–发送带有 SYN 标志的数据包–一次握手–服务端 2.服务端–发送带有 SYN&#x2F;ACK 标志的数据包–二次握手–客户端 3.客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端   <a href="https://blog.csdn.net/qzcsu/article/details/72861891">文章</a>  <a href="https://blog.csdn.net/weixin_43914604/article/details/105516090">文章2</a></p></li><li><p>四次挥手的过程：1.客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送 2.服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号 3.服务器-关闭与客户端的连接，发送一个FIN给客户端 4.客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1 </p></li><li><p>为什么要三次握手？1.第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常 2.第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常 3.第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常 </p></li><li><p>为什么要四次挥手？任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p></li><li><p>为什么TCP客户端最后还要发送一次确认呢(即为啥不能两次握手呢)？一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p></li><li><p>为什么客户端最后还要等待2MSL？1.简单说：客户端等待2MSL后如果仍然没有收到最后一次服务端的FIN的报文，证明服务端已经收到了客户端最后一次的ACK，所以不用再等下去了。 2.详细说：等服务器工作完成了，就把fin信号发送给客户端，此时服务器要等着客户端给他一个回信，让服务器知道客户端已经知道了。因此客户端收到后就给服务器一个回信，为了防止回信丢失，客户端就再等2MSL个时间，之所以是2个，是因为涉及到来回，第一个MSL中是回信在路上的最大时间，第二个MSL是万一回信没到服务端，服务端重发的FIN确认在路上的时间。  换句话说，客户端等待2MSL后如果仍然没有收到最后一次服务端的FIN的报文，证明服务端已经收到了客户端最后一次的ACK，所以不用再等下去了，2MSL的时间一次是客户端发送链路的最大耗时，一次是服务端可能重发的耗时</p></li><li><p>为什么建立连接是三次握手，关闭连接确是四次挥手呢？  建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p></li><li><p>TCP 如何保证可靠性传输？（校验和，序列号，确认，重传（超时重传和快重传），流量控制（确定接收窗口rwnd大小），拥塞控制（确定拥塞窗口cwnd大小）1.满开始和拥塞避免  2.快重传和快恢复   满开始和拥塞避免是用来控制速度的   快恢复是跟拥塞窗口大小直接相关的   快重传跟丢失重传有关</p></li><li><p>滑动窗口：1.停止-等待协议  2.gbn协议（发送方：记住累计确认和超时的全部重传       接收方：接受数据就行了）   3.选择重传协议（发送发：不是累计确认和超时只需要重传特定的帧      接收方：接受数据就行了）</p></li><li></li><li></li><li></li><li><p>计网tcp三次握手中第三次丢失了怎么办？ <a href="https://juejin.cn/post/6844904063964807182#heading-3">https://juejin.cn/post/6844904063964807182#heading-3</a></p><ol><li>客户端最后一次回复「SYN,ACK」的「ACK」包丢了：当客户端在 ESTABLISHED 状态下，开始发送数据包时，会携带上一个「ACK」的确认序号，所以哪怕客户端响应的「ACK」包丢了，服务端在收到这个数据包时，能够通过包内 ACK 的确认序号，正常进入 ESTABLISHED 状态。</li></ol></li><li><p>客户端故意不发最后一次「ACK」包？ <a href="https://blog.csdn.net/apache0554/article/details/47040103">https://blog.csdn.net/apache0554/article/details/47040103</a>  <a href="https://blog.csdn.net/varyall/article/details/79681562">https://blog.csdn.net/varyall/article/details/79681562</a></p><ol><li>防范syn洪范攻击的方法：<ol><li>方式1：减少SYN-ACK数据包的重发次数（默认是5次）：<br>sysctl -w net.ipv4.tcp_synack_retries&#x3D;3<br>sysctl -w net.ipv4.tcp_syn_retries&#x3D;3</li><li>方式2：使用SYN Cookie技术：<br>sysctl -w net.ipv4.tcp_syncookies&#x3D;1</li><li>方式3：增加backlog队列（默认是1024）：<br>sysctl -w net.ipv4.tcp_max_syn_backlog&#x3D;2048</li><li>方式4：限制SYN并发数：<br>iptables -A INPUT -p tcp –syn -m limit –limit 1&#x2F;s -j ACCEPT –limit 1&#x2F;s</li></ol></li></ol></li><li><p>四次握手最后一次丢失了怎么办？</p><ol><li>客户端在回复「ACK」后，会进入 TIME-WAIT 状态，开始长达 2MSL 的等待，服务端因为没有收到「ACK」的回复，会重试一段时间，直到服务端重试超时后主动断开   </li><li>或者等待新的客户端接入后，收到服务端重试的「FIN」消息后，回复「RST」消息，在收到「RST」消息后，复位服务端的状态。</li></ol></li><li></li><li></li><li><p>TCP的流量控制，当接收方的接收窗口为0的时候该怎么办？<a href="https://mp.weixin.qq.com/s/LUtk6u_zv0w8g8GIGWEuCw">https://mp.weixin.qq.com/s/LUtk6u_zv0w8g8GIGWEuCw</a></p><p>上文已经说了发送方式根据接收方回应的 window 来控制能发多少数据，如果接收方一直回应 0，那发送方就杵着？<br>你想一下，发送方发的数据都得到 ACK 了，但是呢回应的窗口都是 0 ，这发送方此时不敢发了啊，那也不能一直等着啊，这 Window 啥时候不变 0 啊？<br>于是 TCP 有一个 Zero Window Probe(盘问) 技术，发送方得知窗口是 0 之后，会去探测探测这个接收方到底行不行，也就是发送 ZWP 包给接收方。<br>具体看实现了，可以发送多次，然后还有间隔时间，多次之后都不行可以直接 RST</p></li><li><p>TCP传输通信时,客户端突然断开连接  <a href="https://www.nowcoder.com/discuss/612115">https://www.nowcoder.com/discuss/612115</a></p><p>TCP设有一个保活计时器，如果客户端出现故障，服务器不会一直等待。服务器每收到一次客户端的请求都会重新复位这个计时器，时间通常设置为2小时，如果两小时没有收到客户端的任何数据，服务端就会每隔75分钟发送一个探测报文，如果连续发送10个探测报文都没有反应，服务端就会认为客户端出了故障，从而关闭连接</p></li><li><p>大量的 TIME_WAIT 状态 TCP 连接存在，其本质原因是什么？ <a href="https://mp.weixin.qq.com/s/N_By2GsnoSpOWkssVzmFLg">https://mp.weixin.qq.com/s/N_By2GsnoSpOWkssVzmFLg</a></p><ol><li><p>如果是服务端存在大量TIME_WAIT 的原因：</p><p>1.大量的短连接存在</p><p>2.特别是 HTTP 请求中，如果 connection 头部取值被设置为 close 时，基本都由「服务端」发起主动关闭连接</p><p>3.而，TCP 四次挥手关闭连接机制中，为了保证 ACK 重发和丢弃延迟数据，设置 time_wait 为 2 倍的 MSL（报文最大存活时间）</p></li><li><p>可能导致的问题</p><p>1.每一个 time_wait 状态，都会占用一个「本地端口」，上限为 65535(16 bit，2 Byte)；2.当大量的连接处于 time_wait 时，新建立 TCP 连接会出错，address already in use : connect 异常</p></li><li><p>解决办法</p><ol><li>1.客户端，HTTP 请求的头部，connection 设置为 keep-alive，保持存活一段时间：现在的浏览器，一般都这么进行了</li><li>2.服务器端允许 time_wait 状态的 socket 被重用缩减 time_wait 时间，设置为 1 MSL（即，2 mins）</li></ol></li></ol></li><li></li><li></li><li><p>网际控制报文协议(Internet Control Message Protocol, ICMP)有什么用？让主机或路由器报告差错和异常情况。1.ICMP差错报告报文  终点不可达无法交复，TTL&#x3D;0，首部字段有问题，改变路由 —–2.ICMP询问报文  回声请求和回声回答报文来测试是否可达， 时间戳请求和回答报文来进行时钟同步和测量时间</p></li><li><p>ARP (Address ResolutionProtocol, ARP)过程？1.检查arp高速缓存，有对应表项则写入MAC帧—-2.没有则用MAC地址为FF-FF-FF-FF-FF-FF的帧封装的广播arp请求分组，统一局域网中的所有主机都能收到该请求，目的主机收到请求后就会向源主机单播一个arp相应分组，源主机收到之后将此映射写入arp缓存（10-20min更新一次）</p></li><li><p>网络层的路由算法，简述RIP，OSPF过程？<a href="https://blog.csdn.net/weixin_43914604/article/details/105313629">https://blog.csdn.net/weixin_43914604/article/details/105313629</a></p><ol><li>外部网关协议：BGP</li><li>内部网关协议：RIP，OSPF<ol><li>（RIP是应用层协议使用UDP，只适合小规模，坏消息传得慢）RIP距离-向量路由算法中，每个结点仅与它的直接<code>邻居</code>交谈，它为它的邻居提供从自己到网络中所有其他结点的最低费用估计</li><li>（RIP使用IP，适合大规模）OSPF链路状态路由算法也叫开放最短路径优先协议中，每个结点通过<code>广播</code>的方式与所有<code>其他结点</code>交谈，但它仅告诉它们与它直接相连的链路的费用</li><li>什么称为用UDP传送？什么称为用IP数据报传送?<ul><li>用UDP传送是指将该信息作为UDP报文的数据部分</li><li>直接使用IP数据报传送是指将该信息直接作为IP 数据报的数据部分</li><li>RIP报文是作为UDP数据报的数据部分。</li><li>OSPF协议直接使用IP数据报进行传递</li></ul></li></ol></li></ol></li><li></li><li></li><li><p>http的报文格式?：</p><ol><li>http报文格式：<a href="https://blog.csdn.net/a19881029/article/details/14002273">https://blog.csdn.net/a19881029/article/details/14002273</a><ol><li>HTTP请求报文主要由请求行、请求头部、请求正文3部分组成<ol><li>请求行：请求方法、URL以及协议版本</li><li>请求头部：请求头部为请求报文添加了一些附加信息，由“名&#x2F;值”对组成，每行一对，名和值之间使用冒号分隔</li><li>请求正文：可选部分</li></ol></li><li>HTTP响应报文主要由状态行、响应头部、响应正文3部分组成<ol><li>状态行：协议版本，状态码，状态码描述</li><li>响应头部：为响应报文添加了一些附加信息</li><li>响应正文：可选部分</li></ol></li></ol></li></ol></li><li><p>Http的状态码？<a href="https://www.runoob.com/http/http-status-codes.html">https://www.runoob.com/http/http-status-codes.html</a></p><ol><li>1信息性状态码，接受端的请求正在处理，服务器收到请求，需要请求者继续执行操作   2成功状态码，操作被成功接收并处理    3 重定向状态码，需要进一步的操作以完成请求     4 客户端错误状态码，请求包含语法错误或无法完成请求      5 服务器错误状态码，服务器在处理请求的过程中发生了错误</li><li>201 已创建。成功请求并创建了新的资源</li><li>202  已接受。已经接受请求，但未处理完成</li><li>301 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li><li>302 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>501 服务器不支持请求的功能，无法完成请求</li><li>502   作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 </li><li>503   由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</li></ol></li><li><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=%E5%8D%81%E4%B8%80-http-10%E5%92%8Chttp-11%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">十一 HTTP 1.0和HTTP 1.1的主要区别是什么?</a> HTTP 1.0和HTTP 1.1的主要区别是什么?1.长连接 : 在HTTP&#x2F;1.0中，默认使用的是短连接，2.错误状态响应码，新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除 ，3.缓存处理，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等， 4.带宽优化及网络连接的使用HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content）</p></li><li><p>Http2.0?  Http3.0? <a href="https://mp.weixin.qq.com/s/RCEvWLGdZE27f7ehdgj5UQ">文章</a>  <a href="https://mp.weixin.qq.com/s/JYGbFg6OPETutTXZyJQHRw">文章</a>    <a href="https://mp.weixin.qq.com/s/pyyhRkaWtMhGR9Yh6lP-lw">文章</a></p><ol><li><p>2.0:</p><ol><li>二进制分帧：HTTP 2.0 的所有帧都采用二进制编码<ol><li>帧：客户端与服务器通过交换帧来通信，帧是基于这个新协议通信的最小单位。</li><li>消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。</li><li>流：流是连接中的一个虚拟信道，每个流都有一个唯一的整数标识符，可以承载双向的消息，一个流代表了一个完整的<strong>请求-响应</strong>过程</li><li>一个域名对应一个连接，流是连接中的一个虚拟信道，每个流都有一个唯一的整数标识符，可以承载双向的消息，一个流代表了一个完整的<strong>请求-响应</strong>过程。<strong>帧</strong>是最小的数据单位，每个<strong>帧</strong>会标识出该帧属于哪个<strong>流</strong>，<strong>流</strong>也就是多个帧组成的数据流。多路复用，就是在一个 TCP 连接中可以存在多个流。</li></ol></li><li>多路复用 (Multiplexing)<ol><li>多路复用允许’同时’通过单一的 HTTP&#x2F;2 连接发起多重的请求-响应消息。有了新的分帧机制后，HTTP&#x2F;2 不再依赖多个TCP  连接去实现多流并行了。HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（<strong>每个域名一个连接</strong>）即可。</li></ol></li><li>请求优先级<ol><li>每个流都可以带有一个31 比特的优先值：0 表示最高优先级；2的31次方-1 表示最低优先级。</li><li>服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽）。</li><li>HTTP 2.0 一举解决了所有这些低效的问题：浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接。</li></ol></li><li>header压缩<ol><li>HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP&#x2F;2使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li></ol></li><li>服务端推送：服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确地请求</li></ol></li><li><p>3.0？</p><ol><li><p>队头阻塞问题  HTTP2.0协议的多路复用机制解决了HTTP层的队头阻塞问题，但是在TCP层仍然存在队头阻塞问题； QUIC协议是基于UDP协议实现的，在一条链接上可以有多个流，流与流之间是互不影响的，当一个流出现丢包影响范围非常小，从而解决队头阻塞问题</p></li><li><p>快速握手，0RTT 建链  ：首次连接的时候需要传递config包所以需要1RTT的时间，非首次连接的时候只需要0RTT</p></li><li><p>集成了 TLS 1.3 加密，前向安全问题： 通俗来说，前向安全指的是密钥泄漏也不会让之前加密的数据被泄漏，影响的只有当前，对之前的数据无影响。</p></li><li><p>前向纠错：接收端利用发送端在发送码元序列中加入的差错控制码元,不但能够发现错码,还能将错码恢复其正确取值。  QUIC每发送一组数据就对这组数据进行<strong>异或运算</strong>，并将结果作为一个FEC包发送出去，接收方收到这一组数据后根据数据包和FEC包即可进行校验和纠错</p></li><li><p>连接迁移：TCP协议使用五元组来表示一条唯一的连接，当我们从4G环境切换到wifi环境时，手机的IP地址就会发生变化，这时必须创建新的TCP连接才能继续传输数据。</p><p>QUIC协议基于UDP实现摒弃了五元组的概念，使用64位的随机数作为连接的ID，并使用该ID表示连接。</p></li></ol></li></ol></li><li></li><li></li><li><p>https</p><ol><li>https的一些解释：图解：<a href="https://juejin.cn/post/6844903764399243278#heading-10">https://juejin.cn/post/6844903764399243278#heading-10</a></li><li>结合这个一起理解，<a href="https://juejin.cn/post/6844904158319869960#heading-12">https://juejin.cn/post/6844904158319869960#heading-12</a></li><li>https：<a href="https://juejin.cn/post/6844903901037084686#heading-6">https://juejin.cn/post/6844903901037084686#heading-6</a></li><li>证书的认证过程，这个讲的是只需要客户端即浏览器验证服务器的，而不需要服务器认证客户端：<a href="https://mp.weixin.qq.com/s/DsnzPiGdciJM-_TM6tbmyQ">https://mp.weixin.qq.com/s/DsnzPiGdciJM-_TM6tbmyQ</a></li><li>证书里面的内容，待签名证书内容（证书的拥有者名字，证书拥有者的公钥，证书有效时间，证书的签发者），证书的签名算法，证书的签名</li><li>https的原理？1.证书的产生过程 2.证书的认证过程 3.https的大致流程（1.证书的产生过程 2.证书的认证过程 3.https的大致流程（1.三次握手，2.Client Hello，3.Server Hello 4.Server Hello Done 5. 交换密钥 6.互发finished））</li></ol></li><li><p>Https怎么抵御中间人攻击？</p><ol><li>中间人攻击原理：针对SSL的中间人攻击方式主要有两类，分别是SSL劫持攻击和SSL剥离攻击</li><li>SSL劫持攻击</li><li>SSL劫持攻击：即SSL证书欺骗攻击，攻击者为了获得HTTPS传输的明文数据，需要先将自己接入到客户端和目标网站之间；在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥，这样，中间人就可以得到明文传输带Key1、Key2和Pre-Master-Key，从而窃取客户端和服务端的通信数据；但是对于客户端来说，如果中间人伪造了证书，在校验证书过程中会提示证书错误，由用户选择继续操作还是返回，由于大多数用户的安全意识不强，会选择继续操作，此时，中间人就可以获取浏览器和服务器之间的通信数据 <a href="https://www.cnblogs.com/lulianqi/p/10558719.html">文章</a></li><li>SSL剥离攻击（SSLStrip）：这种攻击方式也需要将攻击者设置为中间人，之后见HTTPS范文替换为HTTP返回给浏览器，而中间人和服务器之间仍然保持HTTPS服务器。由于HTTP是明文传输的，所以中间人可以获取客户端和服务器传输数据  <a href="https://mp.weixin.qq.com/s/B7AWgnvGPIMItTiYX3VZDg">文章</a></li></ol></li><li><p>HTTPS能被抓包吗？</p><ol><li>能，Fiddler生成一个证书，用户手动把证书安装到客户端！</li><li>抓包过程：<a href="https://mp.weixin.qq.com/s/ArTfPR5sliUZQD8Dx8riGg">https://mp.weixin.qq.com/s/ArTfPR5sliUZQD8Dx8riGg</a>  <a href="https://www.zhihu.com/question/24484809/answer/296984160">原理</a></li></ol></li><li></li><li></li><li><p>get和post的几个误解（产生的误解的可能是因为http只能使用在浏览器中，有些只是浏览器的限制而已）：1.post比get安全？2.get传送的数据有限？3.get的数据不能把数据放在body中？     </p></li><li><p>get和post的区别两篇文章：<a href="https://mp.weixin.qq.com/s/v9JzJalvzaSZxG3B87Ia3Q">文章1</a>，<a href="https://mp.weixin.qq.com/s/0VqcbYwXJU_wV65ALLBF5Q">文章2</a>  <a href="https://blog.csdn.net/qq_33709582/article/details/113549520">文章</a></p><ol><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ol></li><li><p>post如何防止表单重复提交（端重复提交的接口的幂等性问题，还有消息重复消费幂等性问题）？<a href="https://www.cnblogs.com/xdp-gacl/p/3859416.html">文章地址</a>：1.理解重复提交的三种情况（三种情况都是使用第一次提交的时候的页面的数据进行请求的）  2.解决的两种方法（通过js和token两种方法解决，正是三种情况都是使用第一次提交的时候的页面的数据进行请求的所以才能通过token来解决）</p></li><li></li><li></li><li></li><li><p>csrf：1.先看了这一篇，讲了些概念和一些解决方法 <a href="https://www.jianshu.com/p/67408d73c66d">地址</a>，   <a href="https://blog.csdn.net/zdavb/article/details/51161130?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">彻底搞清referrer和origin</a> </p><ol><li>使用post：如果使用get，只要一个img标签就可以了（但如果网站存在xss漏洞，此方法还是不行）</li><li>将cookie设置为HttpOnly，<a href="https://www.cnblogs.com/beautiful-code/p/13036312.html">原理</a><ol><li>如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击，窃取cookie内容（XSS：其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的）</li></ol></li><li>增加token：系统开发人员可以在HTTP请求中以参数的形式加入一个<strong>随机产生</strong>的token，并在服务端进行token校验，如果请求中没有token或者token内容不正确，则认为是CSRF攻击而拒绝该请求</li><li>通过Referer识别</li></ol></li><li><p>学习跨域：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">地址</a></p><ol><li>跨域问题，同时注意到postman是没有跨域问题的，然后我了解到跨域问题的原理，然后通过filter解决的<ol><li>简单请求<ol><li>浏览器<ol><li>请求时携带Origin字段</li><li>对响应的请求校验 Access-Control-Allow-Origin 字段是否跟自己的域名相匹配</li></ol></li><li>服务器<ol><li>可以校验Origin字段</li><li>可以决定返不返回  Access-Control-Allow-Origin 字段</li></ol></li></ol></li><li>复杂请求<ol><li>浏览器<ol><li>会先发送Option请求</li><li>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</li></ol></li></ol></li></ol></li></ol></li><li><p><a href="https://blog.csdn.net/weixin_43914604/article/details/105583806">DNS 解析过程</a></p><ol><li>（1）递归查询方式  （2） 常用递归与迭代相结合的查询方式 </li><li><img src="/img/OIP-C.jpg" data-original="https://img-blog.csdnimg.cn/20200417212650924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><img src="/img/OIP-C.jpg" data-original="https://img-blog.csdnimg.cn/20200417212650924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol></li><li><p>Delay ack  <a href="https://mp.weixin.qq.com/s/TNSYpcqamfC3Sn6IMxti5Q">https://mp.weixin.qq.com/s/TNSYpcqamfC3Sn6IMxti5Q</a></p><ol><li><img src="/img/OIP-C.jpg" data-original="/assets/image-20210325152736813.png" alt="image-20210325152736813"></li></ol></li><li><p>CDN?<a href="https://mp.weixin.qq.com/s/foOkh3w9i-_w5l6eKNzqWw">https://mp.weixin.qq.com/s/foOkh3w9i-_w5l6eKNzqWw</a></p><ol><li><p><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/pUm6Hxkd434gjHCdM3z3Vibu0suEOZzZjy3zoTAicQYKOETVYIOOQabBUia4HhJw0BvV4mmicz0JOcDOKLG1p31AIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ol start="2"><li><p>①、当用户点击APP上的内容，APP会根据URL地址去<strong>本地DNS</strong>（域名解析系统）寻求IP地址解析。</p><p>②、本地DNS系统会将域名的解析权交给<strong>CDN专用DNS服务器</strong>。</p><p>③、CDN专用DNS服务器，将CDN的全局负载均衡设备IP地址返回用户。</p><p>④、用户向<strong>CDN的负载均衡设备</strong>发起内容URL访问请求。</p><p>⑤、CDN负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的<strong>缓存服务器</strong>。</p><p>⑥、负载均衡设备告诉用户这台缓存服务器的IP地址，让用户向所选择的缓存服务器发起请求。</p><p>⑦、用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。</p><p>⑧、如果这台缓存服务器上并没有用户想要的内容，那么这台缓存服务器就要网站的<strong>源服务器</strong>请求内容。</p><p>⑨、源服务器返回内容给缓存服务器，缓存服务器发给用户，并根据用户自定义的缓存策略，判断要不要把内容缓存到缓存服务器上。</p></li></ol></li><li><p>好处：</p><ol><li>最大的好处，就是加速了网站的访问——用户与内容之间的物理距离缩短，用户的等待时间也得以缩短</li><li>此外，CDN还有安全方面的好处。内容进行分发后，源服务器的IP被隐藏，受到攻击的概率会大幅下降。而且，当某个服务器故障时，系统会调用临近的健康服务器 进行服务，避免对用户造成影响。</li></ol></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;快速入门：&lt;a href=&quot;https://blog.csdn.net/weixin_43914604/article/details/105516090&quot;&gt;https://blog.csdn.net/weixin_43914604/article/details/1055</summary>
      
    
    
    
    <category term="面试题" scheme="http://www.sion-io.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="计算机" scheme="http://www.sion-io.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>集合-面试题</title>
    <link href="http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9B%86%E5%90%88/"/>
    <id>http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9B%86%E5%90%88/</id>
    <published>2024-05-12T08:42:17.408Z</published>
    <updated>2024-05-12T08:48:19.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-剖析面试最常见问题之-Java-集合框架"><a href="#1-剖析面试最常见问题之-Java-集合框架" class="headerlink" title="1. 剖析面试最常见问题之 Java 集合框架"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_1-%E5%89%96%E6%9E%90%E9%9D%A2%E8%AF%95%E6%9C%80%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B9%8B-java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6">1. 剖析面试最常见问题之 Java 集合框架</a></h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1. 集合概述"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_11-%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0">1.1. 集合概述</a></h2><h3 id="1-1-1-Java-集合概览"><a href="#1-1-1-Java-集合概览" class="headerlink" title="1.1.1. Java 集合概览"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_111-java-%E9%9B%86%E5%90%88%E6%A6%82%E8%A7%88">1.1.1. Java 集合概览</a></h3><p>从下图可以看出，在 Java 中除了以 <code>Map</code> 结尾的类之外， 其他类都实现了 <code>Collection</code> 接口。</p><p>并且，以 <code>Map</code> 结尾的类都实现了 <code>Map</code> 接口。</p><p><img src="/img/OIP-C.jpg" data-original="https://snailclimb.gitee.io/javaguide/docs/java/collection/images/Java-Collections.jpeg" alt="img"></p><h3 id="1-1-2-说说-List-Set-Map-三者的区别？"><a href="#1-1-2-说说-List-Set-Map-三者的区别？" class="headerlink" title="1.1.2. 说说 List,Set,Map 三者的区别？"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_112-%E8%AF%B4%E8%AF%B4-listsetmap-%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">1.1.2. 说说 List,Set,Map 三者的区别？</a></h3><ul><li><code>List</code>(对付顺序的好帮手)： 存储的元素是有序的、可重复的。</li><li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li><li><code>Map</code>(用 Key 来搜索的专家): 使用键值对（kye-value）存储，类似于数学上的函数 y&#x3D;f(x)，“x”代表 key，”y”代表 value，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h2 id="1-2-Collection-子接口之-List"><a href="#1-2-Collection-子接口之-List" class="headerlink" title="1.2. Collection 子接口之 List"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_12-collection-%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B-list">1.2. Collection 子接口之 List</a></h2><h3 id="1-2-1-Arraylist-和-Vector-的区别"><a href="#1-2-1-Arraylist-和-Vector-的区别" class="headerlink" title="1.2.1. Arraylist 和 Vector 的区别?"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_121-arraylist-%E5%92%8C-vector-%E7%9A%84%E5%8C%BA%E5%88%AB">1.2.1. Arraylist 和 Vector 的区别?</a></h3><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code> Object[ ]</code> 存储，线程安全的。</li></ul><h3 id="1-2-2-Arraylist-与-LinkedList-区别"><a href="#1-2-2-Arraylist-与-LinkedList-区别" class="headerlink" title="1.2.2. Arraylist 与 LinkedList 区别?"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_122-arraylist-%E4%B8%8E-linkedlist-%E5%8C%BA%E5%88%AB">1.2.2. Arraylist 与 LinkedList 区别?</a></h3><h4 id="1-2-2-2-补充内容-RandomAccess-接口"><a href="#1-2-2-2-补充内容-RandomAccess-接口" class="headerlink" title="1.2.2.2. 补充内容:RandomAccess 接口"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_1222-%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9randomaccess-%E6%8E%A5%E5%8F%A3">1.2.2.2. 补充内容:RandomAccess 接口</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RandomAccess</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在 <code>binarySearch（)</code> 方法中，它要判断传入的 list 是否 <code>RamdomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; list, T key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p><h2 id="1-3-Collection-子接口之-Set"><a href="#1-3-Collection-子接口之-Set" class="headerlink" title="1.3. Collection 子接口之 Set"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_13-collection-%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B-set">1.3. Collection 子接口之 Set</a></h2><h3 id="1-3-3-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#1-3-3-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="1.3.3. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_133-%E6%AF%94%E8%BE%83-hashset%E3%80%81linkedhashset-%E5%92%8C-treeset-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C">1.3.3. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</a></h3><p><code>HashSet</code> 是 <code>Set</code> 接口的主要实现类 ，<code>HashSet</code> 的底层是 <code>HashMap</code>，线程不安全的，可以存储 null 值；</p><p><code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，能够按照添加的顺序遍历；</p><p><code>TreeSet</code> 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</p><h2 id="1-4-Map-接口"><a href="#1-4-Map-接口" class="headerlink" title="1.4. Map 接口"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_14-map-%E6%8E%A5%E5%8F%A3">1.4. Map 接口</a></h2><h3 id="1-4-1-HashMap-和-Hashtable-的区别"><a href="#1-4-1-HashMap-和-Hashtable-的区别" class="headerlink" title="1.4.1. HashMap 和 Hashtable 的区别"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_141-hashmap-%E5%92%8C-hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB">1.4.1. HashMap 和 Hashtable 的区别</a></h3><ol><li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>HashTable</code> 是线程安全的,因为 <code>HashTable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>HashTable</code> 效率高一点。另外，<code>HashTable</code> 基本被淘汰，不要在代码中使用它；</li><li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ol><li><p>继承体系图：<a href="https://www.cnblogs.com/skywang12345/p/3308498.html">https://www.cnblogs.com/skywang12345/p/3308498.html</a>    <a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_1-%e5%89%96%e6%9e%90%e9%9d%a2%e8%af%95%e6%9c%80%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e4%b9%8b-java-%e9%9b%86%e5%90%88%e6%a1%86%e6%9e%b6">guide地址</a><img src="/img/OIP-C.jpg" data-original="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/source-code/dubbo/java-collection-hierarchy.png" alt="img"></p></li><li><p>Iterator和fast-fail 和 fast-safe？  <a href="https://www.cnblogs.com/skywang12345/p/3308762.html">https://www.cnblogs.com/skywang12345/p/3308762.html</a>    <a href="https://juejin.cn/post/6844904023003250701#heading-1">https://juejin.cn/post/6844904023003250701#heading-1</a></p><ol><li><strong>快速失败（fail—fast）</strong>是java集合中的一种机制， 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</li><li>java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改</li></ol></li><li><p>说一下hashmap</p><ol><li>扩容过程；<ol><li>先说两个参数的赋值过程：分为已经初始化和未初始化；未初始化分为无参的构造函数和其它构造函数，有参的构造函数的newCap和newThr如何决定？ 已经初始化的分为oldCap是不是大于8，不是大于8的newThr如何决定？</li><li>再说一下是怎么从旧的转移到新的table的：分四种情况，注意最后一种情况的高低链表</li></ol></li><li>put的过程：分四种情况</li><li>hashmap的节点的继承关系：地址<a href="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166377647704.jpg">https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166377647704.jpg</a></li></ol></li><li><p>底层实现：jdk1.7 hashMap，hashTable 都是使用数组加链表；jdk1.8 hashMap   concurrentHashMap 都是使用数组加链表加红黑树；jdk1.7  concurrentHashMap 使用segment数组+HashEntry数组+链表</p></li><li><p>hashMap遍历的七种方式? <a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw">地址</a></p><ol><li>原理<ol><li><strong>EntrySet 和 KeySet 和Lambda 表达式foreach来自Map接口；</strong></li><li><strong>迭代器（Iterator），for Each来自 EntrySet 或 KeySet的 Collection接口</strong></li><li><strong>Streams API来自 EntrySet 或 KeySet的 Collection接口</strong></li></ol></li><li>使用迭代器（Iterator）EntrySet 的方式进行遍历；</li><li>使用迭代器（Iterator）KeySet 的方式进行遍历；</li><li>使用 For Each EntrySet 的方式进行遍历；</li><li>使用 For Each KeySet 的方式进行遍历；</li><li>使用 Lambda 表达式的方式进行遍历；</li><li>使用 Streams API 单线程的方式进行遍历；</li><li>使用 Streams API 多线程的方式进行遍历。</li></ol></li><li><h3 id="1-4-1-HashMap-和-Hashtable-的区别-1"><a href="#1-4-1-HashMap-和-Hashtable-的区别-1" class="headerlink" title="1.4.1. HashMap 和 Hashtable 的区别"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_141-hashmap-%E5%92%8C-hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB">1.4.1. HashMap 和 Hashtable 的区别</a></h3><ol><li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>HashTable</code> 是线程安全的,因为 <code>HashTable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>HashTable</code> 效率高一点。另外，<code>HashTable</code> 基本被淘汰，不要在代码中使用它；</li><li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol></li><li><p>hashTable：<a href="https://www.cnblogs.com/skywang12345/p/3310887.html">https://www.cnblogs.com/skywang12345/p/3310887.html</a>   <a href="https://juejin.cn/post/6844904023003250701#heading-1">https://juejin.cn/post/6844904023003250701#heading-1</a></p><ol><li>迭代器使用的是<strong>Enumeration</strong>，他是fast-safe的</li><li>java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改</li></ol></li><li><p>JDK 1.7 ConcurrentHashMap?   <a href="https://juejin.cn/post/6844904023003250701#heading-1">https://juejin.cn/post/6844904023003250701#heading-1</a></p><p>ConcurrentHashMap 采用了<strong>分段锁</strong>技术，其中 Segment 继承于 ReentrantLock，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发</p><ol><li>put：首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 <code>scanAndLockForPut()</code> 自旋获取锁。               尝试自旋获取锁。如果重试的次数达到了 <code>MAX_SCAN_RETRIES</code> 则改为阻塞锁获取，保证能获取成功。</li><li>get：get 逻辑比较简单，只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上</li></ol></li><li><p>JDK 1.8 ConcurrentHashMap? </p><ol><li>put：<ol><li>如果要创建 table，使用了 cas</li><li>如果要创建链表头节点，使用了cas</li><li>线程正在扩容：帮忙扩容</li><li>捅下标冲突的情况，synchronized锁住链表头节点</li></ol></li><li>get：<ol><li>槽是否为空</li><li>如果头结点已经是要查找的 key</li><li>hash 为负数表示该 bin 在扩容中或是 treebin, 这时调用 find 方法来查找</li><li>链表, 使用&#x3D;&#x3D;比较或 equals 比较</li></ol></li></ol></li><li><p>ConCurrentHashMap里的size()方法是怎么实现的？</p><ol><li><p>size 计算实际发生在 put，remove 改变集合元素的操作之中；这个计数是不准确的，因为是在多线程的环境中</p></li><li><p>baseCount+累加单元数组的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="type">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">                    (<span class="type">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">sumCount</span><span class="params">()</span> &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="comment">// 将 baseCount 计数与所有 cell 计数累加</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>解决哈希冲突的方法有哪些？  <a href="https://lixuekai.blog.csdn.net/article/details/52269862">https://lixuekai.blog.csdn.net/article/details/52269862</a></p><p>1.开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）<br> 2.再哈希法：这种方法是同时构造多个不同的哈希函数<br> 3.链地址法(Java hashmap就是这么做的)<br> 4.建立一个公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表</p></li><li><p>set如何验证是否重复？  <a href="https://lavorange.blog.csdn.net/article/details/80420087">https://lavorange.blog.csdn.net/article/details/80420087</a></p><ol><li>因为调用的是HashMap的方法，所以是先调用它的hashcode判断是否相等，如果相等再使用”&#x3D;&#x3D;”或者equal方法判断</li><li>String和Integer都已经重写了equal和hashcode方法，两个对象如果值相等，那么他们的equal和hashcode方法就相等</li></ol></li><li><p>说说LinkedHashMap的底层原理</p></li><li><p>arrayList的遍历方式  <a href="https://www.cnblogs.com/skywang12345/p/3308556.html">https://www.cnblogs.com/skywang12345/p/3308556.html</a></p><ol><li>通过迭代器遍历</li><li>for循环遍历</li><li>stream api</li><li>随机访问，通过索引值去遍历</li></ol></li><li><p>ArrayList的扩容</p><ol><li>参数确定<ol><li>默认容量为10</li><li>无参构造器（有参但是为0）使用懒初始化，使用默认的容量去进行初始化<ol><li>第一次调用ensureExplicitCapacity()，就会进行初始化扩容了，扩容大小为10<ol><li>newCapacity 被指定为10</li></ol></li><li>第二次调用ensureExplicitCapacity()，并不会扩容，直到11才会扩容了<ol><li>扩容为1.5倍大小，newCapacity 被指定为15</li></ol></li></ol></li><li>有参构造器直接初始化数组<ol><li>第一次调用ensureExplicitCapacity()，不会进行扩容</li><li>直到minCapacity大于数组长度才进行扩容<ol><li>扩容为1.5倍大小</li></ol></li></ol></li></ol></li><li>拷贝：使用Arrays.copyOf()进行扩容</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-剖析面试最常见问题之-Java-集合框架&quot;&gt;&lt;a href=&quot;#1-剖析面试最常见问题之-Java-集合框架&quot; class=&quot;headerlink&quot; title=&quot;1. 剖析面试最常见问题之 Java 集合框架&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://sn</summary>
      
    
    
    
    <category term="面试题" scheme="http://www.sion-io.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="http://www.sion-io.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-面试题</title>
    <link href="http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-05-12T08:42:17.405Z</published>
    <updated>2024-05-12T08:48:19.880Z</updated>
    
    <content type="html"><![CDATA[<p>2.<br>3. Kill 命令的一些区别  <a href="https://www.cnblogs.com/hollischuang/p/12880614.html">https://www.cnblogs.com/hollischuang/p/12880614.html</a></p><ol><li><p>Java程序的终止运行是基于JVM的关闭实现的，JVM关闭方式分为3种：</p><blockquote><p>正常关闭：当最后一个非守护线程结束或者调用了System.exit或者通过其他特定平台的方法关闭（接收到SIGINT（2）、SIGTERM（15）信号等）</p><p>强制关闭：通过调用Runtime.halt方法或者是在操作系统中强制kill（接收到SIGKILL（9）信号)</p><p>异常关闭：运行中遇到RuntimeException异常等。</p></blockquote></li><li><p><code>kill -15</code>执行时，系统向对应的程序发送SIGTERM（15）信号，该信号是可以被执行、阻塞和忽略的，所以应用程序接收到信号后，可以做一些准备工作，再进行程序终止。</p><ol><li>这也会带来很多副作用，如数据丢失等，所以，在非必要时，不要使用<code>kill -9</code>命令，尤其是那些web应用、提供RPC服务、执行定时任务、包含长事务等应用中，因为<code>kill -9</code> 没给spring容器、tomcat服务器、dubbo服务、流程引擎、状态机等足够的时间进行收尾。</li></ol></li><li><p>有的时候，<code>kill -15</code>无法终止程序，因为他可能被忽略，这时候可以使用<code>kill -9</code>，系统会发出SIGKILL（9）信号，该信号不允许忽略和阻塞，所以应用程序会立即终止。</p></li><li><p>进程间通讯的7种方式  <a href="https://blog.csdn.net/zhaohong_bo/article/details/89552188">https://blog.csdn.net/zhaohong_bo/article/details/89552188</a></p><ol><li>管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li><li>命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li>消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li><li>信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li><li>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li></ol></li><li><p>死锁产生的四个必要条件</p><ol><li>互斥条件</li><li>不剥夺条件</li><li>循环等待</li><li>请求和保持</li><li><img src="/img/OIP-C.jpg" data-original="https://img-blog.csdnimg.cn/20200410175208280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol></li><li><p>死锁如何处理</p><ol><li><p>预防死锁</p><ol><li>破坏互斥条件：将互斥的资源改为共享</li><li>破坏不可剥夺：1.主动放弃  2.操作系统协助</li><li>破坏请求和保持条件：可以一次性获取所有的资源</li><li>破坏循坏等待条件：可以顺序获取资源；</li></ol></li><li><p>避免死锁：银行家算法</p></li></ol></li><li><p>进程调度算法（发生询问的时机：1.一个进程执行完了  2.有新的进程过来  3.cpu的时间片用完了）</p><ol><li><p>旧的调度算法</p><p>高响应比优先—HRRN</p><p>最短剩余时间优先算法 SRTN</p><p><img src="/img/OIP-C.jpg" data-original="https://img-blog.csdnimg.cn/20200405210919429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>新的调度算法</p><p><img src="/img/OIP-C.jpg" data-original="https://img-blog.csdnimg.cn/20200405221830211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol></li><li><p>内存的扩充</p><ol><li><p>旧的内存扩充</p><ol><li><img src="/img/OIP-C.jpg" data-original="https://img-blog.csdnimg.cn/20200423175639916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><img src="/img/OIP-C.jpg" data-original="https://img-blog.csdnimg.cn/20200423175532452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol></li><li><p>虚拟存储技术</p><p><img src="/img/OIP-C.jpg" data-original="https://img-blog.csdnimg.cn/20200507181418228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="/img/OIP-C.jpg" data-original="https://img-blog.csdnimg.cn/20200508164532762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol></li><li><p>连续分配管理的内存分配？</p><p><img src="/img/OIP-C.jpg" data-original="https://img-blog.csdnimg.cn/20200423183217819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>动态分区分配：</p><ol><li><p>系统要用怎样的数据结构记录内存的使用情况呢？分为空闲分区表和空闲分区链</p></li><li><p>当多个空闲分区都能满足要求时，应该选择哪个分区进行分配？分为空闲分区表和空闲分区链讨论；</p><p><img src="/img/OIP-C.jpg" data-original="https://img-blog.csdnimg.cn/20200423221937764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>如何进行分区的分配和回收操作？分为空闲分区表和空闲分区链讨论；</p></li></ol></li><li><p>非连续分配管理的内存分配？</p><p><img src="/img/OIP-C.jpg" data-original="https://img-blog.csdnimg.cn/2020050319145526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="/img/OIP-C.jpg" data-original="https://img-blog.csdnimg.cn/20200503190414618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>快表？</p><ol><li><img src="/img/OIP-C.jpg" data-original="https://img-blog.csdnimg.cn/20200505111455765.png" alt="在这里插入图片描述"></li></ol></li><li><p>磁盘调度算法</p></li><li><p><img src="/img/OIP-C.jpg" data-original="https://img-blog.csdnimg.cn/20200527183847708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>docker 和 虚拟机的区别?<a href="https://www.zhihu.com/question/48174633">https://www.zhihu.com/question/48174633</a>   <a href="https://segmentfault.com/a/1190000019462392">https://segmentfault.com/a/1190000019462392</a></p><ol><li>虚拟机<ol><li>虚拟机管理系统(Hypervisor)</li><li>客户机操作系统(Guest Operating System)。假设你需要运行3个相互隔离的应用，则需要使用Hypervisor启动3个客户机操作系统，也就是3个虚拟机。这些虚拟机都非常大，也许有700MB，这就意味着它们将占用2.1GB的磁盘空间。更糟糕的是，它们还会消耗很多CPU和内存。</li><li>各种依赖。每一个客户机操作系统都需要安装许多依赖。</li><li>应用。安装依赖之后，就可以在各个客户机操作系统分别运行应用了，</li></ol></li><li>docker分为<ol><li>主操作系统</li><li>Docker守护进程(Docker Daemon)。Docker守护进程取代了Hypervisor，它是运行在操作系统之上的后台进程，负责管理Docker容器。</li><li>各种依赖。对于Docker，应用的所有依赖都打包在Docker镜像中，Docker容器是基于Docker镜像创建的。</li><li>应用。应用的源代码与它的依赖都打包在Docker镜像中，不同的应用需要不同的Docker镜像。不同的应用运行在不同的Docker容器中，它们是相互隔离的。</li></ol></li><li>对比<ol><li>Docker引擎运行在操作系统上，是基于<span style="color:red">内核的LXC、Chroot等技术实现容器的环境隔离和资源控制</span>，在容器启动后，容器里的进程直接与内核交互，无需经过Docker引擎中转，因此几乎没有性能损耗，能发挥出裸机的全部性能。</li><li>Docker 是一种应用级别的容器引擎</li><li>虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动。由于没有臃肿的从操作系统，Docker可以节省大量的磁盘空间以及其他系统资源</li></ol></li></ol></li><li><p>docker 容器和镜像和仓库的区别？</p><ol><li><img src="/img/OIP-C.jpg" data-original="/assets/image-20210405094722507.png" alt="image-20210405094722507"></li></ol></li><li><p>Docker的文件系统？</p><p><img src="/img/OIP-C.jpg" data-original="https://segmentfault.com/img/bVbtPb5?w=420&h=400" alt="clipboard.png"></p><ol><li>Docker镜像采用分层存储格式，每个镜像可依赖其他镜像进行构建，每一层的镜像可被多个镜像引用，对用户而言，他们所看到的容器，其实是Docker利用UnionFS（联合文件系统）把相关镜像层的目录“联合”到同一个挂载点呈现出来的一个整体</li><li>利用UnionFS写时复制的特点，在启动一个容器时， Docker引擎实际上只是增加了一个可写层(如果对一个只读的文件进行修改，在修改前会先把文件复制一份到可写层)和构造了一个Linux容器，这两者都几乎不消耗系统资源，因此Docker容器能够做到秒级启动</li><li>Docker中的操作系统镜像，与平常安装系统时用的ISO镜像不同。ISO镜像里包含了操作系统内核及该发行版系统包含的所有目录和软件，而Docker中的操作系统镜像，<span style="color:red">不包含系统内核，多个镜像公用同一个内核</span>，仅包含系统必备的一些目录（如&#x2F;etc &#x2F;proc等）和常用的软件和运行库等</li></ol></li><li><p>Docker的资源隔离原理？</p><ol><li><p><code>Linux Container</code>是Linux系统提供的容器化技术，简称<code>LXC</code>，它结合Namespace和CGroup技术为用户提供了更易用的接口来实现容器化</p><blockquote><ol><li>首先说一下何为容器，Linux系统提供了<code>Namespace</code>和<code>CGroup</code>技术实现环境隔离和资源控制，其中Namespace是Linux提供的一种内核级别环境隔离的方法，能使一个进程和该进程创建的子进程的运行空间都与Linux的超级父进程相隔离</li><li>注意Namespace只能实现运行空间的隔离，物理资源还是所有进程共用的，为了实现资源隔离，Linux系统提供了CGroup技术来控制一个进程组群可使用的资源（如CPU、内存、磁盘IO等），把这两种技术结合起来，就能构造一个用户空间独立且限定了资源的对象，这样的对象称为容器。</li></ol></blockquote></li><li><p>LXC仅为一种轻量级的容器化技术，它仅能对部分资源进行限制，无法做到诸如网络限制、磁盘空间占用限制等。dotCloud公司结合LXC和<code>以下列出的技术</code>实现了Docker容器引擎：Chroot，UnionFS等</p></li></ol></li><li><p>Docker持久化存储</p><ol><li>把宿主机文件系统里的目录映射到容器内的目录。如此一来，容器内在该目录里创建的所有文件，都存储到宿主机的对应目录中</li><li>把多台宿主机的磁盘目录通过网络联合为共享存储，然后把共享存储中的特定目录映射给特定的容器</li></ol></li><li><p>Docker镜像制作方法</p><ol><li>通过正在运行的容器生成新镜像</li><li>通过Dockerfile文件来生成新镜像</li></ol></li><li><p>磁盘  <a href="https://mp.weixin.qq.com/s/tG1kOGtAJzHc37XGlsfAPQ">https://mp.weixin.qq.com/s/tG1kOGtAJzHc37XGlsfAPQ</a></p><ol><li>df -h  主要是用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计<ol><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKL2vMuicdKHY3df9AyaODC78V8jr4051Ia6BKx0BMicCTHxIM8ibPtr4abQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li><li>结果参数<ol><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKLwSZfpibtox4pHEoOw3nvhFyT4IGxN5psvccBqseMzDicfPKNQbrA5Y2w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKLjqj8QSBCZzqDsBUNCXaPicJ9TL3eL4DpiapU9zKJFXVMm6gqJKicYPMWA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol></li></ol></li><li>du 主要是为了显示目录或文件的大小。<ol><li>常用参数<ol><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKLDXMJJ0w6qXxuFICjOC9dZJVf1We35J6jnSaFARvibTbIhPFhDyXjeNw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol></li><li>结果参数<ol><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKLkwP8zrxmG3icyzAMOtZBBrSBxT9uDDW1lxCfzL2UumsWyJmdNnbLibQQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol></li></ol></li><li>ls   主要是用于显示指定工作目录下的内容的信息<ol><li>常用参数<ol><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKLjZtoibD1Q6B2icVVr9A0sxZcMj1XIKdol6AvYP0pywXqzgTsuLodCOicw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol></li><li>结果参数<ol><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKLXBU4xzkib6ndaBJt3IKVAxnzEDdZ1mpxm7TbwpbuO4Y9WIVXEgHrtDA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol></li></ol></li></ol></li><li><p>CPU过高</p><ol><li><p>利用 top 查询CPU使用率最高的进程</p><ol><li><p>常用参数</p><ol><li><p><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKLjWQ3selr1fK1bpiaVG9vvXTXOQJciaZibSpARnW0emwCJibFHdEpsCiaITg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p></li><li><p>top进程内指令参数：</p><p><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKLypCdQTt841IHQGJwWWh9791ohlqMDh42QdpdcdcTL3mqwOq8QicHKbA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p></li></ol></li><li><p>结果参数</p><ol><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKLnSRnibcPvcDJMwRffRsZZiaApnAxXMqyD4icN6K6bv6AGUd7M8DHu4OSQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKLTGewicOjqdbjB9fvoxVBQnVrCdkFmZ66LpjCWXANF0icP2WT8EdT937w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol></li></ol></li></ol></li><li><p>Tomcat假死案例分析</p><ol><li>发现问题 监控平台发现某个Tomcat节点已经无法采集到数据，连上服务器查看服务器进程还在，netstat -anop|grep 8001端口也有监听，查看日志打印时断时续</li><li>&#x2F;usr&#x2F;bin&#x2F;jmap -dump:live,format&#x3D;b,file&#x3D;&#x2F;etc&#x2F;redis&#x2F;jmap-8001-2.bin 27401  dump内存快照</li><li>使用Memory Analyzer解析dump文件</li></ol></li><li><p>查询当前事务情况</p><ol><li><p>可以通过查看如下3张表做相应的处理</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 当前运行的所有事务</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> information_schema.innodb_trx;</span><br><span class="line"><span class="comment">-- 当前出现的锁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.INNODB_LOCKS;</span><br><span class="line"><span class="comment">-- 锁等待的对应关系</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> information_schema.INNODB_LOCK_WAITS;</span><br></pre></td></tr></table></figure></li><li><p>查看当前的事务有哪些</p><ol><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKL27khlkueGFicXfpTUE4MRQDYAsF5EPHQ6nDtwjficVwzgty6ZU7Hsdwg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol></li><li><p>查看事务锁类型索引的详细信息</p><ol><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKLGLZEV1GwZWWtTOymVekSaiaeJb3M5T1VW964aTBxomV0QGLyRP48qDQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol></li></ol></li><li><p>连接数过多：常出现too many connections异常,数据库连接到达最大连接数</p><ol><li><p>解决方案：</p><ul><li>通过set global max_connections&#x3D;XXX增大最大连接数。</li><li>先利用show processlist获取连接信息，然后利用kill杀死过多的连</li></ul></li></ol></li><li><p>优化SQL</p><ol><li>通过增加索引，调整SQL语句的方式优化执行时长<ol><li><img src="/img/OIP-C.jpg" data-original="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKLKINxnsia7BDa9Gwa1N0bLiaRxhW2mXOH5fM6Knl60u9icHVBtrv4f2icfQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ol></li></ol></li><li><p>命令：</p><ol><li>磁盘和网络<ol><li>df：查看磁盘空间占用情况</li><li>dh：查看当前目录下的文件及文件夹所占大小</li><li>ifconfig：显示当前网络接口状态</li><li>netstat：查看当前路由信息</li></ol></li><li>解压与压缩<ol><li>tar</li></ol></li><li>文件管理<ol><li>man：显示指定命令的帮助信息</li><li>who：查询系统处于什么运行级别</li><li>clear：用于清除屏幕信息</li><li>mkdir：创建目录</li><li>touch：用于创建文件</li><li>more：用于分页查看文件，例如每页10行查看<code>boot.log</code>文件：more -c -10 &#x2F;var&#x2F;log&#x2F;boot.log</li><li>cat：用于查看文件</li><li>cp：用于拷贝文件</li></ol></li><li>软件安装<ol><li>rpm：RPM是<code>Red-Hat Package Manager</code>的缩写，一种Linux下通用的软件包管理方式，可用于安装和管理<code>.rpm</code>结尾的软件包</li><li>yum：Yum是<code>Yellow dog Updater, Modified</code>的缩写，能够在线自动下载RPM包并安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包</li></ol></li></ol></li></ol><p>​     </p><p>​      </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2.&lt;br&gt;3. Kill 命令的一些区别  &lt;a href=&quot;https://www.cnblogs.com/hollischuang/p/12880614.html&quot;&gt;https://www.cnblogs.com/hollischuang/p/12880614.htm</summary>
      
    
    
    
    <category term="面试题" scheme="http://www.sion-io.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="http://www.sion-io.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Juc-面试题</title>
    <link href="http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%B9%B6%E5%8F%91/"/>
    <id>http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%B9%B6%E5%8F%91/</id>
    <published>2024-05-12T08:42:17.400Z</published>
    <updated>2024-05-12T08:48:19.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-并发进阶常见面试题总结"><a href="#Java-并发进阶常见面试题总结" class="headerlink" title="Java 并发进阶常见面试题总结"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=java-%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93">Java 并发进阶常见面试题总结</a></h1><h2 id="1-synchronized-关键字"><a href="#1-synchronized-关键字" class="headerlink" title="1.synchronized 关键字"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_1synchronized-%E5%85%B3%E9%94%AE%E5%AD%97">1.synchronized 关键字</a></h2><h3 id="1-5-谈谈-synchronized-和-ReentrantLock-的区别"><a href="#1-5-谈谈-synchronized-和-ReentrantLock-的区别" class="headerlink" title="1.5. 谈谈 synchronized 和 ReentrantLock 的区别"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_15-%E8%B0%88%E8%B0%88-synchronized-%E5%92%8C-reentrantlock-%E7%9A%84%E5%8C%BA%E5%88%AB">1.5. 谈谈 synchronized 和 ReentrantLock 的区别</a></h3><h4 id="1-5-1-两者都是可重入锁"><a href="#1-5-1-两者都是可重入锁" class="headerlink" title="1.5.1. 两者都是可重入锁"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_151-%E4%B8%A4%E8%80%85%E9%83%BD%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81">1.5.1. 两者都是可重入锁</a></h4><h4 id="1-5-2-synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API"><a href="#1-5-2-synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API" class="headerlink" title="1.5.2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_152synchronized-%E4%BE%9D%E8%B5%96%E4%BA%8E-jvm-%E8%80%8C-reentrantlock-%E4%BE%9D%E8%B5%96%E4%BA%8E-api">1.5.2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</a></h4><h4 id="1-5-3-ReentrantLock-比-synchronized-增加了一些高级功能"><a href="#1-5-3-ReentrantLock-比-synchronized-增加了一些高级功能" class="headerlink" title="1.5.3.ReentrantLock 比 synchronized 增加了一些高级功能"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_153reentrantlock-%E6%AF%94-synchronized-%E5%A2%9E%E5%8A%A0%E4%BA%86%E4%B8%80%E4%BA%9B%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD">1.5.3.ReentrantLock 比 synchronized 增加了一些高级功能</a></h4><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul><h3 id="最后：特别总结"><a href="#最后：特别总结" class="headerlink" title="最后：特别总结"></a>最后：特别总结</h3><h4 id="4-5-Monitor-概念"><a href="#4-5-Monitor-概念" class="headerlink" title="4.5 Monitor 概念"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%911?id=_45-monitor-%E6%A6%82%E5%BF%B5">4.5 Monitor 概念</a></h4><h5 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%911?id=java-%E5%AF%B9%E8%B1%A1%E5%A4%B4">Java 对象头</a></h5><p>以 32 位虚拟机为例,普通对象的对象头结构如下，其中的Klass Word为指针，指向对应的Class对象；</p><p><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200308223951-617147.png" alt="1583651065372"></p><p>数组对象</p><p><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200308150448-901728.png" alt="1583651088663"></p><p>其中 Mark Word 结构为</p><p><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200308151311-525787.png" alt="1583651590160"></p><p>所以一个对象的结构如下：</p><p><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200308224345-655905.png" alt="1583678624634"></p><h5 id="Monitor-原理"><a href="#Monitor-原理" class="headerlink" title="Monitor 原理"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%911?id=monitor-%E5%8E%9F%E7%90%86">Monitor 原理</a></h5><p>Monitor被翻译为监视器或者说管程</p><p>每个java对象都可以关联一个Monitor，如果使用<code>synchronized</code>给对象上锁（重量级），该对象头的Mark Word中就被设置为指向Monitor对象的指针</p><p><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200309172316-799735.png" alt="1583652360228"></p><ul><li>刚开始时Monitor中的Owner为null</li><li>当Thread-2 执行synchronized(obj){}代码时就会将Monitor的所有者Owner 设置为 Thread-2，上锁成功，Monitor中同一时刻只能有一个Owner</li><li>当Thread-2 占据锁时，如果线程Thread-3，Thread-4也来执行synchronized(obj){}代码，就会进入EntryList中变成BLOCKED状态</li><li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是非公平的</li><li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析</li></ul><blockquote><p>注意：synchronized 必须是进入同一个对象的 monitor 才有上述的效果不加 synchronized 的对象不会关联监视器，不遵从以上规则</p></blockquote><h5 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%911?id=synchronized%E5%8E%9F%E7%90%86-1">synchronized原理</a></h5><p>代码如下 Test17.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object lock=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的部分字节码</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="attr">0</span> <span class="string">getstatic #2 &lt;com/concurrent/test/Test17.lock&gt;</span></span><br><span class="line"><span class="comment"> # 取得lock的引用（synchronized开始了）</span></span><br><span class="line"> <span class="attr">3</span> <span class="string">dup    </span></span><br><span class="line"><span class="comment"> # 复制操作数栈栈顶的值放入栈顶，即复制了一份lock的引用</span></span><br><span class="line"> <span class="attr">4</span> <span class="string">astore_1</span></span><br><span class="line"><span class="comment"> # 操作数栈栈顶的值弹出，即将lock的引用存到局部变量表中</span></span><br><span class="line"> <span class="attr">5</span> <span class="string">monitorenter</span></span><br><span class="line"><span class="comment"> # 将lock对象的Mark Word置为指向Monitor指针</span></span><br><span class="line"> <span class="attr">6</span> <span class="string">getstatic #3 &lt;com/concurrent/test/Test17.counter&gt;</span></span><br><span class="line"> <span class="attr">9</span> <span class="string">iconst_1</span></span><br><span class="line"><span class="attr">10</span> <span class="string">iadd</span></span><br><span class="line"><span class="attr">11</span> <span class="string">putstatic #3 &lt;com/concurrent/test/Test17.counter&gt;</span></span><br><span class="line"><span class="attr">14</span> <span class="string">aload_1</span></span><br><span class="line"><span class="comment"># 从局部变量表中取得lock的引用，放入操作数栈栈顶</span></span><br><span class="line"><span class="attr">15</span> <span class="string">monitorexit</span></span><br><span class="line"><span class="comment"># 将lock对象的Mark Word重置，唤醒EntryList</span></span><br><span class="line"><span class="attr">16</span> <span class="string">goto 24 (+8)</span></span><br><span class="line"><span class="comment"># 下面是异常处理指令，可以看到，如果出现异常，也能自动地释放锁</span></span><br><span class="line"><span class="attr">19</span> <span class="string">astore_2</span></span><br><span class="line"><span class="attr">20</span> <span class="string">aload_1</span></span><br><span class="line"><span class="attr">21</span> <span class="string">monitorexit</span></span><br><span class="line"><span class="attr">22</span> <span class="string">aload_2</span></span><br><span class="line"><span class="attr">23</span> <span class="string">athrow</span></span><br><span class="line"><span class="attr">24</span> <span class="string">return</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：方法级别的 synchronized 不会在字节码指令中有所体现</p></blockquote><h5 id="synchronized-原理进阶"><a href="#synchronized-原理进阶" class="headerlink" title="synchronized 原理进阶"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%911?id=synchronized-%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6">synchronized 原理进阶</a></h5><h6 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%911?id=%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81">轻量级锁</a></h6><p>轻量级锁的使用场景是：如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有人可以竞争的），那么可以使用轻量级锁来进行优化。轻量级锁对使用者是透明的，即语法仍然是<code>synchronized</code>，假设有两个方法同步块，利用同一个对象加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 A</span></span><br><span class="line">         method2();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 B</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>每次指向到synchronized代码块时，都会创建锁记录（Lock Record）对象，每个线程都会包括一个锁记录的结构，锁记录内部可以储存对象的Mark Word和对象引用reference<ol><li><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200309200902-382362.png" alt="1583755737580"></li></ol></li><li>让锁记录中的Object reference指向对象，并且尝试用cas(compare and sweep)替换Object对象的Mark Word ，将Mark Word 的值存入锁记录中<ol><li><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200309201132-961387.png" alt="1583755888236"></li></ol></li><li>如果cas替换成功，那么对象的对象头储存的就是锁记录的地址和状态01，如下所示<ol><li><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200309201247-989088.png" alt="1583755964276"></li></ol></li><li>如果cas失败，有两种情况<ol><li>如果是其它线程已经持有了该Object的轻量级锁，那么表示有竞争，将进入锁膨胀阶段</li><li>如果是自己的线程已经执行了synchronized进行加锁，那么那么再添加一条 Lock Record 作为重入的计数<ol><li><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200309201634-451646.png" alt="1583756190177"></li></ol></li></ol></li><li>当线程退出synchronized代码块的时候，**如果获取的是取值为 null 的锁记录 **，表示有重入，这时重置锁记录，表示重入计数减一<ol><li><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200309201919-357425.png" alt="1583756357835"></li></ol></li><li>当线程退出synchronized代码块的时候，如果获取的锁记录取值不为 null，那么使用cas将Mark Word的值恢复给对象<ol><li>成功则解锁成功</li><li>失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ol></li></ol><h6 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%911?id=%E9%94%81%E8%86%A8%E8%83%80">锁膨胀</a></h6><p>如果在尝试加轻量级锁的过程中，cas操作无法成功，这是有一种情况就是其它线程已经为这个对象加上了轻量级锁，这是就要进行锁膨胀，将轻量级锁变成重量级锁。</p><ol><li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁<ol><li><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200309203715-909034.png" alt="1583757433691"></li></ol></li><li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ol><li>即为对象申请Monitor锁，让Object指向重量级锁地址，然后自己进入Monitor 的EntryList 变成BLOCKED状态</li><li><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200309203947-654193.png" alt="1583757586447"></li></ol></li><li>当Thread-0 推出synchronized同步块时，使用cas将Mark  Word的值恢复给对象头，失败，那么会进入重量级锁的解锁过程，即按照Monitor的地址找到Monitor对象，将Owner设置为null，唤醒EntryList 中的Thread-1线程</li></ol><h6 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%911?id=%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96">自旋优化</a></h6><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以不用进行上下文切换就获得了锁</p><ol><li>自旋重试成功的情况<ol><li><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200309204835-425698.png" alt="1583758113724"></li></ol></li><li>自旋重试失败的情况，自旋了一定次数还是没有等到持锁的线程释放锁<ol><li><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200309204915-424942.png" alt="1583758136650"></li></ol></li></ol><p>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。在 Java 6  之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能</p><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%911?id=%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a></h5><p>在轻量级的锁中，我们可以发现，如果同一个线程对同一个2对象进行重入锁时，也需要执行CAS操作，这是有点耗时滴，那么java6开始引入了偏向锁的东东，只有第一次使用CAS时将对象的Mark Word头设置为入锁线程ID，<strong>之后这个入锁线程再进行重入锁时，发现线程ID是自己的，那么就不用再进行CAS了</strong></p><p><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200309213209-28609.png" alt="1583760728806"></p><h6 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%911?id=%E5%81%8F%E5%90%91%E7%8A%B6%E6%80%81">偏向状态</a></h6><p><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200309215610-51761.png" alt="1583762169169"></p><p>一个对象的创建过程</p><ol><li><p>如果开启了偏向锁（默认是开启的），那么对象刚创建之后，Mark Word 最后三位的值101，并且这是它的Thread，epoch，age都是0，在加锁的时候进行设置这些的值.</p></li><li><p>偏向锁默认是延迟的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：-<code>XX:BiasedLockingStartupDelay=0</code>来禁用延迟</p></li><li><p>注意：处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</p></li><li><p>实验Test18.java，加上虚拟机参数-XX:BiasedLockingStartupDelay&#x3D;0进行测试</p><ol><li><pre><code class="java">public static void main(String[] args) throws InterruptedException &#123;        Test1 t = new Test1();        test.parseObjectHeader(getObjectHeader(t))；        synchronized (t)&#123;            test.parseObjectHeader(getObjectHeader(t));        &#125;        test.parseObjectHeader(getObjectHeader(t));    &#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 输出结果如下，三次输出的状态码都为101</span><br><span class="line"></span><br><span class="line">```properties</span><br><span class="line">biasedLockFlag (1bit): 1</span><br><span class="line">    LockFlag (2bit): 01</span><br><span class="line">biasedLockFlag (1bit): 1</span><br><span class="line">    LockFlag (2bit): 01</span><br><span class="line">biasedLockFlag (1bit): 1</span><br><span class="line">    LockFlag (2bit): 01</span><br></pre></td></tr></table></figure></code></pre></li></ol></li></ol><p>测试禁用：如果没有开启偏向锁，那么对象创建后最后三位的值为001，这时候它的hashcode，age都为0，hashcode是第一次用到<code>hashcode</code>时才赋值的。在上面测试代码运行时在添加 VM 参数<code>-XX:-UseBiasedLocking</code>禁用偏向锁（禁用偏向锁则优先使用轻量级锁），退出<code>synchronized</code>状态变回001</p><ol><li><p>测试代码Test18.java 虚拟机参数<code>-XX:-UseBiasedLocking</code></p></li><li><p>输出结果如下，最开始状态为001，然后加轻量级锁变成00，最后恢复成001</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 0</span></span><br><span class="line">    <span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">LockFlag</span> <span class="string">(2bit): 00</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 0</span></span><br><span class="line">    <span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br></pre></td></tr></table></figure></li></ol><h6 id="撤销偏向锁-hashcode方法"><a href="#撤销偏向锁-hashcode方法" class="headerlink" title="撤销偏向锁-hashcode方法"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%911?id=%E6%92%A4%E9%94%80%E5%81%8F%E5%90%91%E9%94%81-hashcode%E6%96%B9%E6%B3%95">撤销偏向锁-hashcode方法</a></h6><p>测试 <code>hashCode</code>：当调用对象的hashcode方法的时候就会撤销这个对象的偏向锁，因为使用偏向锁时没有位置存<code>hashcode</code>的值了</p><ol><li><p>测试代码如下，使用虚拟机参数<code>-XX:BiasedLockingStartupDelay=0</code>  ，确保我们的程序最开始使用了偏向锁！但是结果显示程序还是使用了轻量级锁。  Test20.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Test1</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">    t.hashCode();</span><br><span class="line">    test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">synchronized</span> (t)&#123;</span><br><span class="line">        test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">    &#125;</span><br><span class="line">    test.parseObjectHeader(getObjectHeader(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>输出结果</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 0</span></span><br><span class="line">    <span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">LockFlag</span> <span class="string">(2bit): 00</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 0</span></span><br><span class="line">    <span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br></pre></td></tr></table></figure><h6 id="撤销偏向锁-其它线程使用对象"><a href="#撤销偏向锁-其它线程使用对象" class="headerlink" title="撤销偏向锁-其它线程使用对象"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%911?id=%E6%92%A4%E9%94%80%E5%81%8F%E5%90%91%E9%94%81-%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1">撤销偏向锁-其它线程使用对象</a></h6><p>这里我们演示的是偏向锁撤销变成轻量级锁的过程，那么就得满足轻量级锁的使用条件，就是没有线程对同一个对象进行锁竞争，我们使用<code>wait</code> 和 <code>notify</code> 来辅助实现</p><ol><li><p>代码 Test19.java，虚拟机参数<code>-XX:BiasedLockingStartupDelay=0</code>确保我们的程序最开始使用了偏向锁！</p></li><li><p>输出结果，最开始使用的是偏向锁，但是第二个线程尝试获取对象锁时，发现本来对象偏向的是线程一，那么偏向锁就会失效，加的就是轻量级锁</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 1</span></span><br><span class="line">    <span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 1</span></span><br><span class="line">    <span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 1</span></span><br><span class="line">    <span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 1</span></span><br><span class="line">    <span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br><span class="line"><span class="attr">LockFlag</span> <span class="string">(2bit): 00</span></span><br><span class="line"><span class="attr">biasedLockFlag</span> <span class="string">(1bit): 0</span></span><br><span class="line">    <span class="attr">LockFlag</span> <span class="string">(2bit): 01</span></span><br></pre></td></tr></table></figure></li></ol><h6 id="撤销-调用-wait-notify"><a href="#撤销-调用-wait-notify" class="headerlink" title="撤销 - 调用 wait&#x2F;notify"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%911?id=%E6%92%A4%E9%94%80-%E8%B0%83%E7%94%A8-waitnotify">撤销 - 调用 wait&#x2F;notify</a></h6><p>会使对象的锁变成重量级锁，因为wait&#x2F;notify方法之后重量级锁才支持</p><h6 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%911?id=%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91">批量重偏向</a></h6><p>如果对象被多个线程访问，但是没有竞争，这时候偏向了线程一的对象又有机会重新偏向线程二，即可以不用升级为轻量级锁，可这和我们之前做的实验矛盾了呀，其实要实现重新偏向是要有条件的：就是超过20对象对同一个线程如线程一撤销偏向时，那么第20个及以后的对象才可以将撤销对线程一的偏向这个动作变为将第20个及以后的对象偏向线程二。Test21.java</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="2-volatile-关键字"><a href="#2-volatile-关键字" class="headerlink" title="2. volatile 关键字"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_2-volatile-%E5%85%B3%E9%94%AE%E5%AD%97">2. volatile 关键字</a></h2><h3 id="2-3-并发编程的三个重要特性"><a href="#2-3-并发编程的三个重要特性" class="headerlink" title="2.3. 并发编程的三个重要特性"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_23-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7">2.3. 并发编程的三个重要特性</a></h3><ol><li><strong>原子性</strong> : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性</strong> ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li><li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li></ol><h3 id="2-4-说说-synchronized-关键字和-volatile-关键字的区别"><a href="#2-4-说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="2.4. 说说 synchronized 关键字和 volatile 关键字的区别"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_24-%E8%AF%B4%E8%AF%B4-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB">2.4. 说说 synchronized 关键字和 volatile 关键字的区别</a></h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p><ul><li><strong>volatile 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile 性能肯定比 synchronized 关键字要好</strong>。但是<strong>volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块</strong>。</li><li><strong>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</strong></li><li><strong>volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</strong></li></ul><h3 id="最后：特别总结-1"><a href="#最后：特别总结-1" class="headerlink" title="最后：特别总结"></a>最后：特别总结</h3><h4 id="volatile-原理"><a href="#volatile-原理" class="headerlink" title="volatile 原理"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%912?id=volatile-%E5%8E%9F%E7%90%86">volatile 原理</a></h4><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）</p><ol><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ol><h5 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%912?id=%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7">如何保证可见性</a></h5><ol><li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>; <span class="comment">// ready是被volatile修饰的 ，赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line"> <span class="comment">// 读屏障</span></span><br><span class="line"> <span class="comment">//  ready是被volatile修饰的 ，读取值带读屏障</span></span><br><span class="line"> <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">     r.r1 = num + num;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     r.r1 = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200714114615-934315.png" alt="1594698374315"></p><h5 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%912?id=%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7">如何保证有序性</a></h5><ol><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line"> num = <span class="number">2</span>;</span><br><span class="line"> ready = <span class="literal">true</span>; <span class="comment">//  ready是被volatile修饰的 ， 赋值带写屏障</span></span><br><span class="line"> <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line"> <span class="comment">// 读屏障</span></span><br><span class="line"> <span class="comment">//  ready是被volatile修饰的 ，读取值带读屏障</span></span><br><span class="line"> <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">     r.r1 = num + num;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     r.r1 = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200714114921-56542.png" alt="1594698559052"></li></ol><p>还是那句话，不能解决指令交错：</p><ol><li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其它线程的读跑到它前面去</li><li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li></ol><p><img src="/img/OIP-C.jpg" data-original="http://bodiegu.lsgdut.fun/20200714115112-322421.png" alt="1594698671628"></p><h4 id="线程安全单例习题"><a href="#线程安全单例习题" class="headerlink" title="线程安全单例习题"></a><a href="https://gu_chun_bo.gitee.io/java-construct/#/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%912?id=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8D%95%E4%BE%8B%E4%B9%A0%E9%A2%98">线程安全单例习题</a></h4><p>单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用 getInstance）时的线程安全，并思考注释中的问题 饿汉式：类加载就会导致该单实例对象被创建 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p><p>实现1： 饿汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题1：为什么加 final，防止子类继承后更改</span></span><br><span class="line"><span class="comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例，如果进行反序列化的时候会生成新的对象，这样跟单例模式生成的对象是不同的。要解决直接加上readResolve()方法就行了，如下所示</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 问题3：为什么设置为私有? 放弃其它类中使用new生成新的实例，是否能防止反射创建新的实例?不能。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?没有，这是类变量，是jvm在类加载阶段就进行了初始化，jvm保证了此操作的线程安全性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。</span></span><br><span class="line">    <span class="comment">//1.提供更好的封装性；2.提供范型的支持</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现2： 饿汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题1：枚举单例是如何限制实例个数的：创建枚举类的时候就已经定义好了，每个枚举常量其实就是枚举类的一个静态成员变量</span></span><br><span class="line"><span class="comment">// 问题2：枚举单例在创建时是否有并发问题：没有，这是静态成员变量</span></span><br><span class="line"><span class="comment">// 问题3：枚举单例能否被反射破坏单例：不能</span></span><br><span class="line"><span class="comment">// 问题4：枚举单例能否被反序列化破坏单例：枚举类默认实现了序列化接口，枚举类已经考虑到此问题，无需担心破坏单例</span></span><br><span class="line"><span class="comment">// 问题5：枚举单例属于懒汉式还是饿汉式：饿汉式</span></span><br><span class="line"><span class="comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做：加构造方法就行了</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现3：懒汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 分析这里的线程安全, 并说明有什么缺点：synchronized加载静态方法上，可以保证线程安全。缺点就是锁的范围过大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( INSTANCE != <span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现4：DCL  懒汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：解释为什么要加 volatile ?为了防止重排序问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题2：对比实现3, 说出这样做的意义：提高了效率</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗？这是为了第一次判断时的并发问题。</span></span><br><span class="line">            <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="keyword">return</span> INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现5：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：属于懒汉式还是饿汉式：懒汉式，这是一个静态内部类。类加载本身就是懒惰的，在没有调用getInstance方法时是没有执行LazyHolder内部类的类加载操作的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 问题2：在创建时是否有并发问题，这是线程安全的，类加载时，jvm保证类加载操作的线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-ThreadLocal"><a href="#3-ThreadLocal" class="headerlink" title="3. ThreadLocal"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_3-threadlocal">3. ThreadLocal</a></h2><h2 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4. 线程池"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_4-%E7%BA%BF%E7%A8%8B%E6%B1%A0">4. 线程池</a></h2><h3 id="4-1-为什么要用线程池？"><a href="#4-1-为什么要用线程池？" class="headerlink" title="4.1. 为什么要用线程池？"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_41-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F">4.1. 为什么要用线程池？</a></h3><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="4-2-实现-Runnable-接口和-Callable-接口的区别"><a href="#4-2-实现-Runnable-接口和-Callable-接口的区别" class="headerlink" title="4.2. 实现 Runnable 接口和 Callable 接口的区别"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_42-%E5%AE%9E%E7%8E%B0-runnable-%E6%8E%A5%E5%8F%A3%E5%92%8C-callable-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB">4.2. 实现 Runnable 接口和 Callable 接口的区别</a></h3><p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。**<code>Runnable</code> 接口<strong>不会返回结果或抛出检查异常，但是</strong><code>Callable</code> 接口<strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 **<code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。</p><p>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。（<code>Executors.callable（Runnable task</code>）或 <code>Executors.callable（Runnable task，Object resule）</code>）。</p><h3 id="4-3-执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#4-3-执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="4.3. 执行 execute()方法和 submit()方法的区别是什么呢？"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_43-%E6%89%A7%E8%A1%8C-execute%E6%96%B9%E6%B3%95%E5%92%8C-submit%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F">4.3. 执行 execute()方法和 submit()方法的区别是什么呢？</a></h3><ol><li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li><li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><h3 id="4-5-ThreadPoolExecutor-类分析"><a href="#4-5-ThreadPoolExecutor-类分析" class="headerlink" title="4.5 ThreadPoolExecutor 类分析"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_45-threadpoolexecutor-%E7%B1%BB%E5%88%86%E6%9E%90">4.5 ThreadPoolExecutor 类分析</a></h3><h4 id="4-5-1-ThreadPoolExecutor构造函数重要参数分析"><a href="#4-5-1-ThreadPoolExecutor构造函数重要参数分析" class="headerlink" title="4.5.1 ThreadPoolExecutor构造函数重要参数分析"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_451-threadpoolexecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90">4.5.1 <code>ThreadPoolExecutor</code>构造函数重要参数分析</a></h4><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数:</p><ol><li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li></ol><h4 id="4-5-2-ThreadPoolExecutor-饱和策略"><a href="#4-5-2-ThreadPoolExecutor-饱和策略" class="headerlink" title="4.5.2 ThreadPoolExecutor 饱和策略"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_452-threadpoolexecutor-%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5">4.5.2 <code>ThreadPoolExecutor</code> 饱和策略</a></h4><p><strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p><ul><li>**<code>ThreadPoolExecutor.AbortPolicy</code>**：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li>**<code>ThreadPoolExecutor.CallerRunsPolicy</code>**：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul><h2 id="6-AQS"><a href="#6-AQS" class="headerlink" title="6. AQS"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_6-aqs">6. AQS</a></h2><h3 id="6-2-AQS-原理分析"><a href="#6-2-AQS-原理分析" class="headerlink" title="6.2. AQS 原理分析"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_62-aqs-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90">6.2. AQS 原理分析</a></h3><h4 id="6-2-2-AQS-对资源的共享方式"><a href="#6-2-2-AQS-对资源的共享方式" class="headerlink" title="6.2.2. AQS 对资源的共享方式"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_622-aqs-%E5%AF%B9%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F">6.2.2. AQS 对资源的共享方式</a></h4><p><strong>AQS 定义两种资源共享方式</strong></p><ul><li><p>Exclusive</p><p>（独占）：只有一个线程能执行，如 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock</span><br></pre></td></tr></table></figure><p>。又可分为公平锁和非公平锁：</p><ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><p><strong>Share</strong>（共享）：多个线程可同时执行，如<code> CountDownLatch</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code> 我们都会在后面讲到。</p></li></ul><p><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS 已经在顶层实现好了。</p><h3 id="6-3-AQS-组件总结"><a href="#6-3-AQS-组件总结" class="headerlink" title="6.3. AQS 组件总结"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=_63-aqs-%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93">6.3. AQS 组件总结</a></h3><ul><li><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li><li><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li><li><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比  CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier  的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await()方法告诉  CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li></ul><h1 id="AQS-原理以及-AQS-同步组件总结"><a href="#AQS-原理以及-AQS-同步组件总结" class="headerlink" title="AQS 原理以及 AQS 同步组件总结"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/AQS%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AAQS%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93">AQS 原理以及 AQS 同步组件总结</a></h1><h3 id="3-Semaphore-信号量-允许多个线程同时访问"><a href="#3-Semaphore-信号量-允许多个线程同时访问" class="headerlink" title="3 Semaphore(信号量)-允许多个线程同时访问"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/AQS%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AAQS%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93?id=_3-semaphore%E4%BF%A1%E5%8F%B7%E9%87%8F-%E5%85%81%E8%AE%B8%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E8%AE%BF%E9%97%AE">3 Semaphore(信号量)-允许多个线程同时访问</a></h3><p><strong>synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</strong> </p><p>执行 <code>acquire</code> 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 <code>release</code> 方法增加一个许可证，实际调用releaseShared 方法，这可能会释放一个阻塞的 acquire 方法，实际调用 acquireSharedInterruptibly方法。然而，其实并没有实际的许可证这个对象，Semaphore 只是维持了一个可获得许可证的数量。 Semaphore 经常用于限制获取某种资源的线程数量。</p><h3 id="4-CountDownLatch-（倒计时器）"><a href="#4-CountDownLatch-（倒计时器）" class="headerlink" title="4 CountDownLatch （倒计时器）"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/AQS%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AAQS%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93?id=_4-countdownlatch-%EF%BC%88%E5%80%92%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%89">4 CountDownLatch （倒计时器）</a></h3><p>CountDownLatch允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。在 Java 并发中，countdownlatch 的概念是一个常见的面试题，所以一定要确保你很好的理解了它。</p><p>CountDownLatch是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。当线程使用countDown方法时,其实使用了<code>releaseShared</code>方法以CAS的操作来减少state,直至state为0就代表所有的线程都调用了countDown方法。当调用await方法的时候，其实调用了acquireSharedInterruptibly 方法，如果state不为0，就代表仍然有线程没有调用countDown方法，那么就把已经调用过countDown的线程都放入阻塞队列Park,并自旋CAS判断state &#x3D;&#x3D; 0，直至最后一个线程调用了countDown，使得state &#x3D;&#x3D; 0，于是阻塞的线程便判断成功，全部往下执行。</p><h4 id="4-3-CountDownLatch-的不足"><a href="#4-3-CountDownLatch-的不足" class="headerlink" title="4.3 CountDownLatch 的不足"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/AQS%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AAQS%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93?id=_43-countdownlatch-%E7%9A%84%E4%B8%8D%E8%B6%B3">4.3 CountDownLatch 的不足</a></h4><p>CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。</p><h3 id="5-CyclicBarrier-循环栅栏"><a href="#5-CyclicBarrier-循环栅栏" class="headerlink" title="5 CyclicBarrier(循环栅栏)"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/AQS%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AAQS%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93?id=_5-cyclicbarrier%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F">5 CyclicBarrier(循环栅栏)</a></h3><p>CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。</p><blockquote><p>CountDownLatch的实现是基于AQS的，而CycliBarrier是基于 ReentrantLock(ReentrantLock也属于AQS同步器)和 Condition 的.</p></blockquote><p>CyclicBarrier  的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用<code>await</code>方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</p><h4 id="5-4-CyclicBarrier-和-CountDownLatch-的区别javadoc-是这么描述它们的："><a href="#5-4-CyclicBarrier-和-CountDownLatch-的区别javadoc-是这么描述它们的：" class="headerlink" title="5.4 CyclicBarrier 和 CountDownLatch 的区别javadoc 是这么描述它们的："></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/AQS%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AAQS%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93?id=_54-cyclicbarrier-%E5%92%8C-countdownlatch-%E7%9A%84%E5%8C%BA%E5%88%AB">5.4 CyclicBarrier 和 CountDownLatch 的区别</a>javadoc 是这么描述它们的：</h4><blockquote><p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads  completes.(CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；) CyclicBarrier : A synchronization aid that allows a set of threads to  all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)</p></blockquote><p>对于 CountDownLatch 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p><p>CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p><h3 id="6-我发现的小细节"><a href="#6-我发现的小细节" class="headerlink" title="6. 我发现的小细节"></a>6. 我发现的小细节</h3><p>CyclicBarrier多个线程在执行完await之后不能继续执行后面的方法，除非达到指定的线程数；</p><p>CountDownLatch在执行完countDown之后还能继续执行后面的方法</p><p>以上结论从源码的角度分析即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                test(threadnum);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                countDownLatch.countDown();<span class="comment">// 表示一个请求已经被完成</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span> + threadnum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java-线程池学习总结"><a href="#Java-线程池学习总结" class="headerlink" title="Java 线程池学习总结"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93">Java 线程池学习总结</a></h1><h2 id="二-Executor-框架"><a href="#二-Executor-框架" class="headerlink" title="二 Executor 框架"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=%E4%BA%8C-executor-%E6%A1%86%E6%9E%B6">二 Executor 框架</a></h2><h3 id="2-2-Executor-框架结构-主要由三大部分组成"><a href="#2-2-Executor-框架结构-主要由三大部分组成" class="headerlink" title="2.2 Executor 框架结构(主要由三大部分组成)"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_22-executor-%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84%E4%B8%BB%E8%A6%81%E7%94%B1%E4%B8%89%E5%A4%A7%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90">2.2 Executor 框架结构(主要由三大部分组成)</a></h3><h4 id="1-任务-Runnable-Callable"><a href="#1-任务-Runnable-Callable" class="headerlink" title="1) 任务(Runnable &#x2F;Callable)"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_1-%E4%BB%BB%E5%8A%A1runnable-callable">1) 任务(<code>Runnable</code> &#x2F;<code>Callable</code>)</a></h4><h4 id="2-任务的执行-Executor"><a href="#2-任务的执行-Executor" class="headerlink" title="2) 任务的执行(Executor)"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_2-%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8Cexecutor">2) 任务的执行(<code>Executor</code>)</a></h4><p>如下图所示，包括任务执行机制的核心接口 <strong><code>Executor</code></strong> ，以及继承自 <code>Executor</code> 接口的 <strong><code>ExecutorService</code> 接口。<code>ThreadPoolExecutor</code></strong> 和 <strong><code>ScheduledThreadPoolExecutor</code></strong> 这两个关键类实现了 <strong>ExecutorService 接口</strong>。</p><p><strong>这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 <code>ThreadPoolExecutor</code> 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。</strong></p><blockquote><p><strong>注意：</strong> 通过查看 <code>ScheduledThreadPoolExecutor</code> 源代码我们发现 <code>ScheduledThreadPoolExecutor</code> 实际上是继承了 <code>ThreadPoolExecutor</code> 并实现了 ScheduledExecutorService ，而 <code>ScheduledExecutorService</code> 又实现了 <code>ExecutorService</code>，正如我们下面给出的类关系图显示的一样。</p></blockquote><p><img src="/img/OIP-C.jpg" data-original="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3.png" alt="任务的执行相关接口"></p><h4 id="3-异步计算的结果-Future"><a href="#3-异步计算的结果-Future" class="headerlink" title="3) 异步计算的结果(Future)"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_3-%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97%E7%9A%84%E7%BB%93%E6%9E%9Cfuture">3) 异步计算的结果(<code>Future</code>)</a></h4><h3 id="2-3-Executor-框架的使用示意图"><a href="#2-3-Executor-框架的使用示意图" class="headerlink" title="2.3 Executor 框架的使用示意图"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_23-executor-%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE">2.3 Executor 框架的使用示意图</a></h3><p><img src="/img/OIP-C.jpg" data-original="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Executor 框架的使用示意图"></p><ol><li><strong>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</strong></li><li><strong>把创建完成的实现 <code>Runnable</code>&#x2F;<code>Callable</code>接口的 对象直接交给 <code>ExecutorService</code> 执行</strong>: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable &lt;T&gt; task）</code>）。</li><li><strong>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现<code>Future</code>接口的对象</strong>（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask 对象）。由于 FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li><li><strong>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</strong></li></ol><h2 id="四-重要-ThreadPoolExecutor-使用示例"><a href="#四-重要-ThreadPoolExecutor-使用示例" class="headerlink" title="四 (重要)ThreadPoolExecutor 使用示例"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=%E5%9B%9B-%E9%87%8D%E8%A6%81threadpoolexecutor-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">四 (重要)ThreadPoolExecutor 使用示例</a></h2><h3 id="4-3-几个常见的对比"><a href="#4-3-几个常见的对比" class="headerlink" title="4.3 几个常见的对比"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_43-%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AF%B9%E6%AF%94">4.3 几个常见的对比</a></h3><h4 id="4-3-1-Runnable-vs-Callable"><a href="#4-3-1-Runnable-vs-Callable" class="headerlink" title="4.3.1 Runnable vs Callable"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_431-runnable-vs-callable">4.3.1 <code>Runnable</code> vs <code>Callable</code></a></h4><p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。**<code>Runnable</code> 接口<strong>不会返回结果或抛出检查异常，但是</strong><code>Callable</code> 接口<strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 **<code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。</p><p>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。（<code>Executors.callable（Runnable task</code>）或 <code>Executors.callable（Runnable task，Object resule）</code>）。</p><h4 id="4-3-2-execute-vs-submit"><a href="#4-3-2-execute-vs-submit" class="headerlink" title="4.3.2 execute() vs submit()"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_432-execute-vs-submit">4.3.2 <code>execute()</code> vs <code>submit()</code></a></h4><ol><li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li><li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><p>我们以**<code>AbstractExecutorService</code>**接口中的一个 <code>submit</code> 方法为例子来看看源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看看<code>execute()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-shutdown-VSshutdownNow"><a href="#4-3-3-shutdown-VSshutdownNow" class="headerlink" title="4.3.3 shutdown()VSshutdownNow()"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_433-shutdownvsshutdownnow">4.3.3 <code>shutdown()</code>VS<code>shutdownNow()</code></a></h4><ul><li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h4 id="4-3-2-isTerminated-VS-isShutdown"><a href="#4-3-2-isTerminated-VS-isShutdown" class="headerlink" title="4.3.2 isTerminated() VS isShutdown()"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_432-isterminated-vs-isshutdown">4.3.2 <code>isTerminated()</code> VS <code>isShutdown()</code></a></h4><ul><li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li></ul><h2 id="五-几种常见的线程池详解"><a href="#五-几种常见的线程池详解" class="headerlink" title="五 几种常见的线程池详解"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=%E4%BA%94-%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3">五 几种常见的线程池详解</a></h2><h3 id="5-1-FixedThreadPool"><a href="#5-1-FixedThreadPool" class="headerlink" title="5.1 FixedThreadPool"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_51-fixedthreadpool">5.1 FixedThreadPool</a></h3><h4 id="5-1-3-为什么不推荐使用FixedThreadPool？"><a href="#5-1-3-为什么不推荐使用FixedThreadPool？" class="headerlink" title="5.1.3 为什么不推荐使用FixedThreadPool？"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_513-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8fixedthreadpool%EF%BC%9F">5.1.3 为什么不推荐使用<code>FixedThreadPool</code>？</a></h4><p><strong><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 Intger.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响 ：</strong></p><ol><li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize；</li><li>由于使用无界队列时 <code>maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 <code>FixedThreadPool</code>的源码可以看出创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 被设置为同一个值。</li><li>由于 1 和 2，使用无界队列时 <code>keepAliveTime</code> 将是一个无效参数；</li><li>运行中的 <code>FixedThreadPool</code>（未执行 <code>shutdown()</code>或 <code>shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。</li></ol><h3 id="5-2-SingleThreadExecutor-详解"><a href="#5-2-SingleThreadExecutor-详解" class="headerlink" title="5.2 SingleThreadExecutor 详解"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_52-singlethreadexecutor-%E8%AF%A6%E8%A7%A3">5.2 SingleThreadExecutor 详解</a></h3><h4 id="5-2-1-介绍"><a href="#5-2-1-介绍" class="headerlink" title="5.2.1 介绍"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_521-%E4%BB%8B%E7%BB%8D">5.2.1 介绍</a></h4><p><code>SingleThreadExecutor</code> 是只有一个线程的线程池。下面看看<strong>SingleThreadExecutor 的实现：</strong>从上面源代码可以看出新创建的 <code>SingleThreadExecutor</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 1.其他参数和 <code>FixedThreadPool</code> 相同。</p><h4 id="5-2-3-为什么不推荐使用SingleThreadExecutor？"><a href="#5-2-3-为什么不推荐使用SingleThreadExecutor？" class="headerlink" title="5.2.3 为什么不推荐使用SingleThreadExecutor？"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_523-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8singlethreadexecutor%EF%BC%9F">5.2.3 为什么不推荐使用<code>SingleThreadExecutor</code>？</a></h4><p><code>SingleThreadExecutor</code> 使用无界队列 <code>LinkedBlockingQueue</code> 作为线程池的工作队列（队列的容量为 Intger.MAX_VALUE）。<code>SingleThreadExecutor</code> 使用无界队列作为线程池的工作队列会对线程池带来的影响与 <code>FixedThreadPool</code> 相同。说简单点就是可能会导致 OOM，</p><h3 id="5-3-CachedThreadPool-详解"><a href="#5-3-CachedThreadPool-详解" class="headerlink" title="5.3 CachedThreadPool 详解"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_53-cachedthreadpool-%E8%AF%A6%E8%A7%A3">5.3 CachedThreadPool 详解</a></h3><h4 id="5-3-2-执行任务过程介绍"><a href="#5-3-2-执行任务过程介绍" class="headerlink" title="5.3.2 执行任务过程介绍"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_532-%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D">5.3.2 执行任务过程介绍</a></h4><p><strong>CachedThreadPool 的 execute()方法的执行示意图（该图片来源：《Java 并发编程的艺术》）：</strong> <img src="/img/OIP-C.jpg" data-original="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/CachedThreadPool-execute.png" alt="CachedThreadPool的execute()方法的执行示意图"></p><p><strong>上图说明：</strong></p><ol><li>首先执行 <code>SynchronousQueue.offer(Runnable task)</code> 提交任务到任务队列。如果当前 <code>maximumPool</code> 中有闲线程正在执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>，那么主线程执行 offer 操作与空闲线程执行的 <code>poll</code> 操作配对成功，主线程把任务交给空闲线程执行，<code>execute()</code>方法执行完成，否则执行下面的步骤 2；</li><li>当初始 <code>maximumPool</code> 为空，或者 <code>maximumPool</code> 中没有空闲线程时，将没有线程执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>。这种情况下，步骤 1 将失败，此时 <code>CachedThreadPool</code> 会创建新线程执行任务，execute 方法执行完成；</li></ol><h4 id="5-3-3-为什么不推荐使用CachedThreadPool？"><a href="#5-3-3-为什么不推荐使用CachedThreadPool？" class="headerlink" title="5.3.3 为什么不推荐使用CachedThreadPool？"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_533-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8cachedthreadpool%EF%BC%9F">5.3.3 为什么不推荐使用<code>CachedThreadPool</code>？</a></h4><p><code>CachedThreadPool</code> 的<code>corePoolSize</code> 被设置为空（0），<code>maximumPoolSize</code>被设置为 Integer.MAX.VALUE，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p><p><code>CachedThreadPool</code>允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</p><h2 id="六-ScheduledThreadPoolExecutor-详解"><a href="#六-ScheduledThreadPoolExecutor-详解" class="headerlink" title="六 ScheduledThreadPoolExecutor 详解"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=%E5%85%AD-scheduledthreadpoolexecutor-%E8%AF%A6%E8%A7%A3">六 ScheduledThreadPoolExecutor 详解</a></h2><h3 id="6-2-运行机制"><a href="#6-2-运行机制" class="headerlink" title="6.2 运行机制"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_62-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">6.2 运行机制</a></h3><p><img src="/img/OIP-C.jpg" data-original="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/ScheduledThreadPoolExecutor%E6%9C%BA%E5%88%B6.png" alt="ScheduledThreadPoolExecutor运行机制"></p><p><strong><code>ScheduledThreadPoolExecutor</code> 的执行主要分为两大部分：</strong></p><ol><li>当调用 <code>ScheduledThreadPoolExecutor</code> 的 <strong><code>scheduleAtFixedRate()</code></strong> 方法或者**<code>scheduleWirhFixedDelay()</code>** 方法时，会向 <code>ScheduledThreadPoolExecutor</code> 的 <strong><code>DelayQueue</code></strong> 添加一个实现了 <strong><code>RunnableScheduledFuture</code></strong> 接口的 <strong><code>ScheduledFutureTask</code></strong> 。</li><li>线程池中的线程从 <code>DelayQueue</code> 中获取 <code>ScheduledFutureTask</code>，然后执行任务。</li></ol><p><strong><code>ScheduledThreadPoolExecutor</code> 为了实现周期性的执行任务，对 <code>ThreadPoolExecutor</code>做了如下修改：</strong></p><ul><li>使用 <strong><code>DelayQueue</code></strong> 作为任务队列；</li><li>获取任务的方不同</li><li>执行周期任务后，增加了额外的处理</li></ul><h3 id="6-3-ScheduledThreadPoolExecutor-执行周期任务的步骤"><a href="#6-3-ScheduledThreadPoolExecutor-执行周期任务的步骤" class="headerlink" title="6.3 ScheduledThreadPoolExecutor 执行周期任务的步骤"></a><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_63-scheduledthreadpoolexecutor-%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%AD%A5%E9%AA%A4">6.3 ScheduledThreadPoolExecutor 执行周期任务的步骤</a></h3><p><img src="/img/OIP-C.jpg" data-original="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/ScheduledThreadPoolExecutor%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1%E6%AD%A5%E9%AA%A4.png" alt="ScheduledThreadPoolExecutor执行周期任务的步骤"></p><ol><li>线程 1 从 <code>DelayQueue</code> 中获取已到期的 <code>ScheduledFutureTask（DelayQueue.take()）</code>。到期任务是指 <code>ScheduledFutureTask</code>的 time 大于等于当前系统的时间；</li><li>线程 1 执行这个 <code>ScheduledFutureTask</code>；</li><li>线程 1 修改 <code>ScheduledFutureTask</code> 的 time 变量为下次将要被执行的时间；</li><li>线程 1 把这个修改 time 之后的 <code>ScheduledFutureTask</code> 放回 <code>DelayQueue</code> 中（<code>DelayQueue.add()</code>)。</li></ol><h1 id="一些面试问题"><a href="#一些面试问题" class="headerlink" title="一些面试问题"></a>一些面试问题</h1><ol start="2"><li><p>Synchronized 优化内容？和一些结构？</p><ol><li>只有一个线程的加锁时候才使用偏向锁，当另一个线程来加锁的时候就算前一个加锁的线程已经释放了锁也会升级成轻量级锁；轻量级是在各个线程轮流加锁的时候使用的，不存在锁竞争即不存在线程阻塞等待；继续升级为重量级锁</li><li>记住3个结构：锁记录，markword，monitor</li></ol></li><li><p>三个特性，volatile和sychronized的区别，volatile的原理，happen before ? 如何实现单例？</p><ol start="2"><li><p>volatile的原理：<a href="https://zhuanlan.zhihu.com/p/133851347">https://zhuanlan.zhihu.com/p/133851347</a>   <a href="https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg">https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg</a></p><ol><li><img src="/img/OIP-C.jpg" data-original="/assets/image-20210328095021207.png" alt="image-20210328095021207"></li></ol></li><li><p>jvm内存模型：MM中规定所有的变量都存储在主内存（Main Memory）中，每条线程都有自己的工作内存（Work  Memory），线程的工作内存中保存了该线程所使用的变量的从主内存中拷贝的副本。线程对于变量的读、写都必须在工作内存中进行，而不能直接读、写主内存中的变量。同时，本线程的工作内存的变量也无法被其他线程直接访问，必须通过主内存完成。</p><ol><li>MESI（缓存一致性协议）一致性协议：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取</li><li>每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里</li><li>由于Volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和cas不断循环，无效交互会导致总线带宽达到峰值</li></ol></li><li><p>java内存模型定义了一些规则来禁止cpu缓存和编译器优化，happen-before用来描述两个操作的内存的可见性，有以下6条： <a href="https://mp.weixin.qq.com/s/3o-zKBcm44BFRfy-CBL3Bg">地址</a></p><p>1.程序的顺序执行，前一个语句对后一个语句可见 （当两个语句没有依赖的情况下还是可以乱序执行）<br>2.volatile变量的写对另一个线程的读可见<br>3.happen-before 具有传递性<br>4.一个线程对锁的释放对另外一个线程的获取锁可见 （也就是一个线程在释放锁之前对共享变量的操作，另外一个线程获取锁后会看的到）<br>5.线程a调用了线程b的start()方法，那么线程a在调用start方法之前的操作，对线程b内的run()方法可见<br>6.线程a调用了线程b的join方法，那么线程b里的所有操作，将对线程a调用join之后的操作可见。</p></li></ol></li><li><p>知道哪些 CAS 的锁？CAS 的缺点？CAS的原理？</p><ol><li><p>记住四种原子类，1.原子整形和原子引用  2.原子数组和原子字段更新器</p><ol><li><p><strong>基本类型</strong> </p><p>使用原子的方式更新基本类型</p><ul><li>AtomicInteger：整型原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul><p><strong>数组类型</strong></p><p>使用原子的方式更新数组里的某个元素</p><ul><li>AtomicIntegerArray：整型数组原子类</li><li>AtomicLongArray：长整型数组原子类</li><li>AtomicReferenceArray ：引用类型数组原子类</li></ul><p><strong>引用类型</strong></p><ul><li>AtomicReference：引用类型原子类</li><li>AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，<del>也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</del></li><li>AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li></ul><p><strong>对象的属性修改类型</strong></p><ul><li>AtomicIntegerFieldUpdater:原子更新整型字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整型字段的更新器</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</li></ul></li></ol></li><li><p>两个缺点：1.消耗资源  2.aba问题</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line">         </span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line">         </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure><p>原理：AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升</p><p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset()  方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。另外 value 是一个volatile变量，在内存中可见，因此 JVM  可以保证任何时刻任何线程总能拿到该变量的最新值</p></li></ol></li><li><p>线程池了解吗？  1.线程创建规则 （小于核心线程数的时候直接创建不考虑有没有空闲进程；大于核心线程数直接放队列而不用管有没有空闲进程；队列满了直接创建急救线程而不管有没有空闲进程）  2.资源回收  3.排队策略  4.拒绝策略</p><ol><li>拒绝策略<ol><li>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。</li><li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li>ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。</li><li>ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。</li></ol></li></ol></li><li><p>默认的一些线程池和线程池的构造参数如何确定？</p><ol><li>默认线程池<ol><li>FixedThreadPool  nThreads, nThreads   new LinkedBlockingQueue<Runnable>()</li><li>SingleThreadExecutor  1, 1,    new LinkedBlockingQueue<Runnable>()</li><li>CachedThreadPool   0, Integer.MAX_VALUE   new SynchronousQueue<Runnable>()</li></ol></li><li>构造参数如何确定<ol><li><a href="https://mp.weixin.qq.com/s/YbyC3qQfUm4B_QQ03GFiNw">https://mp.weixin.qq.com/s/YbyC3qQfUm4B_QQ03GFiNw</a></li><li><a href="https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww">https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww</a></li></ol></li></ol></li><li><p>线程池的源码？</p><ol><li>ThreadPoolExecutor的submit中调用execute方法，发生了线程创建的那3步—–调用addWorker()方法</li><li>ThreadPoolExecutor的addWorker()方法，新建Worker对象，然后是添加到workers集合中—-调用Worker的start方法</li><li>ThreadPoolExecutor.Worker实现了Runnable接口，run()方法中调用runWorker()——runWorker()，执行firstTask 然后getTask()继续执行</li><li>1.Worker实现了AbstractQueuedSynchronizer接口，执行任务的时候会加锁    2.添加到workers集合这个步骤也会使用ReentrantLock加锁</li></ol></li><li><p>AQS</p><ol><li><p>原理：在 AQS 内部，通过维护一个<code>FIFO 队列</code>来管理多线程的排队工作。在公平竞争的情况下，无法获取同步状态的线程将会被封装成一个节点，置于队列尾部。入队的线程将会通过自旋的方式获取同步状态，若在有限次的尝试后，仍未获取成功，线程则会被阻塞住。大致示意图如下：</p><p><img src="/img/OIP-C.jpg" data-original="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15246643802592.jpg" alt="img"></p><p>当头结点释放同步状态后，且后继节点对应的线程被阻塞，此时头结点</p><p>线程将会去唤醒后继节点线程。后继节点线程恢复运行并获取同步状态后，会将旧的头结点从队列中移除，并将自己设为头结点。大致示意图如下：</p><p><img src="/img/OIP-C.jpg" data-original="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15246656604985.jpg" alt="img"></p></li><li><p>自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS 已经在上层已经帮我们实现好了</p></li></ol></li><li><p>CountDownLatch以及CyclicBarrier以及CyclicBarrier？</p><ol><li>Semaphore(信号量)-  semaphore.acquire();&#x2F;&#x2F; 获取一个许可  semaphore.release();&#x2F;&#x2F; 释放一个许可<ol><li>允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li></ol></li><li>CountDownLatch（倒计时器）：主线程调用 await() 进行阻塞，子线程调用 CountDownLatch.countDown() 修改state的值<ol><li>CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li></ol></li><li>CyclicBarrier(循环栅栏)：new CyclicBarrier(n)，子线程在调用CyclicBarrier的await()方法之后进行阻塞，多个子线程共调用n次await()放开阻塞子线程继续，如此循环<ol><li>CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li></ol></li></ol></li><li><p>ReentrantLock和synchronized的区别？</p></li><li><p>等待可中断 : ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</p></li><li><p>可实现公平锁 : ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。</p></li><li><p>可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。</p></li><li><p>ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），synchronized 是依赖于 JVM 实现的</p></li><li><p>CyclicBarrier 和 CountDownLatch 的区别？</p><ol><li>对于 CountDownLatch 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</li><li>CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</li></ol></li><li><p>说说 sleep() 方法和 wait() 方法区别和共同点? 1.两者最主要的区别在于：sleep() 方法没有释放锁，而 wait() 方法释放了锁 。2.wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。</p></li><li><p><a href="https://blog.csdn.net/zheng199172/article/details/88800275">什么是协程</a></p></li><li></li><li><p>AQS源码：</p><ol><li>加锁：acquire()</li><li>acquire方法的 acquireQueued() 逻辑<ol><li>acquireQueued() 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li><li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire() 尝试获取锁</li><li>进入 shouldParkAfterFailedAcquire() 逻辑，如果 shouldParkAfterFailedAcquire() 返回 true  继续进入 parkAndCheckInterrupt() 逻辑</li></ol></li><li>shouldParkAfterFailedAcquire() 逻辑<br>  1. **上一个节点都在阻塞(ws &#x3D;&#x3D; Node.SIGNAL)**， 那么自己也阻塞好了，返回true<br>  2. 上一个节点取消(ws &gt; 0)，那么重构删除前面所有取消的节点，返回false<br>  3. <strong>上一个节点其他状态，设置上一个节点状态为 Node.SIGNAL</strong>，也返回false</li><li>parkAndCheckInterrupt() 逻辑<br>  1. LockSupport.park(this);<br>  2. return Thread.interrupted();</li><li>解锁：release()<ol><li><p>调用unlock()方法里的release()方法中的tryRelease()释放锁，如果成功，设置 exclusiveOwnerThread 为 null</p></li><li><p>unlock方法里的release方法方法中，如果当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor() 逻辑：</p></li><li><p>unparkSuccessor() 逻辑</p><ol><li><strong>将头结点状态设置为0</strong></li><li>unpark 恢复其运行</li></ol></li><li><p>如果Thread-1加锁成功（没有竞争），会设置  （acquireQueued 方法中）</p><ol><li>exclusiveOwnerThread 为 Thread-1，state &#x3D; 1</li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li><li>原本的 head 因为从链表断开，而可被垃圾回收</li></ol></li></ol></li></ol></li><li><p>AQS 各种实现原理</p><ol><li>公平锁实现原理</li><li>可打断实现原理</li><li>条件变量实现原理</li></ol></li><li><p>Condition原理</p><ol><li>awaitUninterruptibly()—不可打断等待 - 直到被唤醒<ol><li>addConditionWaiter()，创建一个关联当前线程的新 Node，<strong>状态为-2</strong>， 添加至队列尾部</li><li>fullyRelease(node)，释放节点持有的锁  </li><li>!isOnSyncQueue(node)，如果该节点还没有转移至 AQS 队列, 阻塞 LockSupport.park(this);</li><li>acquireQueued(node, savedState)  唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列</li></ol></li><li>唤醒：<ol><li>signal()调用doSignal(first)再调用transferForSignal(first);</li><li>transferForSignal(Node node) 将等待队列中的 Node 转移至 AQS 队列<ol><li><strong>设置当前node状态为0（因为处在队列末尾）</strong></li><li>Node p &#x3D; enq(node)  加入 AQS 队列尾部</li><li><strong>插入节点的上一个节点设置状态为 Node.SIGNAL</strong></li></ol></li></ol></li></ol></li><li><p>ReentrantReadWriteLock</p><ol><li>读锁不支持条件变量</li><li>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</li><li>重入时降级支持：即持有写锁的情况下去获取读锁</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-并发进阶常见面试题总结&quot;&gt;&lt;a href=&quot;#Java-并发进阶常见面试题总结&quot; class=&quot;headerlink&quot; title=&quot;Java 并发进阶常见面试题总结&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://snailclimb.gitee.io/j</summary>
      
    
    
    
    <category term="面试题" scheme="http://www.sion-io.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="http://www.sion-io.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>微服务-面试题</title>
    <link href="http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://www.sion-io.cn/2024/05/12/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2024-05-12T08:26:29.962Z</published>
    <updated>2024-05-12T10:11:14.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h1 id="1-微服务篇"><a href="#1-微服务篇" class="headerlink" title="1.微服务篇"></a>1.微服务篇</h1><h2 id="1-1-SpringCloud常见组件有哪些？"><a href="#1-1-SpringCloud常见组件有哪些？" class="headerlink" title="1.1.SpringCloud常见组件有哪些？"></a>1.1.SpringCloud常见组件有哪些？</h2><p><strong>问题说明</strong>：这个题目主要考察对SpringCloud的组件基本了解</p><p><strong>难易程度</strong>：简单</p><p><strong>参考话术</strong>：</p><p>SpringCloud包含的组件很多，有很多功能是重复的。其中最常用组件包括：</p><p>•注册中心组件：Eureka、Nacos等</p><p>•负载均衡组件：Ribbon</p><p>•远程调用组件：OpenFeign</p><p>•网关组件：Zuul、Gateway</p><p>•服务保护组件：Hystrix、Sentinel</p><p>•服务配置管理组件：SpringCloudConfig、Nacos</p><h2 id="1-2-Nacos的服务注册表结构是怎样的？"><a href="#1-2-Nacos的服务注册表结构是怎样的？" class="headerlink" title="1.2.Nacos的服务注册表结构是怎样的？"></a>1.2.Nacos的服务注册表结构是怎样的？</h2><p><strong>问题说明</strong>：考察对Nacos数据分级结构的了解，以及Nacos源码的掌握情况</p><p><strong>难易程度</strong>：一般</p><p><strong>参考话术</strong>：</p><p>Nacos采用了数据的分级存储模型，最外层是Namespace，用来隔离环境。然后是Group，用来对服务分组。接下来就是服务（Service）了，一个服务包含多个实例，但是可能处于不同机房，因此Service下有多个集群（Cluster），Cluster下是不同的实例（Instance）。</p><p>对应到Java代码中，Nacos采用了一个多层的Map来表示。结构为Map&lt;String, Map&lt;String, Service&gt;&gt;，其中最外层Map的key就是namespaceId，值是一个Map。内层Map的key是group拼接serviceName，值是Service对象。Service对象内部又是一个Map，key是集群名称，值是Cluster对象。而Cluster对象内部维护了Instance的集合。</p><p>如图：</p><p><img src="/img/OIP-C.jpg" data-original="/../assets/image-20210925215305446.png" alt="image-20210925215305446"></p><h2 id="1-3-Nacos如何支撑阿里内部数十万服务注册压力？"><a href="#1-3-Nacos如何支撑阿里内部数十万服务注册压力？" class="headerlink" title="1.3.Nacos如何支撑阿里内部数十万服务注册压力？"></a>1.3.Nacos如何支撑阿里内部数十万服务注册压力？</h2><p><strong>问题说明</strong>：考察对Nacos源码的掌握情况</p><p><strong>难易程度</strong>：难</p><p><strong>参考话术</strong>：</p><p>Nacos内部接收到注册的请求时，不会立即写数据，而是将服务注册的任务放入一个阻塞队列就立即响应给客户端。然后利用线程池读取阻塞队列中的任务，异步来完成实例更新，从而提高并发写能力。</p><h2 id="1-4-Nacos如何避免并发读写冲突问题？"><a href="#1-4-Nacos如何避免并发读写冲突问题？" class="headerlink" title="1.4.Nacos如何避免并发读写冲突问题？"></a>1.4.Nacos如何避免并发读写冲突问题？</h2><p><strong>问题说明</strong>：考察对Nacos源码的掌握情况</p><p><strong>难易程度</strong>：难</p><p><strong>参考话术</strong>：</p><p>Nacos在更新实例列表时，会采用CopyOnWrite技术，首先将旧的实例列表拷贝一份，然后更新拷贝的实例列表，再用更新后的实例列表来覆盖旧的实例列表。</p><p>这样在更新的过程中，就不会对读实例列表的请求产生影响，也不会出现脏读问题了。</p><h2 id="1-5-Nacos与Eureka的区别有哪些？"><a href="#1-5-Nacos与Eureka的区别有哪些？" class="headerlink" title="1.5.Nacos与Eureka的区别有哪些？"></a>1.5.Nacos与Eureka的区别有哪些？</h2><p><strong>问题说明</strong>：考察对Nacos、Eureka的底层实现的掌握情况</p><p><strong>难易程度</strong>：难</p><p><strong>参考话术</strong>：</p><p>Nacos与Eureka有相同点，也有不同之处，可以从以下几点来描述：</p><ul><li><strong>接口方式</strong>：Nacos与Eureka都对外暴露了Rest风格的API接口，用来实现服务注册、发现等功能</li><li><strong>实例类型</strong>：Nacos的实例有永久和临时实例之分；而Eureka只支持临时实例</li><li><strong>健康检测</strong>：Nacos对临时实例采用心跳模式检测，对永久实例采用主动请求来检测；Eureka只支持心跳模式</li><li><strong>服务发现</strong>：Nacos支持定时拉取和订阅推送两种模式；Eureka只支持定时拉取模式</li></ul><h2 id="1-6-Sentinel的限流与Gateway的限流有什么差别？"><a href="#1-6-Sentinel的限流与Gateway的限流有什么差别？" class="headerlink" title="1.6.Sentinel的限流与Gateway的限流有什么差别？"></a>1.6.Sentinel的限流与Gateway的限流有什么差别？</h2><p><strong>问题说明</strong>：考察对限流算法的掌握情况</p><p><strong>难易程度</strong>：难</p><p><strong>参考话术</strong>：</p><p>限流算法常见的有三种实现：滑动时间窗口、令牌桶算法、漏桶算法。Gateway则采用了基于Redis实现的令牌桶算法。</p><p>而Sentinel内部却比较复杂：</p><ul><li>默认限流模式是基于滑动时间窗口算法</li><li>排队等待的限流模式则基于漏桶算法</li><li>而热点参数限流则是基于令牌桶算法</li></ul><h2 id="1-7-Sentinel的线程隔离与Hystix的线程隔离有什么差别"><a href="#1-7-Sentinel的线程隔离与Hystix的线程隔离有什么差别" class="headerlink" title="1.7.Sentinel的线程隔离与Hystix的线程隔离有什么差别?"></a>1.7.Sentinel的线程隔离与Hystix的线程隔离有什么差别?</h2><p><strong>问题说明</strong>：考察对线程隔离方案的掌握情况</p><p><strong>难易程度</strong>：一般</p><p><strong>参考话术</strong>：</p><p>Hystix默认是基于线程池实现的线程隔离，每一个被隔离的业务都要创建一个独立的线程池，线程过多会带来额外的CPU开销，性能一般，但是隔离性更强。</p><p>Sentinel是基于信号量（计数器）实现的线程隔离，不用创建线程池，性能较好，但是隔离性一般。</p><h1 id="2-MQ篇"><a href="#2-MQ篇" class="headerlink" title="2.MQ篇"></a>2.MQ篇</h1><h2 id="2-1-你们为什么选择了RabbitMQ而不是其它的MQ？"><a href="#2-1-你们为什么选择了RabbitMQ而不是其它的MQ？" class="headerlink" title="2.1.你们为什么选择了RabbitMQ而不是其它的MQ？"></a>2.1.你们为什么选择了RabbitMQ而不是其它的MQ？</h2><p>如图：</p><p><img src="/img/OIP-C.jpg" data-original="/../assets/image-20210925220034702.png" alt="image-20210925220034702"></p><p><strong>话术：</strong></p><p>kafka是以吞吐量高而闻名，不过其数据稳定性一般，而且无法保证消息有序性。我们公司的日志收集也有使用，业务模块中则使用的RabbitMQ。</p><p>阿里巴巴的RocketMQ基于Kafka的原理，弥补了Kafka的缺点，继承了其高吞吐的优势，其客户端目前以Java为主。但是我们担心阿里巴巴开源产品的稳定性，所以就没有使用。</p><p>RabbitMQ基于面向并发的语言Erlang开发，吞吐量不如Kafka，但是对我们公司来讲够用了。而且消息可靠性较好，并且消息延迟极低，集群搭建比较方便。支持多种协议，并且有各种语言的客户端，比较灵活。Spring对RabbitMQ的支持也比较好，使用起来比较方便，比较符合我们公司的需求。</p><p>综合考虑我们公司的并发需求以及稳定性需求，我们选择了RabbitMQ。</p><h2 id="2-2-RabbitMQ如何确保消息的不丢失？"><a href="#2-2-RabbitMQ如何确保消息的不丢失？" class="headerlink" title="2.2.RabbitMQ如何确保消息的不丢失？"></a>2.2.RabbitMQ如何确保消息的不丢失？</h2><p><strong>话术：</strong></p><p>RabbitMQ针对消息传递过程中可能发生问题的各个地方，给出了针对性的解决方案：</p><ul><li>生产者发送消息时可能因为网络问题导致消息没有到达交换机：<ul><li>RabbitMQ提供了publisher confirm机制<ul><li>生产者发送消息后，可以编写ConfirmCallback函数</li><li>消息成功到达交换机后，RabbitMQ会调用ConfirmCallback通知消息的发送者，返回ACK</li><li>消息如果未到达交换机，RabbitMQ也会调用ConfirmCallback通知消息的发送者，返回NACK</li><li>消息超时未发送成功也会抛出异常</li></ul></li></ul></li><li>消息到达交换机后，如果未能到达队列，也会导致消息丢失：<ul><li>RabbitMQ提供了publisher return机制<ul><li>生产者可以定义ReturnCallback函数</li><li>消息到达交换机，未到达队列，RabbitMQ会调用ReturnCallback通知发送者，告知失败原因</li></ul></li></ul></li><li>消息到达队列后，MQ宕机也可能导致丢失消息：<ul><li>RabbitMQ提供了持久化功能，集群的主从备份功能<ul><li>消息持久化，RabbitMQ会将交换机、队列、消息持久化到磁盘，宕机重启可以恢复消息</li><li>镜像集群，仲裁队列，都可以提供主从备份功能，主节点宕机，从节点会自动切换为主，数据依然在</li></ul></li></ul></li><li>消息投递给消费者后，如果消费者处理不当，也可能导致消息丢失<ul><li>SpringAMQP基于RabbitMQ提供了消费者确认机制、消费者重试机制，消费者失败处理策略：<ul><li>消费者的确认机制：<ul><li>消费者处理消息成功，未出现异常时，Spring返回ACK给RabbitMQ，消息才被移除</li><li>消费者处理消息失败，抛出异常，宕机，Spring返回NACK或者不返回结果，消息不被异常</li></ul></li><li>消费者重试机制：<ul><li>默认情况下，消费者处理失败时，消息会再次回到MQ队列，然后投递给其它消费者。Spring提供的消费者重试机制，则是在处理失败后不返回NACK，而是直接在消费者本地重试。多次重试都失败后，则按照消费者失败处理策略来处理消息。避免了消息频繁入队带来的额外压力。</li></ul></li><li>消费者失败策略：<ul><li>当消费者多次本地重试失败时，消息默认会丢弃。</li><li>Spring提供了Republish策略，在多次重试都失败，耗尽重试次数后，将消息重新投递给指定的异常交换机，并且会携带上异常栈信息，帮助定位问题。</li></ul></li></ul></li></ul></li></ul><h2 id="2-3-RabbitMQ如何避免消息堆积？"><a href="#2-3-RabbitMQ如何避免消息堆积？" class="headerlink" title="2.3.RabbitMQ如何避免消息堆积？"></a>2.3.RabbitMQ如何避免消息堆积？</h2><p><strong>话术：</strong></p><p>消息堆积问题产生的原因往往是因为消息发送的速度超过了消费者消息处理的速度。因此解决方案无外乎以下三点：</p><ul><li>提高消费者处理速度</li><li>增加更多消费者</li><li>增加队列消息存储上限</li></ul><p>1）提高消费者处理速度</p><p>消费者处理速度是由业务代码决定的，所以我们能做的事情包括：</p><ul><li>尽可能优化业务代码，提高业务性能</li><li>接收到消息后，开启线程池，并发处理多个消息</li></ul><p>优点：成本低，改改代码即可</p><p>缺点：开启线程池会带来额外的性能开销，对于高频、低时延的任务不合适。推荐任务执行周期较长的业务。</p><p>2）增加更多消费者</p><p>一个队列绑定多个消费者，共同争抢任务，自然可以提供消息处理的速度。</p><p>优点：能用钱解决的问题都不是问题。实现简单粗暴</p><p>缺点：问题是没有钱。成本太高</p><p>3）增加队列消息存储上限</p><p>在RabbitMQ的1.8版本后，加入了新的队列模式：Lazy Queue</p><p>这种队列不会将消息保存在内存中，而是在收到消息后直接写入磁盘中，理论上没有存储上限。可以解决消息堆积问题。</p><p>优点：磁盘存储更安全；存储无上限；避免内存存储带来的Page Out问题，性能更稳定；</p><p>缺点：磁盘存储受到IO性能的限制，消息时效性不如内存模式，但影响不大。</p><h2 id="2-4-RabbitMQ如何保证消息的有序性？"><a href="#2-4-RabbitMQ如何保证消息的有序性？" class="headerlink" title="2.4.RabbitMQ如何保证消息的有序性？"></a>2.4.RabbitMQ如何保证消息的有序性？</h2><p><strong>话术：</strong></p><p>其实RabbitMQ是队列存储，天然具备先进先出的特点，只要消息的发送是有序的，那么理论上接收也是有序的。不过当一个队列绑定了多个消费者时，可能出现消息轮询投递给消费者的情况，而消费者的处理顺序就无法保证了。</p><p>因此，要保证消息的有序性，需要做的下面几点：</p><ul><li>保证消息发送的有序性</li><li>保证一组有序的消息都发送到同一个队列</li><li>保证一个队列只包含一个消费者</li></ul><h2 id="2-5-如何防止MQ消息被重复消费？"><a href="#2-5-如何防止MQ消息被重复消费？" class="headerlink" title="2.5.如何防止MQ消息被重复消费？"></a>2.5.如何防止MQ消息被重复消费？</h2><p><strong>话术：</strong></p><p>消息重复消费的原因多种多样，不可避免。所以只能从消费者端入手，只要能保证消息处理的幂等性就可以确保消息不被重复消费。</p><p>而幂等性的保证又有很多方案：</p><ul><li>给每一条消息都添加一个唯一id，在本地记录消息表及消息状态，处理消息时基于数据库表的id唯一性做判断</li><li>同样是记录消息表，利用消息状态字段实现基于乐观锁的判断，保证幂等</li><li>基于业务本身的幂等性。比如根据id的删除、查询业务天生幂等；新增、修改等业务可以考虑基于数据库id唯一性、或者乐观锁机制确保幂等。本质与消息表方案类似。</li></ul><h2 id="2-6-如何保证RabbitMQ的高可用？"><a href="#2-6-如何保证RabbitMQ的高可用？" class="headerlink" title="2.6.如何保证RabbitMQ的高可用？"></a>2.6.如何保证RabbitMQ的高可用？</h2><p><strong>话术：</strong></p><p>要实现RabbitMQ的高可用无外乎下面两点：</p><ul><li>做好交换机、队列、消息的持久化</li><li>搭建RabbitMQ的镜像集群，做好主从备份。当然也可以使用仲裁队列代替镜像集群。</li></ul><h2 id="2-7-使用MQ可以解决那些问题？"><a href="#2-7-使用MQ可以解决那些问题？" class="headerlink" title="2.7.使用MQ可以解决那些问题？"></a>2.7.使用MQ可以解决那些问题？</h2><p><strong>话术：</strong></p><p>RabbitMQ能解决的问题很多，例如：</p><ul><li>解耦合：将几个业务关联的微服务调用修改为基于MQ的异步通知，可以解除微服务之间的业务耦合。同时还提高了业务性能。</li><li>流量削峰：将突发的业务请求放入MQ中，作为缓冲区。后端的业务根据自己的处理能力从MQ中获取消息，逐个处理任务。流量曲线变的平滑很多</li><li>延迟队列：基于RabbitMQ的死信队列或者DelayExchange插件，可以实现消息发送后，延迟接收的效果。</li></ul><h1 id="3-Redis篇"><a href="#3-Redis篇" class="headerlink" title="3.Redis篇"></a>3.Redis篇</h1><h2 id="3-1-Redis与Memcache的区别？"><a href="#3-1-Redis与Memcache的区别？" class="headerlink" title="3.1.Redis与Memcache的区别？"></a>3.1.Redis与Memcache的区别？</h2><ul><li><code>redis支持更丰富的数据类型</code>（支持更复杂的应用场景）：Redis不仅仅支持简单的k&#x2F;v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li><li><code>Redis支持数据的持久化</code>，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</li><li><code>集群模式</code>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li><li><code>Redis使用单线程</code>：Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</li></ul><p><img src="/img/OIP-C.jpg" data-original="/../assets/1574821356723.png" alt="1574821356723"></p><h2 id="3-2-Redis的单线程问题"><a href="#3-2-Redis的单线程问题" class="headerlink" title="3.2.Redis的单线程问题"></a>3.2.Redis的单线程问题</h2><p><strong>面试官</strong>：Redis采用单线程，如何保证高并发？</p><p><strong>面试话术</strong>：</p><p>Redis快的主要原因是：</p><ol><li>完全基于内存</li><li>数据结构简单，对数据操作也简单</li><li>使用多路 I&#x2F;O 复用模型，充分利用CPU资源</li></ol><p><strong>面试官</strong>：这样做的好处是什么？</p><p><strong>面试话术</strong>：</p><p>单线程优势有下面几点：</p><ul><li>代码更清晰，处理逻辑更简单</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为锁而导致的性能消耗</li><li>不存在多进程或者多线程导致的CPU切换，充分利用CPU资源</li></ul><h2 id="3-2-Redis的持久化方案由哪些？"><a href="#3-2-Redis的持久化方案由哪些？" class="headerlink" title="3.2.Redis的持久化方案由哪些？"></a>3.2.Redis的持久化方案由哪些？</h2><p><strong>相关资料：</strong></p><p>1）RDB 持久化</p><p>RDB持久化可以使用save或bgsave，为了不阻塞主进程业务，一般都使用bgsave，流程：</p><ul><li>Redis 进程会 fork 出一个子进程（与父进程内存数据一致）。</li><li>父进程继续处理客户端请求命令</li><li>由子进程将内存中的所有数据写入到一个临时的 RDB 文件中。</li><li>完成写入操作之后，旧的 RDB 文件会被新的 RDB 文件替换掉。</li></ul><p>下面是一些和 RDB 持久化相关的配置：</p><ul><li><code>save 60 10000</code>：如果在 60 秒内有 10000 个 key 发生改变，那就执行 RDB 持久化。</li><li><code>stop-writes-on-bgsave-error yes</code>：如果 Redis 执行 RDB 持久化失败（常见于操作系统内存不足），那么 Redis 将不再接受 client 写入数据的请求。</li><li><code>rdbcompression yes</code>：当生成 RDB 文件时，同时进行压缩。</li><li><code>dbfilename dump.rdb</code>：将 RDB 文件命名为 dump.rdb。</li><li><code>dir /var/lib/redis</code>：将 RDB 文件保存在<code>/var/lib/redis</code>目录下。</li></ul><p>　　当然在实践中，我们通常会将<code>stop-writes-on-bgsave-error</code>设置为<code>false</code>，同时让监控系统在 Redis 执行 RDB 持久化失败时发送告警，以便人工介入解决，而不是粗暴地拒绝 client 的写入请求。</p><p>RDB持久化的优点：</p><ul><li>RDB持久化文件小，Redis数据恢复时速度快</li><li>子进程不影响父进程，父进程可以持续处理客户端命令</li><li>子进程fork时采用copy-on-write方式，大多数情况下，没有太多的内存消耗，效率比较好。</li></ul><p> RDB 持久化的缺点：</p><ul><li>子进程fork时采用copy-on-write方式，如果Redis此时写操作较多，可能导致额外的内存占用，甚至内存溢出</li><li>RDB文件压缩会减小文件体积，但通过时会对CPU有额外的消耗</li><li>如果业务场景很看重数据的持久性 (durability)，那么不应该采用 RDB 持久化。譬如说，如果 Redis 每 5 分钟执行一次 RDB 持久化，要是 Redis 意外奔溃了，那么最多会丢失 5 分钟的数据。</li></ul><p>2）AOF 持久化</p><p>　　可以使用<code>appendonly yes</code>配置项来开启 AOF 持久化。Redis 执行 AOF 持久化时，会将接收到的写命令追加到 AOF 文件的末尾，因此 Redis 只要对 AOF 文件中的命令进行回放，就可以将数据库还原到原先的状态。<br>　　与 RDB 持久化相比，AOF 持久化的一个明显优势就是，它可以提高数据的持久性 (durability)。因为在 AOF 模式下，Redis 每次接收到 client 的写命令，就会将命令<code>write()</code>到 AOF 文件末尾。<br>　　然而，在 Linux 中，将数据<code>write()</code>到文件后，数据并不会立即刷新到磁盘，而会先暂存在 OS 的文件系统缓冲区。在合适的时机，OS 才会将缓冲区的数据刷新到磁盘（如果需要将文件内容刷新到磁盘，可以调用<code>fsync()</code>或<code>fdatasync()</code>）。<br>　　通过<code>appendfsync</code>配置项，可以控制 Redis 将命令同步到磁盘的频率：</p><ul><li><code>always</code>：每次 Redis 将命令<code>write()</code>到 AOF 文件时，都会调用<code>fsync()</code>，将命令刷新到磁盘。这可以保证最好的数据持久性，但却会给系统带来极大的开销。</li><li><code>no</code>：Redis 只将命令<code>write()</code>到 AOF 文件。这会让 OS 决定何时将命令刷新到磁盘。</li><li><code>everysec</code>：除了将命令<code>write()</code>到 AOF 文件，Redis 还会每秒执行一次<code>fsync()</code>。在实践中，推荐使用这种设置，一定程度上可以保证数据持久性，又不会明显降低 Redis 性能。</li></ul><p>　　然而，AOF 持久化并不是没有缺点的：Redis 会不断将接收到的写命令追加到 AOF 文件中，导致 AOF 文件越来越大。过大的 AOF 文件会消耗磁盘空间，并且导致 Redis 重启时更加缓慢。为了解决这个问题，在适当情况下，Redis 会对 AOF 文件进行重写，去除文件中冗余的命令，以减小 AOF 文件的体积。在重写 AOF 文件期间， Redis 会启动一个子进程，由子进程负责对 AOF 文件进行重写。<br>　　可以通过下面两个配置项，控制 Redis 重写 AOF 文件的频率：</p><ul><li><code>auto-aof-rewrite-min-size 64mb</code></li><li><code>auto-aof-rewrite-percentage 100</code></li></ul><p>　　上面两个配置的作用：当 AOF 文件的体积大于 64MB，并且 AOF 文件的体积比上一次重写之后的体积大了至少一倍，那么 Redis 就会执行 AOF 重写。</p><p>优点：</p><ul><li>持久化频率高，数据可靠性高</li><li>没有额外的内存或CPU消耗</li></ul><p>缺点：</p><ul><li>文件体积大</li><li>文件大导致服务数据恢复时效率较低</li></ul><p><strong>面试话术：</strong></p><p>Redis 提供了两种数据持久化的方式，一种是 RDB，另一种是 AOF。默认情况下，Redis 使用的是 RDB 持久化。</p><p>RDB持久化文件体积较小，但是保存数据的频率一般较低，可靠性差，容易丢失数据。另外RDB写数据时会采用Fork函数拷贝主进程，可能有额外的内存消耗，文件压缩也会有额外的CPU消耗。</p><p>ROF持久化可以做到每秒钟持久化一次，可靠性高。但是持久化文件体积较大，导致数据恢复时读取文件时间较长，效率略低</p><h2 id="3-3-Redis的集群方式有哪些？"><a href="#3-3-Redis的集群方式有哪些？" class="headerlink" title="3.3.Redis的集群方式有哪些？"></a>3.3.Redis的集群方式有哪些？</h2><p><strong>面试话术：</strong></p><p>Redis集群可以分为<strong>主从集群</strong>和<strong>分片集群</strong>两类。</p><p><strong>主从集群</strong>一般一主多从，主库用来写数据，从库用来读数据。结合哨兵，可以再主库宕机时从新选主，<strong>目的是保证Redis的高可用</strong>。</p><p><strong>分片集群</strong>是数据分片，我们会让多个Redis节点组成集群，并将16383个插槽分到不同的节点上。存储数据时利用对key做hash运算，得到插槽值后存储到对应的节点即可。因为存储数据面向的是插槽而非节点本身，因此可以做到集群动态伸缩。<strong>目的是让Redis能存储更多数据。</strong></p><p>1）主从集群</p><p>主从集群，也是读写分离集群。一般都是一主多从方式。</p><p>Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。</p><p>只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p><ul><li>写数据时只能通过主节点完成</li><li>读数据可以从任何节点完成</li><li>如果配置了<code>哨兵节点</code>，当master宕机时，哨兵会从salve节点选出一个新的主。</li></ul><p>主从集群分两种：</p><p><img src="/img/OIP-C.jpg" data-original="/../assets/1574821993599.png" alt="1574821993599"> <img src="/img/OIP-C.jpg" data-original="/../assets/1574822026037.png" alt="1574822026037"> </p><p>带有哨兵的集群：</p><p><img src="/img/OIP-C.jpg" data-original="/../assets/1574822077190.png" alt="1574822077190"></p><p>2）分片集群</p><p>主从集群中，每个节点都要保存所有信息，容易形成木桶效应。并且当数据量较大时，单个机器无法满足需求。此时我们就要使用分片集群了。</p><p><img src="/img/OIP-C.jpg" data-original="/../assets/1574822184467.png" alt="1574822184467"> </p><p>集群特征：</p><ul><li><p>每个节点都保存不同数据</p></li><li><p>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.</p></li><li><p>节点的fail是通过集群中超过半数的节点检测失效时才生效.</p></li><li><p>客户端与redis节点直连,不需要中间proxy层连接集群中任何一个可用节点都可以访问到数据</p></li><li><p>redis-cluster把所有的物理节点映射到[0-16383]slot（插槽）上，实现动态伸缩</p></li></ul><p>为了保证Redis中每个节点的高可用，我们还可以给每个节点创建replication（slave节点），如图：</p><p><img src="/img/OIP-C.jpg" data-original="/../assets/1574822584357.png" alt="1574822584357"></p><p>出现故障时，主从可以及时切换：</p><p><img src="/img/OIP-C.jpg" data-original="/../assets/1574822602109.png" alt="1574822602109"></p><h2 id="3-4-Redis的常用数据类型有哪些？"><a href="#3-4-Redis的常用数据类型有哪些？" class="headerlink" title="3.4.Redis的常用数据类型有哪些？"></a>3.4.Redis的常用数据类型有哪些？</h2><p>支持多种类型的数据结构，主要区别是value存储的数据格式不同：</p><ul><li><p>string：最基本的数据类型，二进制安全的字符串，最大512M。</p></li><li><p>list：按照添加顺序保持顺序的字符串列表。</p></li><li><p>set：无序的字符串集合，不存在重复的元素。</p></li><li><p>sorted set：已排序的字符串集合。</p></li><li><p>hash：key-value对格式</p></li></ul><h2 id="3-5-聊一下Redis事务机制"><a href="#3-5-聊一下Redis事务机制" class="headerlink" title="3.5.聊一下Redis事务机制"></a>3.5.聊一下Redis事务机制</h2><p><strong>相关资料：</strong></p><p>参考：<a href="http://redisdoc.com/topic/transaction.html">http://redisdoc.com/topic/transaction.html</a></p><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的。Redis会将一个事务中的所有命令序列化，然后按顺序执行。但是Redis事务不支持回滚操作，命令运行出错后，正确的命令会继续执行。</p><ul><li><code>MULTI</code>: 用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个<strong>待执行命令队列</strong>中</li><li><code>EXEC</code>：按顺序执行命令队列内的所有命令。返回所有命令的返回值。事务执行过程中，Redis不会执行其它事务的命令。</li><li><code>DISCARD</code>：清空命令队列，并放弃执行事务， 并且客户端会从事务状态中退出</li><li><code>WATCH</code>：Redis的乐观锁机制，利用compare-and-set（CAS）原理，可以监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行</li></ul><p>使用事务时可能会遇上以下两种错误：</p><ul><li>执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 <code>maxmemory</code> 设置了最大内存限制的话）。<ul><li>Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。</li></ul></li><li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。<ul><li>即使事务中有某个&#x2F;某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行，不会回滚。</li></ul></li></ul><p>为什么 Redis 不支持回滚（roll back）？</p><p>以下是这种做法的优点：</p><ul><li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由<strong>编程错误</strong>造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li><li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul><p>鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p><p><strong>面试话术：</strong></p><p>Redis事务其实是把一系列Redis命令放入队列，然后批量执行，执行过程中不会有其它事务来打断。不过与关系型数据库的事务不同，Redis事务不支持回滚操作，事务中某个命令执行失败，其它命令依然会执行。</p><p>为了弥补不能回滚的问题，Redis会在事务入队时就检查命令，如果命令异常则会放弃整个事务。</p><p>因此，只要程序员编程是正确的，理论上说Redis会正确执行所有事务，无需回滚。</p><p>面试官：如果事务执行一半的时候Redis宕机怎么办？</p><p>Redis有持久化机制，因为可靠性问题，我们一般使用AOF持久化。事务的所有命令也会写入AOF文件，但是如果在执行EXEC命令之前，Redis已经宕机，则AOF文件中事务不完整。使用 <code>redis-check-aof</code> 程序可以移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p><h2 id="3-6-Redis的Key过期策略"><a href="#3-6-Redis的Key过期策略" class="headerlink" title="3.6.Redis的Key过期策略"></a>3.6.Redis的Key过期策略</h2><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a><strong>参考资料：</strong></h3><h4 id="为什么需要内存回收？"><a href="#为什么需要内存回收？" class="headerlink" title="为什么需要内存回收？"></a>为什么需要内存回收？</h4><ul><li>1、在Redis中，set指令可以指定key的过期时间，当过期时间到达以后，key就失效了；</li><li>2、Redis是基于内存操作的，所有的数据都是保存在内存中，一台机器的内存是有限且很宝贵的。</li></ul><p>基于以上两点，为了保证Redis能继续提供可靠的服务，Redis需要一种机制清理掉不常用的、无效的、多余的数据，失效后的数据需要及时清理，这就需要内存回收了。</p><p>Redis的内存回收主要分为过期删除策略和内存淘汰策略两部分。</p><h4 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h4><p>删除达到过期时间的key。</p><ul><li>1）定时删除</li></ul><p>对于每一个设置了过期时间的key都会创建一个定时器，一旦到达过期时间就立即删除。该策略可以立即清除过期的数据，对内存较友好，但是缺点是占用了大量的CPU资源去处理过期的数据，会影响Redis的吞吐量和响应时间。</p><ul><li>2）惰性删除</li></ul><p>当访问一个key时，才判断该key是否过期，过期则删除。该策略能最大限度地节省CPU资源，但是对内存却十分不友好。有一种极端的情况是可能出现大量的过期key没有被再次访问，因此不会被清除，导致占用了大量的内存。</p><blockquote><p>在计算机科学中，懒惰删除（英文：lazy deletion）指的是从一个散列表（也称哈希表）中删除元素的一种方法。在这个方法中，删除仅仅是指标记一个元素被删除，而不是整个清除它。被删除的位点在插入时被当作空元素，在搜索之时被当作已占据。</p></blockquote><ul><li>3）定期删除</li></ul><p>每隔一段时间，扫描Redis中过期key字典，并清除部分过期的key。该策略是前两者的一个折中方案，还可以通过调整定时扫描的时间间隔和每次扫描的限定耗时，在不同情况下使得CPU和内存资源达到最优的平衡效果。</p><p>在Redis中，<code>同时使用了定期删除和惰性删除</code>。不过Redis定期删除采用的是随机抽取的方式删除部分Key，因此不能保证过期key 100%的删除。</p><p>Redis结合了定期删除和惰性删除，基本上能很好的处理过期数据的清理，但是实际上还是有点问题的，如果过期key较多，定期删除漏掉了一部分，而且也没有及时去查，即没有走惰性删除，那么就会有大量的过期key堆积在内存中，导致redis内存耗尽，当内存耗尽之后，有新的key到来会发生什么事呢？是直接抛弃还是其他措施呢？有什么办法可以接受更多的key？</p><h4 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h4><p>Redis的内存淘汰策略，是指内存达到maxmemory极限时，使用某种算法来决定清理掉哪些数据，以保证新数据的存入。</p><p>Redis的内存淘汰机制包括：</p><ul><li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错。</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间（<code>server.db[i].dict</code>）中，移除最近最少使用的 key（这个是最常用的）。</li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间（<code>server.db[i].dict</code>）中，随机移除某个 key。</li><li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，移除最近最少使用的 key。</li><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，随机移除某个 key。</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，有更早过期时间的 key 优先移除。</li></ul><blockquote><p>在配置文件中，通过maxmemory-policy可以配置要使用哪一个淘汰机制。</p></blockquote><p>什么时候会进行淘汰？</p><p>Redis会在每一次处理命令的时候（processCommand函数调用freeMemoryIfNeeded）判断当前redis是否达到了内存的最大限制，如果达到限制，则使用对应的算法去处理需要删除的key。</p><p>在淘汰key时，Redis默认最常用的是LRU算法（Latest Recently Used）。Redis通过在每一个redisObject保存lru属性来保存key最近的访问时间，在实现LRU算法时直接读取key的lru属性。</p><p>具体实现时，Redis遍历每一个db，从每一个db中随机抽取一批样本key，默认是3个key，再从这3个key中，删除最近最少使用的key。</p><h3 id="面试话术："><a href="#面试话术：" class="headerlink" title="面试话术："></a>面试话术：</h3><p>Redis过期策略包含定期删除和惰性删除两部分。定期删除是在Redis内部有一个定时任务，会定期删除一些过期的key。惰性删除是当用户查询某个Key时，会检查这个Key是否已经过期，如果没过期则返回用户，如果过期则删除。</p><p>但是这两个策略都无法保证过期key一定删除，漏网之鱼越来越多，还可能导致内存溢出。当发生内存不足问题时，Redis还会做内存回收。内存回收采用LRU策略，就是最近最少使用。其原理就是记录每个Key的最近使用时间，内存回收时，随机抽取一些Key，比较其使用时间，把最老的几个删除。</p><p>Redis的逻辑是：最近使用过的，很可能再次被使用</p><h2 id="3-7-Redis在项目中的哪些地方有用到"><a href="#3-7-Redis在项目中的哪些地方有用到" class="headerlink" title="3.7.Redis在项目中的哪些地方有用到?"></a>3.7.Redis在项目中的哪些地方有用到?</h2><p>（1）共享session</p><p>在分布式系统下，服务会部署在不同的tomcat，因此多个tomcat的session无法共享，以前存储在session中的数据无法实现共享，可以用redis代替session，解决分布式系统间数据共享问题。</p><p>（2）数据缓存</p><p>Redis采用内存存储，读写效率较高。我们可以把数据库的访问频率高的热点数据存储到redis中，这样用户请求时优先从redis中读取，减少数据库压力，提高并发能力。</p><p>（3）异步队列</p><p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。而且Redis中还有pub&#x2F;sub这样的专用结构，用于1对N的消息通信模式。</p><p>（4）分布式锁</p><p>Redis中的乐观锁机制，可以帮助我们实现分布式锁的效果，用于解决分布式系统下的多线程安全问题</p><h2 id="3-8-Redis的缓存击穿、缓存雪崩、缓存穿透"><a href="#3-8-Redis的缓存击穿、缓存雪崩、缓存穿透" class="headerlink" title="3.8.Redis的缓存击穿、缓存雪崩、缓存穿透"></a>3.8.Redis的缓存击穿、缓存雪崩、缓存穿透</h2><h3 id="1）缓存穿透"><a href="#1）缓存穿透" class="headerlink" title="1）缓存穿透"></a>1）缓存穿透</h3><p>参考资料：</p><ul><li><p>什么是缓存穿透</p><ul><li>正常情况下，我们去查询数据都是存在。那么请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。这种查询不存在数据的现象我们称为<strong>缓存穿透</strong>。</li></ul></li><li><p>穿透带来的问题</p><ul><li>试想一下，如果有黑客会对你的系统进行攻击，拿一个不存在的id 去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉。</li></ul></li><li><p>解决办法</p><ul><li>缓存空值：之所以会发生穿透，就是因为缓存中没有存储这些空数据的key。从而导致每次查询都到数据库去了。那么我们就可以为这些key对应的值设置为null 丢到缓存里面去。后面再出现查询这个key 的请求的时候，直接返回null 。这样，就不用在到数据库中去走一圈了，但是别忘了设置过期时间。</li><li>BloomFilter（布隆过滤）：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 -&gt; 查 DB。</li></ul></li></ul><p><strong>话术：</strong></p><p>缓存穿透有两种解决方案：<strong>其一</strong>是把不存在的key设置null值到缓存中。<strong>其二</strong>是使用布隆过滤器，在查询缓存前先通过布隆过滤器判断key是否存在，存在再去查询缓存。</p><p>设置null值可能被恶意针对，攻击者使用大量不存在的不重复key ，那么方案一就会缓存大量不存在key数据。此时我们还可以对Key规定格式模板，然后对不存在的key做<strong>正则规范</strong>匹配，如果完全不符合就不用存null值到redis，而是直接返回错误。</p><h3 id="2）缓存击穿"><a href="#2）缓存击穿" class="headerlink" title="2）缓存击穿"></a>2）缓存击穿</h3><p><strong>相关资料</strong>：</p><ul><li>什么是缓存击穿？</li></ul><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p><p>当这个key在失效的瞬间，redis查询失败，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><ul><li>解决方案：<ul><li>使用互斥锁(mutex key)：mutex，就是互斥。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用Redis的SETNX去set一个互斥key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现互斥的效果。</li><li>软过期：也就是逻辑过期，不使用redis提供的过期时间，而是业务层在数据中存储过期时间信息。查询时由业务程序判断是否过期，如果数据即将过期时，将缓存的时效延长，程序可以派遣一个线程去数据库中获取最新的数据，其他线程这时看到延长了的过期时间，就会继续使用旧数据，等派遣的线程获取最新数据后再更新缓存。</li></ul></li></ul><p>推荐使用互斥锁，因为软过期会有业务逻辑侵入和额外的判断。</p><p><strong>面试话术</strong>：</p><p>缓存击穿主要担心的是某个Key过期，更新缓存时引起对数据库的突发高并发访问。因此我们可以在更新缓存时采用互斥锁控制，只允许一个线程去更新缓存，其它线程等待并重新读取缓存。例如Redis的setnx命令就能实现互斥效果。</p><h3 id="3）缓存雪崩"><a href="#3）缓存雪崩" class="headerlink" title="3）缓存雪崩"></a>3）缓存雪崩</h3><p><strong>相关资料</strong>：</p><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。对这批数据的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。</p><p>解决方案：</p><ul><li>数据分类分批处理：采取不同分类数据，缓存不同周期</li><li>相同分类数据：采用固定时长加随机数方式设置缓存</li><li>热点数据缓存时间长一些，冷门数据缓存时间短一些</li><li>避免redis节点宕机引起雪崩，搭建主从集群，保证高可用</li></ul><p><strong>面试话术：</strong></p><p>解决缓存雪崩问题的关键是让缓存Key的过期时间分散。因此我们可以把数据按照业务分类，然后设置不同过期时间。相同业务类型的key，设置固定时长加随机数。尽可能保证每个Key的过期时间都不相同。</p><p>另外，Redis宕机也可能导致缓存雪崩，因此我们还要搭建Redis主从集群及哨兵监控，保证Redis的高可用。</p><h2 id="3-9-缓存冷热数据分离"><a href="#3-9-缓存冷热数据分离" class="headerlink" title="3.9.缓存冷热数据分离"></a>3.9.缓存冷热数据分离</h2><p><strong>背景资料</strong>：</p><p>Redis使用的是内存存储，当需要海量数据存储时，成本非常高。</p><p>经过调研发现，当前主流DDR3内存和主流SATA SSD的单位成本价格差距大概在20倍左右，为了优化redis机器综合成本，我们考虑实现基于<strong>热度统计 的数据分级存储</strong>及数据在RAM&#x2F;FLASH之间的动态交换，从而大幅度降低成本，达到性能与成本的高平衡。</p><p>基本思路：基于key访问次数(LFU)的热度统计算法识别出热点数据，并将热点数据保留在redis中，对于无访问&#x2F;访问次数少的数据则转存到SSD上，如果SSD上的key再次变热，则重新将其加载到redis内存中。</p><p>目前流行的高性能磁盘存储，并且遵循Redis协议的方案包括：</p><ul><li>SSDB：<a href="http://ssdb.io/zh_cn/">http://ssdb.io/zh_cn/</a></li><li>RocksDB：<a href="https://rocksdb.org.cn/">https://rocksdb.org.cn/</a></li></ul><p>因此，我们就需要在应用程序与缓存服务之间引入代理，实现Redis和SSD之间的切换，如图：</p><p><img src="/img/OIP-C.jpg" data-original="/../assets/image-20200521115702956.png" alt="image-20200521115702956"></p><p>这样的代理方案阿里云提供的就有。当然也有一些开源方案，例如：<a href="https://github.com/JingchengLi/swapdb">https://github.com/JingchengLi/swapdb</a></p><h2 id="3-10-Redis实现分布式锁"><a href="#3-10-Redis实现分布式锁" class="headerlink" title="3.10.Redis实现分布式锁"></a>3.10.Redis实现分布式锁</h2><p>分布式锁要满足的条件：</p><ul><li>多进程互斥：同一时刻，只有一个进程可以获取锁</li><li>保证锁可以释放：任务结束或出现异常，锁一定要释放，避免死锁</li><li>阻塞锁（可选）：获取锁失败时可否重试</li><li>重入锁（可选）：获取锁的代码递归调用时，依然可以获取锁</li></ul><h3 id="1）最基本的分布式锁："><a href="#1）最基本的分布式锁：" class="headerlink" title="1）最基本的分布式锁："></a>1）最基本的分布式锁：</h3><p>利用Redis的setnx命令，这个命令的特征时如果多次执行，只有第一次执行会成功，可以实现<code>互斥</code>的效果。但是为了保证服务宕机时也可以释放锁，需要利用expire命令给锁设置一个有效期</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setnx lock thread-01 # 尝试获取锁</span><br><span class="line">expire lock 10 # 设置有效期</span><br></pre></td></tr></table></figure><p><strong>面试官问题1</strong>：如果expire之前服务宕机怎么办？</p><p>要保证setnx和expire命令的原子性。redis的set命令可以满足：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value [NX] [EX time] </span><br></pre></td></tr></table></figure><p>需要添加nx和ex的选项：</p><ul><li>NX：与setnx一致，第一次执行成功</li><li>EX：设置过期时间</li></ul><p><strong>面试官问题2</strong>：释放锁的时候，如果自己的锁已经过期了，此时会出现安全漏洞，如何解决？</p><p>在锁中存储当前进程和线程标识，释放锁时对锁的标识判断，如果是自己的则删除，不是则放弃操作。</p><p>但是这两步操作要保证原子性，需要通过Lua脚本来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br><span class="line">    redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="2）可重入分布式锁"><a href="#2）可重入分布式锁" class="headerlink" title="2）可重入分布式锁"></a>2）可重入分布式锁</h3><p>如果有重入的需求，则除了在锁中记录进程标识，还要记录重试次数，流程如下：</p><p><img src="/img/OIP-C.jpg" data-original="/../assets/1574824172228.png" alt="1574824172228"> </p><p>下面我们假设锁的key为“<code>lock</code>”，hashKey是当前线程的id：“<code>threadId</code>”，锁自动释放时间假设为20</p><p>获取锁的步骤：</p><ul><li>1、判断lock是否存在 <code>EXISTS lock</code><ul><li>存在，说明有人获取锁了，下面判断是不是自己的锁<ul><li>判断当前线程id作为hashKey是否存在：<code>HEXISTS lock threadId</code><ul><li>不存在，说明锁已经有了，且不是自己获取的，锁获取失败，end</li><li>存在，说明是自己获取的锁，重入次数+1：<code>HINCRBY lock threadId 1</code>，去到步骤3</li></ul></li></ul></li><li>2、不存在，说明可以获取锁，<code>HSET key threadId 1</code></li><li>3、设置锁自动释放时间，<code>EXPIRE lock 20</code></li></ul></li></ul><p>释放锁的步骤：</p><ul><li>1、判断当前线程id作为hashKey是否存在：<code>HEXISTS lock threadId</code><ul><li>不存在，说明锁已经失效，不用管了</li><li>存在，说明锁还在，重入次数减1：<code>HINCRBY lock threadId -1</code>，获取新的重入次数</li></ul></li><li>2、判断重入次数是否为0：<ul><li>为0，说明锁全部释放，删除key：<code>DEL lock</code></li><li>大于0，说明锁还在使用，重置有效时间：<code>EXPIRE lock 20</code></li></ul></li></ul><p>对应的Lua脚本如下：</p><p>首先是获取锁：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;exists&#x27;</span>, key) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断是否存在</span></span><br><span class="line">redis.call(<span class="string">&#x27;hset&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>); <span class="comment">-- 不存在, 获取锁</span></span><br><span class="line">redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime); <span class="comment">-- 设置有效期</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">1</span>) <span class="keyword">then</span> <span class="comment">-- 锁已经存在，判断threadId是否是自己</span></span><br><span class="line">redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>); <span class="comment">-- 不存在, 获取锁，重入次数+1</span></span><br><span class="line">redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime); <span class="comment">-- 设置有效期</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">-- 代码走到这里,说明获取锁的不是自己，获取锁失败</span></span><br></pre></td></tr></table></figure><p>然后是释放锁：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, key, threadId) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断当前锁是否还是被自己持有</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">-- 如果已经不是自己，则直接返回</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, threadId, <span class="number">-1</span>); <span class="comment">-- 是自己的锁，则重入次数-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断是否重入次数是否已经为0</span></span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, releaseTime); <span class="comment">-- 大于0说明不能释放锁，重置有效期然后返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">&#x27;DEL&#x27;</span>, key); <span class="comment">-- 等于0说明可以释放锁，直接删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3 id="3）高可用的锁"><a href="#3）高可用的锁" class="headerlink" title="3）高可用的锁"></a>3）高可用的锁</h3><p><code>面试官问题</code>：redis分布式锁依赖与redis，如果redis宕机则锁失效。如何解决？</p><p>此时大多数同学会回答说：搭建主从集群，做数据备份。</p><p>这样就进入了陷阱，因为面试官的下一个问题就来了：</p><p><code>面试官问题</code>：如果搭建主从集群做数据备份时，进程A获取锁，master还没有把数据备份到slave，master宕机，slave升级为master，此时原来锁失效，其它进程也可以获取锁，出现安全问题。如何解决？</p><p>关于这个问题，Redis官网给出了解决方案，使用RedLock思路可以解决：</p><blockquote><p>在Redis的分布式环境中，我们假设有N个Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁。我们确保将在每（N)个实例上使用此方法获取和释放锁。在这个样例中，我们假设有5个Redis master节点，这是一个比较合理的设置，所以我们需要在5台机器上面或者5台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。</p><p>为了取到锁，客户端应该执行以下操作:</p><ol><li>获取当前Unix时间，以毫秒为单位。</li><li>依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。</li><li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</li><li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li><li>如果因为某些原因，获取锁失败（<em>没有</em>在至少N&#x2F;2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。</li></ol></blockquote><h2 id="3-11-如何实现数据库与缓存数据一致？"><a href="#3-11-如何实现数据库与缓存数据一致？" class="headerlink" title="3.11.如何实现数据库与缓存数据一致？"></a>3.11.如何实现数据库与缓存数据一致？</h2><p>面试话术：</p><p>实现方案有下面几种：</p><ul><li>本地缓存同步：当前微服务的数据库数据与缓存数据同步，可以直接在数据库修改时加入对Redis的修改逻辑，保证一致。</li><li>跨服务缓存同步：服务A调用了服务B，并对查询结果缓存。服务B数据库修改，可以通过MQ通知服务A，服务A修改Redis缓存数据</li><li>通用方案：使用Canal框架，伪装成MySQL的salve节点，监听MySQL的binLog变化，然后修改Redis缓存数据</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见面试题&quot;&gt;&lt;a href=&quot;#常见面试题&quot; class=&quot;headerlink&quot; title=&quot;常见面试题&quot;&gt;&lt;/a&gt;常见面试题&lt;/h1&gt;&lt;h1 id=&quot;1-微服务篇&quot;&gt;&lt;a href=&quot;#1-微服务篇&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="面试题" scheme="http://www.sion-io.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="http://www.sion-io.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JSP</title>
    <link href="http://www.sion-io.cn/2024/05/11/%E7%AC%94%E8%AE%B0/02-JSP/"/>
    <id>http://www.sion-io.cn/2024/05/11/%E7%AC%94%E8%AE%B0/02-JSP/</id>
    <published>2024-05-11T06:56:01.000Z</published>
    <updated>2024-05-12T08:19:51.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="1-JSP简述"><a href="#1-JSP简述" class="headerlink" title="1.JSP简述"></a>1.JSP简述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JSP全称是Java Server Pages。本质来说就是一个Servlet、他和Servlet组成在一起是一套J2EE的规范。</span><br><span class="line">和HTML的区别就是:</span><br><span class="line">HTML是纯静态的。不能包含Java代码。无法动态的加载，修改，删除数据</span><br><span class="line">Servlet：通过响应对象可以给空白页写入html元素，但是开发效率低</span><br><span class="line">JSP:支持HTML的标签，同时具备Servlet的动态输出功能。 可以理解为HTML+Servlet</span><br></pre></td></tr></table></figure><h2 id="2-入门程序"><a href="#2-入门程序" class="headerlink" title="2.入门程序"></a>2.入门程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.在maven项目中添加web模块</span><br><span class="line">2.webapp目录中创建jsp页面</span><br><span class="line">3.编写页面</span><br><span class="line">4.运行测试</span><br></pre></td></tr></table></figure><h2 id="3-Jsp运行原理"><a href="#3-Jsp运行原理" class="headerlink" title="3.Jsp运行原理"></a>3.Jsp运行原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端发送请求到服务器，tomcat服务器解析请求并且处理请求，然后转发到指定的JSP页面。Tomcat会将JSP页面转换成Servlet的Java文件，JVM将.java文件编译成.class文件，响应执行.class文件</span><br></pre></td></tr></table></figure><h2 id="4-JSP应用"><a href="#4-JSP应用" class="headerlink" title="4.JSP应用"></a>4.JSP应用</h2><h3 id="4-1JSP语法"><a href="#4-1JSP语法" class="headerlink" title="4.1JSP语法"></a>4.1JSP语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.Java代码块</span><br><span class="line">语法:&lt;%Java代码块%&gt;</span><br><span class="line">案例:</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String str = &quot;messsage&quot;;</span><br><span class="line">System.out.println(str)</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">注意：在实际开发中不使用此种方式开发Java代码。因为里面的内容都是Tomcat负责编译，编译之后会成为Servlet的成员变量。只会给tomcat增加额外的负担。</span><br><span class="line"></span><br><span class="line">2.JSP表达式</span><br><span class="line">语法：&lt;%= %&gt; (实际开发中也不使用)</span><br><span class="line">案例:&lt;%=1+6==7 %&gt;</span><br><span class="line">表达式的内容最后是由out.println(&quot;表达式&quot;)</span><br><span class="line"></span><br><span class="line">3.JSP声明:在JSP页面中声明一些Java变量，方法，静态方法等</span><br><span class="line">语法：&lt;%! %&gt; (实际开发中也不使用)</span><br><span class="line">案例:</span><br><span class="line">&lt;%! </span><br><span class="line">public void method01()&#123;</span><br><span class="line">        System.out.println(&quot;这是JSP的声明方法&quot;)</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    method01();</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="4-2-JSP指令-3"><a href="#4-2-JSP指令-3" class="headerlink" title="4.2 JSP指令(3)"></a>4.2 JSP指令(3)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">指令必须使用&lt;%@ %&gt;</span><br><span class="line">1.page指令</span><br><span class="line">简介:创建一个jsp页面后默认就存在了page指令</span><br><span class="line">page执行的属性和作用:</span><br><span class="line">contentType:告知引擎，响应正文使用的mime类型</span><br><span class="line">language：告知引擎，脚本使用的语言，默认是Java，不写不行。</span><br><span class="line">extends：告知引擎，当前jsp对应的servlet的父类是谁。不需要则不编写</span><br><span class="line">import：告知引擎引入相关依赖(.jar)</span><br><span class="line">注意:JSP在默认情况下也导入以下几个包。java.lang.*;javax.servlet.*;javax.servlet.http.*;javax.servlet.*javax.servlet.jsp.*</span><br><span class="line">session:告知引擎是否产生httpSession对象，默认为true。</span><br><span class="line">buffer：告知引擎设置缓存大小。默认为8kb；</span><br><span class="line">errorPage：告知引擎页面发生异常后转发到那个页面。一般在开发中使用web.xml中配置全局错误页面取代它</span><br><span class="line">isErrorPage：告知引擎是否捕获异常。默认值为false。如果设置为true，那么页面中就可以使用exception对象(隐式对象)</span><br><span class="line">isELIgnored:告知引擎是否忽略EL表达式。默认为false。一般也不会更改</span><br><span class="line">pageEncoding：告知引擎编译JSP的时候使用的编码格式</span><br><span class="line"></span><br><span class="line">2.include指令</span><br><span class="line">语法:&lt;%@ file=&quot;&quot; %&gt;</span><br><span class="line">作用：该指令用于包含外部页面(静态包含)</span><br><span class="line">引用场景:一个网站包含很多页面，这些页面一般都有公共的头和尾。所以一般把头尾做成两个页面，其他页面引用这两个头尾页面</span><br><span class="line">案例:</span><br><span class="line">&lt;%@ includ file = &quot;head.jsp&quot;%&gt;</span><br><span class="line"></span><br><span class="line">3.taglib指令</span><br><span class="line">语法:&lt;%@ taglib prefix=&quot;&quot; uri=&quot;&quot; %&gt;</span><br><span class="line">作用:引入外部的标签库。jsp页面中默认就引入了html和jsp的标签库</span><br><span class="line">属性:</span><br><span class="line">uri:外部标签的地址</span><br><span class="line">prefix:使用外部标签库的前缀</span><br></pre></td></tr></table></figure><h3 id="4-3-JSP动作-6"><a href="#4-3-JSP动作-6" class="headerlink" title="4.3 JSP动作(6)"></a>4.3 JSP动作(6)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.jsp:include(动态包含)</span><br><span class="line">语法:&lt;jsp:include page=&quot;地址&quot;&gt;</span><br><span class="line">案例：&lt;jsp:include page = &quot;head.jsp&quot;&gt;&lt;/jsp:include&gt;</span><br><span class="line">动态包含和静态包含的区别:</span><br><span class="line">最终的结果和目的是一样的。</span><br><span class="line">主要区别是静态包含(指令)是把两个页面合成一个页面，也就是说编译后只产生一个.java文件(先包含再编译)</span><br><span class="line">动态包含是将两个页面分别进行编译，包含者和被包含者属于调用关系(先编译再调用)</span><br><span class="line"></span><br><span class="line">2.jsp:useBean;jsp:setProperty;getProperty </span><br><span class="line">&lt;%--等价于 Student stu = new Student()--%&gt;</span><br><span class="line">&lt;jsp:useBean id=&quot;stu&quot; class=&quot;com.lxk.pojo.Student&quot;&gt;&lt;/jsp:useBean&gt;</span><br><span class="line">&lt;%-- 等价于 stu.setStudentName(&quot;张雨薇&quot;)--%&gt;</span><br><span class="line">&lt;jsp:setProperty name=&quot;stu&quot; property=&quot;studentName&quot; value=&quot;张雨薇&quot;&gt;&lt;/jsp:setProperty&gt; </span><br><span class="line">&lt;%--等价于 stu.getStudentName() 直接把结果输出带页面上--%&gt;</span><br><span class="line">&lt;jsp:getProperty name=&quot;stu&quot; property=&quot;studentName&quot;/&gt;</span><br><span class="line"></span><br><span class="line">3.jsp:forward；jsp:param</span><br><span class="line">&lt;jsp:forward page=&quot;adduser.jsp&quot;&gt;</span><br><span class="line">    &lt;jsp:param name=&quot;userId&quot; value=&quot;123&quot;/&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br><span class="line">--------获取参数</span><br><span class="line">&lt;%= request.getParameter(&quot;userId&quot;)%&gt;</span><br></pre></td></tr></table></figure><h3 id="4-4-JSP隐式对象-9"><a href="#4-4-JSP隐式对象-9" class="headerlink" title="4.4 JSP隐式对象(9)"></a>4.4 JSP隐式对象(9)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">JSP的隐式对象就是JSP的内置对象，是JSP事先创建好的对象，不需要new就可以直接使用。</span><br><span class="line">注意:在任何JSP页面中都可以使用，但是只能在表达式和脚本中使用</span><br><span class="line"></span><br><span class="line">分类:</span><br><span class="line">输入输出对象:request，response，out</span><br><span class="line">作用域:session，application，pageContext</span><br><span class="line">servlet对象:page,config</span><br><span class="line">错误对象:exception</span><br><span class="line"></span><br><span class="line">输入输出对象:</span><br><span class="line">request，response和Servlet中的是同一个对象</span><br><span class="line">out:主要用于页面内容的输出，一般不使用。一般使用EL和JSTL</span><br><span class="line"></span><br><span class="line">作用域对象和Servlet的四大作用域一样；</span><br><span class="line"></span><br><span class="line">servlet对象：</span><br><span class="line">page:page对象指的是当前页面本身，有点类似于Java中的this</span><br><span class="line">config：作用就是当前JSP转成servlet之后的配置信息。等价于servlet中的ServletConfig</span><br><span class="line"></span><br><span class="line">错误对象:</span><br><span class="line">使用前提是page指令中开启异常捕获。</span><br><span class="line">开发不使用，错误统一配置</span><br></pre></td></tr></table></figure><h2 id="5-EL表达式"><a href="#5-EL表达式" class="headerlink" title="5.EL表达式"></a>5.EL表达式</h2><h3 id="5-1-EL表达式简介"><a href="#5-1-EL表达式简介" class="headerlink" title="5.1 EL表达式简介"></a>5.1 EL表达式简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EL表达式是JSP/Servlet规范中的一部分。主要作用是JSP中获取数据(使用EL表达式取代JSP表达式)从而达到JSP脱离Java代码块和Java表达式</span><br><span class="line"></span><br><span class="line">语法:$&#123;表达式&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-基本应用"><a href="#5-2-基本应用" class="headerlink" title="5.2 基本应用"></a>5.2 基本应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        //存储一个String</span><br><span class="line">        req.setAttribute(&quot;name&quot;,&quot;张雨薇&quot;);</span><br><span class="line">        //存储一个引用数据类型</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        student.setStudentId(1);</span><br><span class="line">        student.setStudentName(&quot;张三&quot;);</span><br><span class="line">        req.setAttribute(&quot;student&quot;,student);</span><br><span class="line">        //集合类型</span><br><span class="line">        ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Student student2 = new Student();</span><br><span class="line">        student2.setStudentId(2);</span><br><span class="line">        student2.setStudentName(&quot;王凤荣&quot;);</span><br><span class="line">        Student student3 = new Student();</span><br><span class="line">        student3.setStudentId(3);</span><br><span class="line">        student3.setStudentName(&quot;麻子&quot;);</span><br><span class="line">        list.add(student2);</span><br><span class="line">        list.add(student3);</span><br><span class="line">        req.setAttribute(&quot;list&quot;,list);</span><br><span class="line">        //map类型</span><br><span class="line">        HashMap&lt;String, Student&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Student student4 = new Student();</span><br><span class="line">        student4.setStudentId(4);</span><br><span class="line">        student4.setStudentName(&quot;遛虞波狗东西&quot;);</span><br><span class="line">        student4.setStudentGender(&quot;不好说&quot;);</span><br><span class="line">        map.put(student4.getStudentName(),student4);</span><br><span class="line">        req.setAttribute(&quot;map&quot;,map);</span><br><span class="line">        req.getRequestDispatcher(&quot;/jsp/eltest.jsp&quot;).forward(req,resp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">获取String类型的数据</span><br><span class="line">$&#123;name&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">获取student对象的数据</span><br><span class="line">$&#123;student&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">获取student对象中的属性的数据</span><br><span class="line">$&#123;student.studentId&#125;</span><br><span class="line">$&#123;student.studentName&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">获取集合中的数据</span><br><span class="line">$&#123;list[0].studentId&#125;</span><br><span class="line">$&#123;list[0].studentName&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">获取map中的数据</span><br><span class="line">$&#123;map.key.studentGender&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-EL表达式运算符"><a href="#5-3-EL表达式运算符" class="headerlink" title="5.3 EL表达式运算符"></a>5.3 EL表达式运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">性别:&lt;input type=&quot;radio&quot; value = &quot;男&quot; name=&quot;gender&quot; $&#123;student.gender==&quot;男&quot;?&quot;checked&quot;:&quot;&quot;&#125;&gt;男</span><br><span class="line">&lt;input type=&quot;radio&quot; value = &quot;女&quot; name=&quot;gender&quot; $&#123;student.gender==&quot;女&quot;?&quot;checked&quot;:&quot;&quot;&#125;&gt;女</span><br></pre></td></tr></table></figure><h2 id="6-JSTL表达式"><a href="#6-JSTL表达式" class="headerlink" title="6.JSTL表达式"></a>6.JSTL表达式</h2><h3 id="6-1-JSTL简介"><a href="#6-1-JSTL简介" class="headerlink" title="6.1 JSTL简介"></a>6.1 JSTL简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">它是服务于JSP技术的一个第三方标签库。右apache实现的。主要是用于在JSP页面中的逻辑处理。</span><br><span class="line">JSTL标签库由五部分组成:Core,fmt,Funcations,SQL,XML。一般只使用Core。</span><br><span class="line">Core:核心标签库。只要用于逻辑处理</span><br><span class="line">Fmt:实现国际化</span><br><span class="line">Funcations：EL函数库。里面主要提供了EL表达式可以使用的方法</span><br><span class="line">SQL:用于操作数据源</span><br><span class="line">XML：操作XML</span><br></pre></td></tr></table></figure><h3 id="6-2-JSTL使用"><a href="#6-2-JSTL使用" class="headerlink" title="6.2 JSTL使用"></a>6.2 JSTL使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1.引入依赖</span><br><span class="line">2.在jsp中使用指令引入标签库</span><br><span class="line">3.使用</span><br><span class="line">3.1 遍历</span><br><span class="line">标签名:c:forEach</span><br><span class="line">属性:</span><br><span class="line">item：需要遍历的集合。此处使用EL表达式获取作用域中的数据</span><br><span class="line">var：把当前遍历的元素放入到page作用域中，var的属性的值作为page作用域中的key，当前的遍历的元素作为value</span><br><span class="line">begin：开始遍历的索引</span><br><span class="line">end：结束遍历的索引</span><br><span class="line">step：每次遍历的步长</span><br><span class="line">varStatus：它是计数器对象，记录索引和数据个数</span><br><span class="line">案例:</span><br><span class="line">    &lt;c:forEach items=&quot;$&#123;list&#125;&quot; var=&quot;student&quot;&gt;</span><br><span class="line">        $&#123;student.studentId&#125;</span><br><span class="line">        $&#123;student.studentName&#125;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;c:forEach begin=&quot;1&quot; end=&quot;$&#123;pageNum&#125;&quot; step=&quot;1&quot; var=&quot;i&quot;&gt;</span><br><span class="line">        &lt;a href=&quot;#&quot;&gt;$&#123;i&#125;&lt;/a&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">    </span><br><span class="line">3.2 判断</span><br><span class="line">标签名:c:if</span><br><span class="line">属性:</span><br><span class="line">test:表达式返回的结果决定当前JSTL标签内的代码是否执行</span><br><span class="line">案例：</span><br><span class="line">&lt;c:if test=&quot;$&#123;student.age&gt;18&#125;&quot;&gt;</span><br><span class="line">&lt;span&gt;成年1&lt;/span&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br><span class="line">&lt;c:if test=&quot;$&#123;student.age&gt;20&#125;&quot;&gt;</span><br><span class="line">&lt;span&gt;成年2&lt;/span&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=&quot;$&#123;student.age&lt;18&#125;&quot;&gt;&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=&quot;$&#123;student.age&lt;18&#125;&quot;&gt;&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=&quot;$&#123;student.age&lt;18&#125;&quot;&gt;&lt;/c:when&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br><span class="line"></span><br><span class="line">3.2 存储</span><br><span class="line">标签名:c:set</span><br><span class="line">属性:</span><br><span class="line">var:key</span><br><span class="line">value:value</span><br><span class="line">scope:作用域</span><br><span class="line">案例：</span><br><span class="line">&lt;c:set var=&quot;ctx&quot; value=&quot;$&#123;pageContext.request.contextPath&#125;&quot;&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:out value=&quot;$&#123;ctx&#125;&quot;&gt;&lt;/c:out&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JSP&quot;&gt;&lt;a href=&quot;#JSP&quot; class=&quot;headerlink&quot; title=&quot;JSP&quot;&gt;&lt;/a&gt;JSP&lt;/h1&gt;&lt;h2 id=&quot;1-JSP简述&quot;&gt;&lt;a href=&quot;#1-JSP简述&quot; class=&quot;headerlink&quot; title=&quot;1.JSP简述</summary>
      
    
    
    
    <category term="笔记" scheme="http://www.sion-io.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://www.sion-io.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Cookie Session</title>
    <link href="http://www.sion-io.cn/2024/05/11/%E7%AC%94%E8%AE%B0/03-Cookie%E5%92%8CSession/"/>
    <id>http://www.sion-io.cn/2024/05/11/%E7%AC%94%E8%AE%B0/03-Cookie%E5%92%8CSession/</id>
    <published>2024-05-11T06:56:01.000Z</published>
    <updated>2024-05-12T08:19:51.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-会话简介"><a href="#1-会话简介" class="headerlink" title="1.会话简介"></a>1.会话简介</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">会话：web应用中的会话指的是web开发中的一次通话，当通过浏览器访问应用的时候就会产生会话。浏览器关闭或者会话获取就会结束会话。</span><br></pre></td></tr></table></figure><h2 id="2-会话分类"><a href="#2-会话分类" class="headerlink" title="2.会话分类"></a>2.会话分类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie(客户端会话):使用客户端(浏览器)使用数据的存储和共享。每次请求的时候都会把会话的信息携带到服务器，从而实现多次请求之间的数据共享</span><br><span class="line">Session(服务端会话):底层采用的还是客户端会话技术(Cookie,),可以理解为Session就是一个特殊的Cookie(cookie名为JSESSIONID)。每次客户端发送请求都会把这个特殊标识(JSESSIONID)携带到服务端。服务器通过这个特殊标识找到对应的内存空间。</span><br></pre></td></tr></table></figure><h2 id="3-Cookie"><a href="#3-Cookie" class="headerlink" title="3.Cookie"></a>3.Cookie</h2><h3 id="3-1-cookie简介"><a href="#3-1-cookie简介" class="headerlink" title="3.1 cookie简介"></a>3.1 cookie简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie其实就是客户端的一个缓存文件。里面记录了客户端(浏览器)访问网站的一些内容信息</span><br></pre></td></tr></table></figure><h3 id="3-2-Cookie属性"><a href="#3-2-Cookie属性" class="headerlink" title="3.2 Cookie属性"></a>3.2 Cookie属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name:cookie的名(必须的)</span><br><span class="line">value：cookie的值(必须的)；Cookie需要遵守RFC2109规范。这套规范规定了只能只用ASCII字符集中的值，所以不能使用中文</span><br><span class="line">comment:描述</span><br><span class="line">domain:域名</span><br><span class="line">maxAge:寿命。默认值为-1</span><br><span class="line">path:路径</span><br><span class="line">version:版本</span><br><span class="line"></span><br><span class="line">自学：cookie如何使用中文</span><br></pre></td></tr></table></figure><h3 id="3-3-Cookie的特性"><a href="#3-3-Cookie的特性" class="headerlink" title="3.3 Cookie的特性"></a>3.3 Cookie的特性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Cookie的大小和数量是有限制的。每个网站最多存储20个Cookie。并且最大不能超过4KB。</span><br><span class="line">2.针对整个浏览器来说所有的网站Cookie总数不能超过300个</span><br><span class="line">3.当不设置maxAge的时候，默认值为-1.此时存储Cookie使用的是浏览器内存，当关闭浏览器的时候Cookie就会丢失。和Session一起死亡。</span><br><span class="line">4.当设置了maxAge的时候，Cookie就会存储到磁盘中的一个缓存文件中。浏览器关闭不会影响Cookie的寿命</span><br></pre></td></tr></table></figure><h3 id="3-4-Cookie案例"><a href="#3-4-Cookie案例" class="headerlink" title="3.4 Cookie案例"></a>3.4 Cookie案例</h3><h4 id="3-4-1-一周免登录"><a href="#3-4-1-一周免登录" class="headerlink" title="3.4.1 一周免登录"></a>3.4.1 一周免登录</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;post&quot; action=&quot;$&#123;ctx&#125;/login&quot;&gt;</span><br><span class="line">  用户名:&lt;input type=&quot;text&quot; name=&quot;userName&quot; value=&quot;$&#123;userName&#125;&quot;&gt;&lt;br/&gt;</span><br><span class="line">  密码:&lt;input type=&quot;password&quot; name=&quot;userPassword&quot; value=&quot;$&#123;userPassword&#125;&quot;&gt;&lt;br/&gt;</span><br><span class="line">  &lt;input type=&quot;checkbox&quot; name=&quot;ck&quot;&gt;一周免登陆</span><br><span class="line">  &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;tologin&quot;</span> :</span><br><span class="line"><span class="comment">//获取cookie</span></span><br><span class="line">Cookie[] cookies = req.getCookies();</span><br><span class="line"><span class="keyword">if</span>(cookies!=<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cookie.getName().equals(<span class="string">&quot;userInfo&quot;</span>))&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cookie.getValue();</span><br><span class="line">            String[] info = value.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            req.setAttribute(<span class="string">&quot;userName&quot;</span>,info[<span class="number">0</span>]);</span><br><span class="line">            req.setAttribute(<span class="string">&quot;userPassword&quot;</span>,info[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">req.getRequestDispatcher(<span class="string">&quot;/jsp/login.jsp&quot;</span>).forward(req,resp);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;login&quot;</span> :</span><br><span class="line"><span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">userPassword</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;userPassword&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">0</span>, userName, userPassword);</span><br><span class="line"><span class="type">String</span> <span class="variable">ck</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;ck&quot;</span>);<span class="comment">//如果复选框被选中 返回的数据的 on</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> userService.login(user);</span><br><span class="line"><span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;on&quot;</span>.equals(ck))&#123;</span><br><span class="line">        <span class="comment">//创建Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;userInfo&quot;</span>, userName + <span class="string">&quot;-&quot;</span> + userPassword);</span><br><span class="line">        cookie.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">7</span>);</span><br><span class="line">        <span class="comment">//存储cookie</span></span><br><span class="line">        resp.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line">    resp.sendRedirect(<span class="string">&quot;findall&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    req.getRequestDispatcher(<span class="string">&quot;/jsp/login.jsp&quot;</span>).forward(req,resp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-HttpSession"><a href="#4-HttpSession" class="headerlink" title="4.HttpSession"></a>4.HttpSession</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.简介</span><br><span class="line">HttpSession其实就是一个服务端的会话对象。但是其本质还是一个Cookie(是一个特殊的cookie)，它是由服务器自动创建的一个Cookie。此Cookie的名字为JSESSIONID。值是服务器分配的唯一标识。</span><br><span class="line"></span><br><span class="line">当我们使用HttpSession的时候，只要浏览器本身没有禁用Cookie，那么请求就会JSESSIONID携带到服务器，服务器根据JSESSIONID的值获取对应的HttpSession对象。如果没有找到就会创建一个，多次请求携带的JSESSIONID都是同一个。并且此Cookie没有设置过期时间，所以浏览器关闭就消亡(也对应了Session的生命周期)</span><br><span class="line"></span><br><span class="line">2.HttpSession的钝化和活化</span><br><span class="line">钝化:持久化(把长久不使用但是又没有过期的HttpSession进行序列化到磁盘上)</span><br><span class="line">活化：反序列化</span><br><span class="line"></span><br><span class="line">钝化和活化的实际:不需要程序员操作。服务器自动完成。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-会话简介&quot;&gt;&lt;a href=&quot;#1-会话简介&quot; class=&quot;headerlink&quot; title=&quot;1.会话简介&quot;&gt;&lt;/a&gt;1.会话简介&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    <category term="笔记" scheme="http://www.sion-io.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://www.sion-io.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="http://www.sion-io.cn/2024/05/11/%E7%AC%94%E8%AE%B0/04-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>http://www.sion-io.cn/2024/05/11/%E7%AC%94%E8%AE%B0/04-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/</id>
    <published>2024-05-11T06:56:01.000Z</published>
    <updated>2024-05-12T08:19:51.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="过滤器和监听器"><a href="#过滤器和监听器" class="headerlink" title="过滤器和监听器"></a>过滤器和监听器</h1><h2 id="1-过滤器"><a href="#1-过滤器" class="headerlink" title="1.过滤器"></a>1.过滤器</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>过滤器就是Filter，是Java Web中的三大组件之一。另外两个组件是Servlet，Listener。<br>过滤器主要用于对web资源的访问进行拦截，并且在拦截后进行统一的处理。<br>应用场景:中文乱码问题，URL级别的权限问题。过滤敏感词汇问题。</p><h3 id="1-2-编写入门过滤器"><a href="#1-2-编写入门过滤器" class="headerlink" title="1.2 编写入门过滤器"></a>1.2 编写入门过滤器</h3><p>public class FilterDemo implements Filter {</p><pre><code>@Overridepublic void init(FilterConfig filterConfig) throws ServletException &#123;    //初始化方法&#125;@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;    System.out.println(&quot;拦截到了&quot;);    chain.doFilter(request,response);&#125;@Overridepublic void destroy() &#123;    //销毁的方法&#125;</code></pre><p>}</p><filter>    <filter-name>filedemo</filter-name>    <filter-class>com.lxk.filter.FilterDemo</filter-class></filter><filter-mapping>    <filter-name>filedemo</filter-name>    <!--对所有的请求进行拦截-->    <url-pattern>/*</url-pattern></filter-mapping><h3 id="1-3注解开发"><a href="#1-3注解开发" class="headerlink" title="1.3注解开发"></a>1.3注解开发</h3><p>@WebFilter(filterName &#x3D; “filedemo”,urlPatterns &#x3D; {“&#x2F;*”})<br>属性:<br>filterName:拦截器的名称<br>value:指定哪些请求交给过滤器拦截<br>urlPatterns:同上。但是两者不能同时配置<br>servletName:指定此过滤器作用于哪些Servlet<br>intParams:初始化参数<br>description：拦截器的描述</p><h3 id="1-4-生命周期"><a href="#1-4-生命周期" class="headerlink" title="1.4 生命周期"></a>1.4 生命周期</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当应用加载的时候执行过滤器的初始化和实例化。只要服务器提供服务此对象一直存在，当服务器宕机时过滤器对象也消亡。和Servlet一样都是单例的。</span><br></pre></td></tr></table></figure><h3 id="1-5-过滤器解决乱码问题"><a href="#1-5-过滤器解决乱码问题" class="headerlink" title="1.5 过滤器解决乱码问题"></a>1.5 过滤器解决乱码问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter(urlPatterns = &#123;&quot;/*&quot;&#125;,initParams = &#123;@WebInitParam(name = &quot;charset&quot;,value =&quot;UTF-8&quot;)&#125;)</span><br><span class="line">public class CharEncodingFilter implements Filter &#123;</span><br><span class="line">    String charset=null;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">        charset = filterConfig.getInitParameter(&quot;charset&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest)request;</span><br><span class="line">        HttpServletResponse resp = (HttpServletResponse)response;</span><br><span class="line">        req.setCharacterEncoding(charset);</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        resp.setCharacterEncoding(charset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-过滤器显示权限"><a href="#1-6-过滤器显示权限" class="headerlink" title="1.6 过滤器显示权限"></a>1.6 过滤器显示权限</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter(urlPatterns = &#123;&quot;/*&quot;&#125;)</span><br><span class="line">public class LoginFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">        //1.获取支持Http协议的两个对象</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest)request;</span><br><span class="line">        HttpServletResponse resp = (HttpServletResponse)response;</span><br><span class="line">        //2.获取请求的url</span><br><span class="line">        String uri = req.getRequestURI();</span><br><span class="line">        //3.获取请求后缀</span><br><span class="line">        //localhost:8080/项目名/tologin | login | fildall |add |update |Delete</span><br><span class="line">        String suffix = uri.substring(uri.lastIndexOf(&quot;/&quot;) + 1);</span><br><span class="line">        //4.根据后缀判断是否放行</span><br><span class="line">        if(&quot;login&quot;.equals(suffix) ||&quot;tologin&quot;.equals(suffix))&#123;</span><br><span class="line">            chain.doFilter(request,response);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //5.判断是否已经登录</span><br><span class="line">            String loginCode = (String)req.getSession().getAttribute(&quot;loginCode&quot;);</span><br><span class="line">            if(&quot;success&quot;.equals(loginCode))&#123;</span><br><span class="line">                //已经登录</span><br><span class="line">                chain.doFilter(request,response);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //既没登录也不是访问登录   不放行</span><br><span class="line">                resp.sendRedirect(&quot;tologin&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------</span><br><span class="line">登录方法中加入以下代码:</span><br><span class="line">req.getSession().setAttribute(&quot;loginCode&quot;,&quot;success&quot;); //登录成功的标识</span><br></pre></td></tr></table></figure><h2 id="2-监听器"><a href="#2-监听器" class="headerlink" title="2.监听器"></a>2.监听器</h2><h3 id="2-1-观察者模式"><a href="#2-1-观察者模式" class="headerlink" title="2.1 观察者模式"></a>2.1 观察者模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">观察者模式三元素:</span><br><span class="line">1.事件源:触发事件的对象</span><br><span class="line">2.事件:触发的动作</span><br><span class="line">3.监听器:当事假触发的时候所作的事情</span><br></pre></td></tr></table></figure><h3 id="2-2-Servlet中的监听器"><a href="#2-2-Servlet中的监听器" class="headerlink" title="2.2 Servlet中的监听器"></a>2.2 Servlet中的监听器</h3><h4 id="2-2-1-监听对象创建"><a href="#2-2-1-监听对象创建" class="headerlink" title="2.2.1 监听对象创建"></a>2.2.1 监听对象创建</h4><h5 id="2-2-1-1-ServletContextListener"><a href="#2-2-1-1-ServletContextListener" class="headerlink" title="2.2.1.1 ServletContextListener"></a>2.2.1.1 ServletContextListener</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">此监听器是用于监听ServletContext对象的创建以及销毁</span><br><span class="line">事件源:ServletContext对象</span><br><span class="line">事件:创建,销毁</span><br><span class="line">监听器源码:</span><br><span class="line">public interface ServletContextListener extends EventListener &#123;</span><br><span class="line">//ServletContext对象创建的时候执行的方法</span><br><span class="line">    public void contextInitialized(ServletContextEvent sce);</span><br><span class="line">    //ServletContext对象销毁的时候执行的方法</span><br><span class="line">    public void contextDestroyed(ServletContextEvent sce);</span><br><span class="line">&#125;</span><br><span class="line">案例:</span><br><span class="line">@WebListener</span><br><span class="line">public class ServletContextListenerImpl implements ServletContextListener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void contextInitialized(ServletContextEvent sce) &#123;</span><br><span class="line">        System.out.println(&quot;哥们的项目的启动&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextDestroyed(ServletContextEvent sce) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配置监听器生效</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">&lt;listener-class&gt;com.lxk.listener.ServletContextListenerImpl&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br><span class="line"></span><br><span class="line">注解生效</span><br><span class="line">@WebListener</span><br></pre></td></tr></table></figure><h5 id="2-2-1-2-HttpSessionListener"><a href="#2-2-1-2-HttpSessionListener" class="headerlink" title="2.2.1.2 HttpSessionListener"></a>2.2.1.2 HttpSessionListener</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">此监听器用于监听HttpSession对象的创建以及销毁</span><br><span class="line">源码:</span><br><span class="line">public interface HttpSessionListener extends EventListener &#123;</span><br><span class="line">//HttpSession对象创建的时候执行的方法</span><br><span class="line">    public void sessionCreated(HttpSessionEvent se);</span><br><span class="line">    //HttpSession对象销毁的时候执行的方法</span><br><span class="line">    public void sessionDestroyed(HttpSessionEvent se);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-1-3-ServletRequestListener"><a href="#2-2-1-3-ServletRequestListener" class="headerlink" title="2.2.1.3 ServletRequestListener"></a>2.2.1.3 ServletRequestListener</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">此监听器用于监听ServletRequest对象的创建以及销毁</span><br><span class="line">源码:</span><br><span class="line">public interface ServletRequestListener extends EventListener &#123;</span><br><span class="line">//ServletRequest对象销毁的时候执行的方法</span><br><span class="line">    public void requestDestroyed(ServletRequestEvent sre);</span><br><span class="line">//ServletRequest对象创建的时候执行的方法</span><br><span class="line">    public void requestInitialized(ServletRequestEvent sre);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-2-2-监听域中属性变化"><a href="#2-2-2-监听域中属性变化" class="headerlink" title="2.2.2 监听域中属性变化"></a>2.2.2 监听域中属性变化</h4><h5 id="2-2-2-1-ServletContextAttributeListener"><a href="#2-2-2-1-ServletContextAttributeListener" class="headerlink" title="2.2.2.1 ServletContextAttributeListener"></a>2.2.2.1 ServletContextAttributeListener</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">此监听器用于监听ServletContext中的属性发生改变</span><br><span class="line">源码:</span><br><span class="line">public interface ServletContextAttributeListener extends EventListener &#123;</span><br><span class="line">//当ServletContext对象执行了setAttribute(key,value)方法的时候执行</span><br><span class="line">    public void attributeAdded(ServletContextAttributeEvent event);</span><br><span class="line">//域中发生删除的时候执行此方法</span><br><span class="line">    public void attributeRemoved(ServletContextAttributeEvent event);</span><br><span class="line">//域中发生替换的时候执行此方法</span><br><span class="line">    public void attributeReplaced(ServletContextAttributeEvent event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-2-2-HttpSessionAttributeListener"><a href="#2-2-2-2-HttpSessionAttributeListener" class="headerlink" title="2.2.2.2 HttpSessionAttributeListener"></a>2.2.2.2 HttpSessionAttributeListener</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此监听器用于监听HttpSession中的属性发生改变</span><br></pre></td></tr></table></figure><h5 id="2-2-2-3-ServletRequestAttributeListener"><a href="#2-2-2-3-ServletRequestAttributeListener" class="headerlink" title="2.2.2.3 ServletRequestAttributeListener"></a>2.2.2.3 ServletRequestAttributeListener</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此监听器用于监听ServletRequest中的属性发生改变</span><br></pre></td></tr></table></figure><h4 id="2-2-3-感知型监听器"><a href="#2-2-3-感知型监听器" class="headerlink" title="2.2.3 感知型监听器"></a>2.2.3 感知型监听器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpSessionBindingListener：用于监听数据加入或者删除到session域</span><br><span class="line">HttpSessionActivationListener：用于感知会话域中对象的钝化和活化</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;过滤器和监听器&quot;&gt;&lt;a href=&quot;#过滤器和监听器&quot; class=&quot;headerlink&quot; title=&quot;过滤器和监听器&quot;&gt;&lt;/a&gt;过滤器和监听器&lt;/h1&gt;&lt;h2 id=&quot;1-过滤器&quot;&gt;&lt;a href=&quot;#1-过滤器&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="笔记" scheme="http://www.sion-io.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://www.sion-io.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>AJAX</title>
    <link href="http://www.sion-io.cn/2024/05/11/%E7%AC%94%E8%AE%B0/05-Ajax(1)/"/>
    <id>http://www.sion-io.cn/2024/05/11/%E7%AC%94%E8%AE%B0/05-Ajax(1)/</id>
    <published>2024-05-11T06:56:01.000Z</published>
    <updated>2024-05-12T08:19:51.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h2 id="1-Ajax简介"><a href="#1-Ajax简介" class="headerlink" title="1.Ajax简介"></a>1.Ajax简介</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ajax即Asynchronous Javascript And XML（异步JavaScript和XML），严格意义上来说并不是一种新技术，而是整合之前所学的技术用于实现动态网页。</span><br><span class="line"></span><br><span class="line">目前所学的请求和响应都是基于同步的。发送请求就必须重新加载整个页面。而Ajax通过浏览器和复位器进行少量的数据交互从而实现页面异步更新的效果。所谓的异步更新就是不需要加载整个页面，就可以对页面进行局部的更新。</span><br><span class="line"></span><br><span class="line">应用场景:注册查看用户名是否已经占用</span><br></pre></td></tr></table></figure><h2 id="2-Ajax应用"><a href="#2-Ajax应用" class="headerlink" title="2.Ajax应用"></a>2.Ajax应用</h2><h3 id="2-1-原生Ajax"><a href="#2-1-原生Ajax" class="headerlink" title="2.1 原生Ajax"></a>2.1 原生Ajax</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">userName4Reg</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">studentNumber</span> <span class="operator">=</span> userService.findByName(userName4Reg);</span><br><span class="line"><span class="keyword">if</span>(studentNumber&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    resp.getWriter().write(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    resp.getWriter().write(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;userName&quot;</span>).<span class="property">onblur</span>=<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//创建XMLHttpRequest</span></span><br><span class="line">        <span class="keyword">var</span> xmlHttpRequest = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        <span class="keyword">var</span> userName = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;userName&quot;</span>).<span class="property">value</span>;</span><br><span class="line">        xmlHttpRequest.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;userNameExists?userName=&quot;</span>+userName,<span class="literal">true</span>);</span><br><span class="line">        xmlHttpRequest.<span class="title function_">send</span>();</span><br><span class="line">        xmlHttpRequest.<span class="property">onreadystatechange</span>=<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(xmlHttpRequest.<span class="property">readyState</span>==<span class="number">4</span> &amp;&amp; xmlHttpRequest.<span class="property">status</span>==<span class="number">200</span>)&#123;</span><br><span class="line">                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;sp1&quot;</span>).<span class="property">innerText</span>=xmlHttpRequest.<span class="property">responseText</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">详解:</span><br><span class="line">核心对象:XMLHttpRequest：用于客户端和服务端的异步操作</span><br><span class="line">打开连接:open(method,url,async)</span><br><span class="line">method:请求方式;GET 或者 POST</span><br><span class="line">url:请求的路径</span><br><span class="line">async：本次请求是否异步</span><br><span class="line">发送请求:send(String param):</span><br><span class="line">param：请求的时候传递的参数(POST请求专用)</span><br><span class="line">处理响应:onreadystatechange(此函数就是用于处理响应结果)</span><br><span class="line">readyState(ajax的状态):</span><br><span class="line">0:请求没有初始化</span><br><span class="line">1:服务连接已经建立</span><br><span class="line">2:请求已经接收</span><br><span class="line">3.请求处理中</span><br><span class="line">4.请求已经完成并且响应已经就绪</span><br><span class="line">status（请求的状态码）：</span><br><span class="line">200:成功</span><br><span class="line">获取相应数据的方式:</span><br><span class="line">xmlHttpRequest.responseText:获取字符串类型的数据</span><br><span class="line">xmlHttpRequest.responseXML:获取XML类型的数据</span><br><span class="line">总结:不推荐使用</span><br></pre></td></tr></table></figure><h3 id="2-2-JQ的Ajax"><a href="#2-2-JQ的Ajax" class="headerlink" title="2.2 JQ的Ajax"></a>2.2 JQ的Ajax</h3><h4 id="2-2-1-Get方式Ajax"><a href="#2-2-1-Get方式Ajax" class="headerlink" title="2.2.1 Get方式Ajax"></a>2.2.1 Get方式Ajax</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法:</span><br><span class="line">$.get(url,[data],[callback],[type])</span><br><span class="line">url:请求的地址</span><br><span class="line">data：发送到服务器的数据，格式为key=value</span><br><span class="line">callback：请求成功后的回调函数(响应处理)</span><br><span class="line">type:预期的返回数据类型  xml,html.js,json,text</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;$&#123;ctx&#125;/js/jquery-3.3.1.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">userNameExists</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> userName =  $(<span class="string">&quot;#userName&quot;</span>).<span class="title function_">val</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $.<span class="title function_">get</span>(</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="string">&quot;userNameExists&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="string">&quot;userName=&quot;</span>+userName,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">function</span> (<span class="params">data</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            $(<span class="string">&quot;#sp1&quot;</span>).<span class="title function_">html</span>(data);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    );</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-Post方式Ajax"><a href="#2-2-2-Post方式Ajax" class="headerlink" title="2.2.2 Post方式Ajax"></a>2.2.2 Post方式Ajax</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法:</span><br><span class="line">$.post(url,[data],[callback],[type])</span><br><span class="line">url:请求的地址</span><br><span class="line">data：发送到服务器的数据，格式为key=value</span><br><span class="line">callback：请求成功后的回调函数(响应处理)</span><br><span class="line">type:预期的返回数据类型  xml,html.js,json,text</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">userNameExists</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> userName =  $(<span class="string">&quot;#userName&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">    $.<span class="title function_">post</span>(</span><br><span class="line">        <span class="string">&quot;userNameExists&quot;</span>,</span><br><span class="line">        <span class="string">&quot;userName=&quot;</span>+userName,</span><br><span class="line">        <span class="keyword">function</span> (<span class="params">data</span>)&#123;</span><br><span class="line">            $(<span class="string">&quot;#sp1&quot;</span>).<span class="title function_">html</span>(data);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;text&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-通用方式Ajax"><a href="#2-2-3-通用方式Ajax" class="headerlink" title="2.2.3 通用方式Ajax"></a>2.2.3 通用方式Ajax</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：$.ajax(&#123;key:value...&#125;)</span><br><span class="line">url:请求的地址</span><br><span class="line">async:是否异步(默认为true)</span><br><span class="line">data:请求的参数</span><br><span class="line">type:请求的方式</span><br><span class="line">success:请求成功后的回调函数</span><br><span class="line">error:请求失败后的回调函数</span><br><span class="line">dataType:预期返回的数据的类型</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">userNameExists</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> userName =  $(<span class="string">&quot;#userName&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;userNameExists&quot;</span>,</span><br><span class="line">        <span class="attr">async</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">data</span>: <span class="string">&quot;userName=&quot;</span>+userName,</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        <span class="attr">dataType</span>:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="attr">success</span>:<span class="keyword">function</span> (<span class="params">data</span>)&#123;</span><br><span class="line">            $(<span class="string">&quot;#sp1&quot;</span>).<span class="title function_">html</span>(data);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">error</span>:<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ajax error&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-JSON处理"><a href="#3-JSON处理" class="headerlink" title="3.JSON处理"></a>3.JSON处理</h2><h3 id="3-1-json简介"><a href="#3-1-json简介" class="headerlink" title="3.1 json简介"></a>3.1 json简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">json就是一种文件格式。主要用于数据的存储和表示，一般用于前后端分离的项目的数据交互。</span><br><span class="line">JSON格式:</span><br><span class="line">&#123;</span><br><span class="line">    key:value,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">[</span><br><span class="line">    &#123;key:value,</span><br><span class="line">    ...&#125;,</span><br><span class="line">    &#123;key:value,</span><br><span class="line">    ...&#125;,</span><br><span class="line">    &#123;key:value,</span><br><span class="line">    ...&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="3-2-JSON数据转换"><a href="#3-2-JSON数据转换" class="headerlink" title="3.2 JSON数据转换"></a>3.2 JSON数据转换</h3><p>对象和JSON转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student.setStudentId(<span class="number">1</span>);</span><br><span class="line">student.setStudentName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">student.setStudentGender(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">student.setStudentAge(<span class="number">18</span>);</span><br><span class="line">student.setStudentBirthday(<span class="string">&quot;2000-01-01&quot;</span>);</span><br><span class="line">student.setCardId(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//核心对象</span></span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> om.writeValueAsString(student); <span class="comment">//java对象转json</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> om.readValue(json,Student.calss); <span class="comment">//json转java对象</span></span><br></pre></td></tr></table></figure><p>list和json的转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> @Test</span><br><span class="line"> public void method01() throws Exception &#123;</span><br><span class="line">     List&lt;String&gt; list = Arrays.asList(&quot;张三&quot;, &quot;李四&quot;, &quot;王二&quot;);</span><br><span class="line">     ObjectMapper om = new ObjectMapper();</span><br><span class="line">     String json = om.writeValueAsString(list);</span><br><span class="line">     System.out.println(json);</span><br><span class="line">     ArrayList list1 = om.readValue(json, ArrayList.class);</span><br><span class="line">     list1.forEach(System.out::println);</span><br><span class="line"> &#125;</span><br><span class="line">上述代码是List中存储的是基本数据和String</span><br><span class="line">@Test</span><br><span class="line">public void method02() throws Exception &#123;</span><br><span class="line">    User user = new User(1, &quot;张三&quot;, &quot;1235&quot;);</span><br><span class="line">    User user2 = new User(2, &quot;李四&quot;, &quot;555&quot;);</span><br><span class="line">    List&lt;User&gt; list = Arrays.asList(user, user2);</span><br><span class="line">    ObjectMapper om = new ObjectMapper();</span><br><span class="line">    String json = om.writeValueAsString(list);</span><br><span class="line">    System.out.println(json);</span><br><span class="line">    ArrayList list2 = om.readValue(json, new TypeReference&lt;ArrayList&lt;User&gt;&gt;() &#123;&#125;);</span><br><span class="line">    list2.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">上述代码是List中存储的是引用数据类型</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ajax&quot;&gt;&lt;a href=&quot;#Ajax&quot; class=&quot;headerlink&quot; title=&quot;Ajax&quot;&gt;&lt;/a&gt;Ajax&lt;/h1&gt;&lt;h2 id=&quot;1-Ajax简介&quot;&gt;&lt;a href=&quot;#1-Ajax简介&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="笔记" scheme="http://www.sion-io.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://www.sion-io.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>css</title>
    <link href="http://www.sion-io.cn/2024/05/11/%E7%AC%94%E8%AE%B0/CSS(2)/"/>
    <id>http://www.sion-io.cn/2024/05/11/%E7%AC%94%E8%AE%B0/CSS(2)/</id>
    <published>2024-05-11T06:56:01.000Z</published>
    <updated>2024-05-12T08:19:51.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="1-CSS简介"><a href="#1-CSS简介" class="headerlink" title="1.CSS简介"></a>1.CSS简介</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CSS：层叠样式表</span><br><span class="line">CSS也是一种标记语言，用于给HTML的元素结构设置样式。样式:文字大小。颜色。宽高等等。</span><br><span class="line">总结一句话就是CSS就是用于美化HTML</span><br></pre></td></tr></table></figure><h2 id="2-CSS的编写位置"><a href="#2-CSS的编写位置" class="headerlink" title="2.CSS的编写位置"></a>2.CSS的编写位置</h2><h3 id="2-1-行内样式"><a href="#2-1-行内样式" class="headerlink" title="2.1  行内样式"></a>2.1  行内样式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">行内样式写在标签的style属性中。</span><br><span class="line">语法:</span><br><span class="line">&lt;标签 style=&quot;k:v;k2:v2&quot;&gt;&lt;/标签&gt;</span><br><span class="line">注意:style的属性值不能随便编写。需要遵守CSS的语法规范。就是k:v组成，多组样式之间用;隔开。</span><br><span class="line">案例:&lt;h1 style=&quot;font-size: 200px;color: red;&quot;&gt;这是H1的标签内容&lt;/h1&gt;</span><br><span class="line">缺点:</span><br><span class="line">1.书写繁琐并且不能复用</span><br><span class="line">2.违背了结构和样式分离的思想</span><br></pre></td></tr></table></figure><h3 id="2-2-内部样式"><a href="#2-2-内部样式" class="headerlink" title="2.2 内部样式"></a>2.2 内部样式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">内部样式写在html页面的内部。将所有的css代码独立的放在&lt;style&gt;标签</span><br><span class="line">案例:</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;/&gt;</span><br><span class="line">&lt;title&gt;网址的标题&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            p &#123;</span><br><span class="line">                font-size: 40px;</span><br><span class="line">                color: red;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt; </span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">        &lt;p&gt;这是H1的标签内容&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;这是H1的标签内容&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">注意:style标签理论上来说可以放在HTML文档的任意地方。但是一般放在&lt;head&gt;标签中</span><br><span class="line">缺点:</span><br><span class="line">1.多个HTML页面无法复用样式</span><br><span class="line">2.没完全实现结构和样式的分离</span><br></pre></td></tr></table></figure><h3 id="2-3-外部样式"><a href="#2-3-外部样式" class="headerlink" title="2.3 外部样式"></a>2.3 外部样式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">外部样式是一个独立的css文件。编写后由html文件进行引入使用</span><br><span class="line">语法:和内部样式没有区别，只是单独写在css文件中</span><br><span class="line">使用:</span><br><span class="line">1.编写css文件</span><br><span class="line">        p &#123;</span><br><span class="line">        font-size: 40px;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line">    2.引入使用</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./my.css&quot;&gt;</span><br><span class="line">注意:</span><br><span class="line">1.link写在&lt;head&gt;标签中</span><br><span class="line">2.href属性：引入css文件的位置</span><br><span class="line">3.rel属性:引入的文档与当前文档的关系</span><br><span class="line">4.可以触发浏览器的缓存机制，提高访问速度</span><br></pre></td></tr></table></figure><h3 id="2-4-样式的优先级"><a href="#2-4-样式的优先级" class="headerlink" title="2.4 样式的优先级"></a>2.4 样式的优先级</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">行内样式&gt;内部样式=外部样式</span><br><span class="line"></span><br><span class="line">针对于同一个标签设置了内部和外部一样。由于两者优先级一样。后设置会覆盖先设置的。</span><br></pre></td></tr></table></figure><h2 id="3-CSS语法规范"><a href="#3-CSS语法规范" class="headerlink" title="3.CSS语法规范"></a>3.CSS语法规范</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.核心组成部分</span><br><span class="line">CSS语法规范由两部分组成。</span><br><span class="line">选择器:找到要添加样式的元素</span><br><span class="line">声明块:设置具体的样式。声明的格式为: 属性名:属性值;</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">选择器 &#123;</span><br><span class="line">    属性名1: 属性值1;</span><br><span class="line">    属性名2: 属性值2;</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">1.最后一个声明块结尾的分号理论上可以省略，但是最好写上</span><br><span class="line">2.选择器和声明块之间，以及属性名和属性值之间均有一个空格。理论上可以省略，但是最好写上</span><br><span class="line"></span><br><span class="line">2.注释编写</span><br><span class="line">/* 注释内容 */</span><br><span class="line"></span><br><span class="line">3.代码风格</span><br><span class="line">展开风格：开发的时候使用，可阅读性强。便于修改和调试</span><br><span class="line">p &#123;</span><br><span class="line">        font-size: 40px;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line">紧凑风格：项目上线的时候进行使用。减少文件的体积</span><br><span class="line">p&#123;font-size: 40px;color: red;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-CSS选择器"><a href="#4-CSS选择器" class="headerlink" title="4.CSS选择器"></a>4.CSS选择器</h2><h3 id="4-1-基本选择器"><a href="#4-1-基本选择器" class="headerlink" title="4.1 基本选择器"></a>4.1 基本选择器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.通配选择器</span><br><span class="line">2.元素选择器</span><br><span class="line">3.类选择器</span><br><span class="line">4.id选择器</span><br></pre></td></tr></table></figure><h4 id="4-1-1-通配选择器"><a href="#4-1-1-通配选择器" class="headerlink" title="4.1.1 通配选择器"></a>4.1.1 通配选择器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">作用:可以选中所有的HTML元素</span><br><span class="line">语法:</span><br><span class="line">* &#123;</span><br><span class="line">    属性名: 属性值;</span><br><span class="line">&#125;</span><br><span class="line">注意:主要作用是清除浏览器的边距的差异，统一页面在各个浏览器的展示效果。</span><br></pre></td></tr></table></figure><h4 id="4-1-2-元素选择器"><a href="#4-1-2-元素选择器" class="headerlink" title="4.1.2 元素选择器"></a>4.1.2 元素选择器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">作用:选中HTML中某一种元素(标签选择器)</span><br><span class="line">语法:</span><br><span class="line">标签名 &#123;</span><br><span class="line">    属性名: 属性值;</span><br><span class="line">&#125;</span><br><span class="line">案例:</span><br><span class="line">p &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">&#125;</span><br><span class="line">div &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-类选择器"><a href="#4-1-3-类选择器" class="headerlink" title="4.1.3 类选择器"></a>4.1.3 类选择器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">作用:根据元素的class属性的值来选择元素</span><br><span class="line">语法:</span><br><span class="line">.类名 &#123;</span><br><span class="line">      属性名: 属性值;</span><br><span class="line">&#125;</span><br><span class="line">案例:</span><br><span class="line">&lt;p class=&quot;p1&quot;&gt;这是H1的标签内容&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;p1&quot;&gt;这是H1的标签内容&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;p2&quot;&gt;这是H1的标签内容&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">.p1 &#123;</span><br><span class="line">    font-size: 40px;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-4-ID选择器"><a href="#4-1-4-ID选择器" class="headerlink" title="4.1.4 ID选择器"></a>4.1.4 ID选择器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">作用:根据元素的id属性的值来选择元素</span><br><span class="line">语法:</span><br><span class="line">#id值 &#123;</span><br><span class="line">      属性名: 属性值;</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">1.id属性值尽量由字母，数字，下划线。段杠(-)组成。最好以字母开头。不要包含空格，并且区分大小写。</span><br><span class="line">2.一个元素只有一个id属性，多个元素的id值不能相同</span><br></pre></td></tr></table></figure><h3 id="4-2-复合选择器"><a href="#4-2-复合选择器" class="headerlink" title="4.2 复合选择器"></a>4.2 复合选择器</h3><h4 id="4-2-1-交集选择器"><a href="#4-2-1-交集选择器" class="headerlink" title="4.2.1 交集选择器"></a>4.2.1 交集选择器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">作用:选中同时符合多个条件的元素(多个选择器的集合)</span><br><span class="line">语法：选择器1选择器2...选择器n &#123;&#125;</span><br><span class="line">案例:</span><br><span class="line">/* 类名为p1的div标签*/</span><br><span class="line">div.p1 &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">注意：</span><br><span class="line">1.交集选择器中使用了标签选择器，那么标签选择器必须写在前面</span><br><span class="line">2.id选择器和通配选择器，理论上来说可以使用但是没有意义</span><br><span class="line">3.交集选择器中不能出现两个元素选择器。</span><br><span class="line">4.使用最多的交集选择器就是元素选择器搭配类选择器</span><br></pre></td></tr></table></figure><h4 id="4-2-2-并集选择器"><a href="#4-2-2-并集选择器" class="headerlink" title="4.2.2 并集选择器"></a>4.2.2 并集选择器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">作用:选中多个条件对应的元素(多个选择器的集合)</span><br><span class="line">语法：选择器1,选择器2,...选择器n &#123;&#125;</span><br><span class="line">案例:</span><br><span class="line">#username,</span><br><span class="line">.gender &#123;</span><br><span class="line">    font-size: 40px;</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">1.并集选择器中的多个选择器一般换行写</span><br><span class="line">2.任何选择器都可以为并集选择器中的一部分</span><br></pre></td></tr></table></figure><h4 id="4-2-3-元素的关系"><a href="#4-2-3-元素的关系" class="headerlink" title="4.2.3 元素的关系"></a>4.2.3 元素的关系</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">分类:</span><br><span class="line">1.父元素(也是祖先元素的一种):直接包含某个元素的元素，就是该元素的父元素</span><br><span class="line">2.子元素(也是后代元素的一种):被父元素直接包含的元素</span><br><span class="line">3.祖先元素:元素的上级元素都是祖先元素</span><br><span class="line">4.后代元素:元素的下级元素都是后代元素</span><br><span class="line">5.兄弟元素:具有相同父元素的元素，相互称之为兄弟元素</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-2-4-后代选择器"><a href="#4-2-4-后代选择器" class="headerlink" title="4.2.4 后代选择器"></a>4.2.4 后代选择器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法:选择器1 选择器2 ...选择器n &#123;&#125;</span><br><span class="line">案例:</span><br><span class="line">ul li &#123;</span><br><span class="line">    color: pink;</span><br><span class="line">&#125;</span><br><span class="line">ul li a &#123;</span><br><span class="line">    color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-5-子元素选择器"><a href="#4-2-5-子元素选择器" class="headerlink" title="4.2.5 子元素选择器"></a>4.2.5 子元素选择器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法:选择器1&gt;选择器2&gt; ...选择器n &#123;&#125;</span><br><span class="line">案例:</span><br><span class="line">div&gt;a &#123;       </span><br><span class="line">    color :red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#d1&gt;a&#123;</span><br><span class="line">    color :bule;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-6-兄弟选择器"><a href="#4-2-6-兄弟选择器" class="headerlink" title="4.2.6 兄弟选择器"></a>4.2.6 兄弟选择器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.相邻兄弟选择器</span><br><span class="line">语法:选择器1+选择器2 &#123;&#125;</span><br><span class="line">案例:</span><br><span class="line">/* div后相邻的兄弟p元素*/</span><br><span class="line">div+p &#123;</span><br><span class="line">    color :red;</span><br><span class="line">&#125;</span><br><span class="line">2.通用兄弟选择器</span><br><span class="line">语法：选择器1~选择器2 &#123;&#125;</span><br><span class="line">案例:</span><br><span class="line">/* div后所有的兄弟p元素*/</span><br><span class="line">div~p &#123;</span><br><span class="line">    color :red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意:上面两个选择器选中都是元素后的兄弟元素</span><br></pre></td></tr></table></figure><h3 id="4-3-属性选择器"><a href="#4-3-属性选择器" class="headerlink" title="4.3 属性选择器"></a>4.3 属性选择器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">作用:选中属性值符合一定要求的元素</span><br><span class="line">语法:</span><br><span class="line">[属性名]:选择具有某个属性的元素</span><br><span class="line">[属性名=&quot;值&quot;]:选择具有某个属性并且属性值等于指定值的元素</span><br><span class="line">[属性名^=&quot;值&quot;]:选择具有某个属性并且属性值以指定值开头的元素</span><br><span class="line">[属性名$=&quot;值&quot;]:选择具有某个属性并且属性值以指定值结尾的元素</span><br><span class="line">[属性名*=&quot;值&quot;]:选择具有某个属性并且属性值包含指定值的元素</span><br><span class="line">案例：</span><br><span class="line">input[name]&#123;&#125; ：选中具有name属性的input元素</span><br><span class="line">input[name=&quot;gender&quot;]&#123;&#125; ：选中具有name属性并且值为gender的input元素</span><br><span class="line">input[name^=&quot;g&quot;]&#123;&#125; ：选中具有name属性并且值以g开头的input元素</span><br><span class="line">input[name$=&quot;g&quot;]&#123;&#125; ：选中具有name属性并且值以g结尾的input元素</span><br><span class="line">input[name*=&quot;g&quot;]&#123;&#125; ：选中具有name属性并且值包含g的input元素</span><br></pre></td></tr></table></figure><h3 id="4-4-伪类选择器"><a href="#4-4-伪类选择器" class="headerlink" title="4.4 伪类选择器"></a>4.4 伪类选择器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">作用:选中特殊状态的元素</span><br></pre></td></tr></table></figure><h4 id="4-4-1-动态伪类选择器"><a href="#4-4-1-动态伪类选择器" class="headerlink" title="4.4.1 动态伪类选择器"></a>4.4.1 动态伪类选择器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">分类:</span><br><span class="line">:link：超链接没有被访问的状态</span><br><span class="line">:visited：超链接访问过的状态</span><br><span class="line">:hover: 鼠标悬停在元素上的状态</span><br><span class="line">:active: 元素激活的状态</span><br><span class="line"></span><br><span class="line">:focus : 获取焦点的元素(表单类的元素才能使用:focus伪类)</span><br></pre></td></tr></table></figure><h4 id="4-4-2-结构伪类选择器"><a href="#4-4-2-结构伪类选择器" class="headerlink" title="4.4.2 结构伪类选择器"></a>4.4.2 结构伪类选择器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:first-child 所有兄弟元素中的第一个</span><br><span class="line">:last-child 所有兄弟元素中的最后一个</span><br><span class="line">:nth-child(n) 所有兄弟元素中的第n个</span><br><span class="line"></span><br><span class="line">:first-of-type 所有同类型兄弟元素中的第一个</span><br><span class="line">:last-of-type 所有同类型兄弟元素中的最后一个</span><br><span class="line">:nth-of-type(n) 所有同类型兄弟元素中的第n个</span><br></pre></td></tr></table></figure><h2 id="5-CSS三大特性"><a href="#5-CSS三大特性" class="headerlink" title="5.CSS三大特性"></a>5.CSS三大特性</h2><h3 id="5-1-层叠性"><a href="#5-1-层叠性" class="headerlink" title="5.1 层叠性"></a>5.1 层叠性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义:如果发生了样式的冲突那么就会根据一定的规则(选择器的优先级:行内样式&gt;ID选择器&gt;类选择器&gt;元素选择器&gt;通配选择器)，进行样式的层叠(覆盖)。</span><br></pre></td></tr></table></figure><h3 id="5-2-继承性"><a href="#5-2-继承性" class="headerlink" title="5.2 继承性"></a>5.2 继承性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义:元素会自动拥有祖先元素上设置的某些样式</span><br><span class="line">继承规则：就近原则</span><br><span class="line">常见的可继承属性:</span><br><span class="line">text-xx , font-xx , line-xx , color</span><br></pre></td></tr></table></figure><h3 id="5-3-优先性"><a href="#5-3-优先性" class="headerlink" title="5.3 优先性"></a>5.3 优先性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">行内样式&gt;ID选择器&gt;类选择器&gt;元素选择器&gt;通配选择器&gt;继承的样式</span><br><span class="line"></span><br><span class="line">复合选择器的优先级需要计算权重(看视频)</span><br></pre></td></tr></table></figure><h2 id="6-CSS常用属性"><a href="#6-CSS常用属性" class="headerlink" title="6.CSS常用属性"></a>6.CSS常用属性</h2><h3 id="6-1-颜色的表达方式"><a href="#6-1-颜色的表达方式" class="headerlink" title="6.1 颜色的表达方式"></a>6.1 颜色的表达方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.颜色名</span><br><span class="line">color: red</span><br><span class="line">2.rgb/rgba</span><br><span class="line">r:红色</span><br><span class="line">g:绿色</span><br><span class="line">b:蓝色</span><br><span class="line">a:透明度</span><br><span class="line">color: rgb(255,0,0,50%) 红色</span><br><span class="line">color: rgb(0,0,0) 黑色</span><br><span class="line">color: rgb(255,255,255) 白色</span><br><span class="line"> 3.HEX/HEXA</span><br><span class="line"> 格式: rrggbb</span><br><span class="line"> color: #ff0000 红色</span><br><span class="line"> color: #f00 红色</span><br><span class="line"> IE浏览器支持HEX但是不支持HEXA</span><br></pre></td></tr></table></figure><h3 id="6-2-CSS字体属性"><a href="#6-2-CSS字体属性" class="headerlink" title="6.2 CSS字体属性"></a>6.2 CSS字体属性</h3><h4 id="6-2-1-字体大小"><a href="#6-2-1-字体大小" class="headerlink" title="6.2.1 字体大小"></a>6.2.1 字体大小</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">属性名:font-size</span><br><span class="line">作用:控制字体的大小</span><br><span class="line">语法：div&#123;font-size: 30px&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">1.chrome浏览器默认的字体16px。最小支持12px。设置成0px的字体会消失</span><br><span class="line">2.由于各个浏览器默认的字体大小是不一致的，所以一般最好给一个明确值。</span><br><span class="line">3.字体大小的明确值一般给body。这样的话其他元素就可以继承此属性</span><br></pre></td></tr></table></figure><h4 id="6-2-2-字体族"><a href="#6-2-2-字体族" class="headerlink" title="6.2.2 字体族"></a>6.2.2 字体族</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">属性名:font-family</span><br><span class="line">作用:控制字体类型</span><br><span class="line">语法:div&#123;font-family: &quot;Microsoft YaHei&quot;,serif&#125;</span><br><span class="line">注意:</span><br><span class="line">1.如果字体名包含空格，需要使用引号包含起来.</span><br><span class="line">2.windows默认的还就是微软雅黑</span><br><span class="line">3.可以同时设置多个字体。</span><br><span class="line">4.serif 衬线字体    sans-serif 非衬线字体</span><br></pre></td></tr></table></figure><h4 id="6-2-3-字体风格"><a href="#6-2-3-字体风格" class="headerlink" title="6.2.3 字体风格"></a>6.2.3 字体风格</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">属性名:font-style</span><br><span class="line">作用:控制字体是否为斜体</span><br><span class="line">语法:div&#123;font-style: normal&#125;</span><br><span class="line">常用值:</span><br><span class="line">normal:默认值，正常不斜体</span><br><span class="line">italic：斜体(使用字体本身的斜体效果)</span><br><span class="line">oblique：斜体(强制产生斜体效果) ：不推荐</span><br></pre></td></tr></table></figure><h4 id="6-2-4-字体粗细"><a href="#6-2-4-字体粗细" class="headerlink" title="6.2.4 字体粗细"></a>6.2.4 字体粗细</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属性名:font-weight</span><br><span class="line">作用:控制字体粗细</span><br><span class="line">语法:div&#123;font-weight: 属性值&#125;</span><br><span class="line">属性值:</span><br><span class="line">关键字: lighter：细  normal:正常 bold:粗 bolder:超粗(绝大部分字体不支持) </span><br><span class="line">数值: 100-1000并且没有单位。数值越大字体越粗</span><br></pre></td></tr></table></figure><h4 id="6-2-5-字体的复合写法"><a href="#6-2-5-字体的复合写法" class="headerlink" title="6.2.5 字体的复合写法"></a>6.2.5 字体的复合写法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">属性名:font</span><br><span class="line">作用:将上述四个属性编写在一起</span><br><span class="line">编写规则:</span><br><span class="line">1.字体大小和字体族必须写</span><br><span class="line">2.字体族必须在最后以为，字体大小必须在倒数第二位</span><br><span class="line">3.各个属性空空格隔开</span><br><span class="line">语法:div &#123;font: 20px  &quot;Microsoft YaHei&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-CSS文本属性"><a href="#6-3-CSS文本属性" class="headerlink" title="6.3 CSS文本属性"></a>6.3 CSS文本属性</h3><h4 id="6-3-1-文本颜色"><a href="#6-3-1-文本颜色" class="headerlink" title="6.3.1 文本颜色"></a>6.3.1 文本颜色</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">属性名color</span><br><span class="line">作用:控制文字的颜色</span><br><span class="line">语法:div&#123;font-weight: 属性值&#125;</span><br><span class="line">属性值:</span><br><span class="line">就是表达颜色的四种方式。常用的是rgb/HEX</span><br></pre></td></tr></table></figure><h4 id="6-3-2-文本间距"><a href="#6-3-2-文本间距" class="headerlink" title="6.3.2 文本间距"></a>6.3.2 文本间距</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">属性名:letter-spacing(字母间距) word-spacing(单词间距。通过空格识词)</span><br><span class="line">属性值:像素(px)。正值让间距增大。负值让间距缩小</span><br></pre></td></tr></table></figure><h4 id="6-3-3-文本修饰"><a href="#6-3-3-文本修饰" class="headerlink" title="6.3.3 文本修饰"></a>6.3.3 文本修饰</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">属性名:text-decoration</span><br><span class="line">作用:控制文本的各种装修线</span><br><span class="line">可选值:</span><br><span class="line">none：无装饰线(常用)</span><br><span class="line">underline：下划线</span><br><span class="line">overline:上划线</span><br><span class="line">line-through：删除线</span><br><span class="line">案例：text-decoration: underline wavy red;</span><br></pre></td></tr></table></figure><h4 id="6-3-4-文本缩进"><a href="#6-3-4-文本缩进" class="headerlink" title="6.3.4 文本缩进"></a>6.3.4 文本缩进</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">属性名:text-indent</span><br><span class="line">作用:控制文本首字母的缩进</span><br><span class="line">属性值:长度数值+单位</span><br></pre></td></tr></table></figure><h4 id="6-3-5-文本对齐-水平"><a href="#6-3-5-文本对齐-水平" class="headerlink" title="6.3.5 文本对齐-水平"></a>6.3.5 文本对齐-水平</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属性名:text-align</span><br><span class="line">作用:控制文本的水平对齐方式</span><br><span class="line">属性值:</span><br><span class="line">left：左对齐(默认值)</span><br><span class="line">right：右对齐</span><br><span class="line">center：居中对齐</span><br></pre></td></tr></table></figure><h4 id="6-3-6-行高"><a href="#6-3-6-行高" class="headerlink" title="6.3.6 行高"></a>6.3.6 行高</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属性名:line-heigeht</span><br><span class="line">作用:控制一行文字的高度</span><br><span class="line">属性值:</span><br><span class="line">1.normal：由浏览器根据字体大小自动决定的一个值</span><br><span class="line">2.像素(px)</span><br><span class="line">3.数字:font-size的倍数(最常用) 一般值都为1.5</span><br></pre></td></tr></table></figure><h4 id="6-3-7-文本对齐-垂直"><a href="#6-3-7-文本对齐-垂直" class="headerlink" title="6.3.7 文本对齐-垂直"></a>6.3.7 文本对齐-垂直</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.顶部:不需要任何设置 默认就是</span><br><span class="line">2.居中:height=line-heigeht值</span><br><span class="line">3.底部:line-heigeht = (height*2)-font-size-x</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">属性名:vertical-align</span><br><span class="line">作用:用于指定同一行元素之间或者表格单元格内的文字的垂直对齐方式</span><br><span class="line">属性值:</span><br><span class="line">baseline:默认值。元素的基线和父元素的基线对齐</span><br><span class="line">top:元素顶部和所在行的顶部对齐</span><br><span class="line">middle:居中对齐</span><br><span class="line">bottom元素底部和所在行的底部对齐</span><br><span class="line">注意:此属性不能控制块元素</span><br></pre></td></tr></table></figure><h3 id="6-4-CSS列表属性"><a href="#6-4-CSS列表属性" class="headerlink" title="6.4 CSS列表属性"></a>6.4 CSS列表属性</h3><h4 id="6-4-1-列表符号"><a href="#6-4-1-列表符号" class="headerlink" title="6.4.1 列表符号"></a>6.4.1 列表符号</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">属性名:list-style-type</span><br><span class="line">作用:设置列表符号</span><br><span class="line">属性值:</span><br><span class="line">none:不显示前面的标识</span><br><span class="line">disc:圆形</span><br><span class="line">square：实心方块</span><br><span class="line">decimal：数字</span><br><span class="line">lower-roman：小写罗马字</span><br><span class="line">upper-roman：大写罗马字</span><br><span class="line">lower-alpha：小写英文字母</span><br><span class="line">upper-alpha：大写英文字母</span><br></pre></td></tr></table></figure><h4 id="6-4-2-符号位置"><a href="#6-4-2-符号位置" class="headerlink" title="6.4.2 符号位置"></a>6.4.2 符号位置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">属性名:list-style-position</span><br><span class="line">作用:设置列表符号的位置</span><br><span class="line">属性值:</span><br><span class="line">inside:在li的里面</span><br><span class="line">outside:在li的外面</span><br></pre></td></tr></table></figure><h4 id="6-4-3-自定义列表符号"><a href="#6-4-3-自定义列表符号" class="headerlink" title="6.4.3 自定义列表符号"></a>6.4.3 自定义列表符号</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">属性名:list-style-image</span><br><span class="line">作用:自定义列表符号</span><br><span class="line">属性值: url(图片位置)</span><br></pre></td></tr></table></figure><h4 id="6-4-4-符合写法"><a href="#6-4-4-符合写法" class="headerlink" title="6.4.4 符合写法"></a>6.4.4 符合写法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">属性名:list-styl</span><br><span class="line">特点:没有数量和顺序的要求</span><br></pre></td></tr></table></figure><h3 id="6-5-CSS表格属性"><a href="#6-5-CSS表格属性" class="headerlink" title="6.5 CSS表格属性"></a>6.5 CSS表格属性</h3><h4 id="6-5-1-边框属性-非表格专属"><a href="#6-5-1-边框属性-非表格专属" class="headerlink" title="6.5.1 边框属性(非表格专属)"></a>6.5.1 边框属性(非表格专属)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">属性名:border-width，border-color，border-style</span><br><span class="line">作用:设置表格边框的宽度，颜色，样式</span><br><span class="line">属性值：</span><br><span class="line">border-width：像素值</span><br><span class="line">border-color：具体的颜色值</span><br><span class="line">border-style：</span><br><span class="line">none:默认值。</span><br><span class="line">solid：实线</span><br><span class="line">dashed：虚线</span><br><span class="line">dotted：点线</span><br><span class="line">double：双实线</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">属性名:border（复合属性）</span><br><span class="line">属性值:没有顺序和数量要求</span><br><span class="line"></span><br><span class="line">注意:此属性不光表格可以其他使用。 其他元素也可以使用</span><br></pre></td></tr></table></figure><h4 id="6-5-2-表格专属属性"><a href="#6-5-2-表格专属属性" class="headerlink" title="6.5.2 表格专属属性"></a>6.5.2 表格专属属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">属性名:table-layout</span><br><span class="line">作用:设置列的宽度</span><br><span class="line">属性值:</span><br><span class="line">auto:自动</span><br><span class="line">具体的列宽</span><br><span class="line"></span><br><span class="line">属性名:border-spacing</span><br><span class="line">作用:设置单元格的间距</span><br><span class="line">属性值:css长度值+单位</span><br><span class="line"></span><br><span class="line">属性名:empty-cells</span><br><span class="line">作用：是否隐藏没有内容的单元格</span><br><span class="line">属性值: hide(隐藏) show(展示，默认值)</span><br><span class="line"></span><br><span class="line">注意:以上三个属性只能在table中使用</span><br></pre></td></tr></table></figure><h3 id="6-6-CSS背景属性"><a href="#6-6-CSS背景属性" class="headerlink" title="6.6 CSS背景属性"></a>6.6 CSS背景属性</h3><h4 id="6-6-1-背景颜色"><a href="#6-6-1-背景颜色" class="headerlink" title="6.6.1 背景颜色"></a>6.6.1 背景颜色</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">属性名:background-color</span><br><span class="line">作用:设置背景颜色</span><br><span class="line">属性值:符合css规范的颜色</span><br></pre></td></tr></table></figure><h4 id="6-6-2-背景图片"><a href="#6-6-2-背景图片" class="headerlink" title="6.6.2 背景图片"></a>6.6.2 背景图片</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">属性名:background-image</span><br><span class="line">作用:设置背景图片</span><br><span class="line">属性值:url(图片的地址)</span><br></pre></td></tr></table></figure><h4 id="6-6-3-背景重复方式"><a href="#6-6-3-背景重复方式" class="headerlink" title="6.6.3 背景重复方式"></a>6.6.3 背景重复方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">属性名:background-repeat</span><br><span class="line">作用:设置背景图片重复的方式</span><br><span class="line">属性值:</span><br><span class="line">repeat:重复铺满。默认值</span><br><span class="line">no-repeat:不重复</span><br><span class="line">repeat-x:水平重复</span><br><span class="line">repeat-y:垂直重复</span><br></pre></td></tr></table></figure><h4 id="6-6-4-背景图片位置"><a href="#6-6-4-背景图片位置" class="headerlink" title="6.6.4 背景图片位置"></a>6.6.4 背景图片位置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属性名:background-position</span><br><span class="line">作用:设置背景图片位置</span><br><span class="line">属性值:由两个值组成，水平 垂直</span><br><span class="line">水平:left center right</span><br><span class="line">垂直:top center bottom</span><br><span class="line">也可以通过两个数值来进行设置，分别代表x坐标和y坐标</span><br></pre></td></tr></table></figure><h4 id="6-6-5-复合属性"><a href="#6-6-5-复合属性" class="headerlink" title="6.6.5 复合属性"></a>6.6.5 复合属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">属性名:background</span><br><span class="line">属性值:没有数量和顺序的要求</span><br></pre></td></tr></table></figure><h2 id="7-CSS盒子模型"><a href="#7-CSS盒子模型" class="headerlink" title="7.CSS盒子模型"></a>7.CSS盒子模型</h2><h3 id="7-1-元素显示模式"><a href="#7-1-元素显示模式" class="headerlink" title="7.1 元素显示模式"></a>7.1 元素显示模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">块元素:</span><br><span class="line">1.在页面中独占一行.</span><br><span class="line">2.默认宽度是撑满父元素的</span><br><span class="line">3.默认的高度是由内容撑开</span><br><span class="line">4.可以通过CSS设置宽高</span><br><span class="line">行内元素：</span><br><span class="line">1.在页面中不会独占一行。一行内无法容纳行内元素则会在下一行继续展示</span><br><span class="line">2.默认宽度由内容撑开</span><br><span class="line">3.默认高度由内容撑开</span><br><span class="line">4.无法通过CSS设置宽高</span><br><span class="line">行内块元素:</span><br><span class="line">1.在页面中不会独占一行。一行内无法容纳行内元素则会在下一行继续展示</span><br><span class="line">2.默认宽度由内容撑开</span><br><span class="line">3.默认高度由内容撑开</span><br><span class="line">4.可以通过CSS设置宽高</span><br><span class="line">注意:早起区别元素只有一个条件，是否独占一行。所以行内块元素早起属于行内元素。</span><br><span class="line"></span><br><span class="line">块元素(block):</span><br><span class="line">1.主题结构标签:html body</span><br><span class="line">2.排版标签:h1-h6 hr p pre div</span><br><span class="line">3.列表标签:ul ol li dl dt dd</span><br><span class="line">4.表单标签:form option</span><br><span class="line">5.表格标签:table tbody thead tfoot tr </span><br><span class="line">行内元素(inline):</span><br><span class="line">1.文本标签:br span em strong ...</span><br><span class="line">2.特殊标签:a label</span><br><span class="line">行内块元素(inline-block):</span><br><span class="line">1.图片:img</span><br><span class="line">2.单元格:td th</span><br><span class="line">3.表单控件:input select button textarea</span><br><span class="line">4.框架标签: iframe</span><br></pre></td></tr></table></figure><h3 id="7-2-显示模式修改"><a href="#7-2-显示模式修改" class="headerlink" title="7.2 显示模式修改"></a>7.2 显示模式修改</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">属性名:display</span><br><span class="line">作用:修改标签的显示模式</span><br><span class="line">属性值:</span><br><span class="line">none：元素会被隐藏</span><br><span class="line">block:元素作为块级元素显示</span><br><span class="line">inline:元素作为行级元素显示</span><br><span class="line">inline-block:元素作为行内块级元素显示</span><br></pre></td></tr></table></figure><h3 id="7-3-盒子模型的组成部分"><a href="#7-3-盒子模型的组成部分" class="headerlink" title="7.3 盒子模型的组成部分"></a>7.3 盒子模型的组成部分</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">盒子模型由以下四部分组成:</span><br><span class="line">margin(外边距)：盒子与外界的距离</span><br><span class="line">border(边框):盒子的边框</span><br><span class="line">padding(内边距):紧贴内容的补白区域</span><br><span class="line">content(内容):元素中的文本或者其后代元素的内容</span><br><span class="line"></span><br><span class="line">盒子大小:内容+左右内边距+左右的边框</span><br><span class="line">外边距不会影响盒子的大小，但是会影响盒子的位置</span><br><span class="line"></span><br><span class="line">图片:https://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%20css&amp;step_word=&amp;hs=0&amp;pn=1&amp;spn=0&amp;di=7308398814245683201&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0%2C0&amp;istype=2&amp;ie=utf-8&amp;oe=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=-1&amp;cs=3204025573%2C765940591&amp;os=4190189360%2C3265744688&amp;simid=3204025573%2C765940591&amp;adpicid=0&amp;lpn=0&amp;ln=1591&amp;fr=&amp;fmq=1712650489514_R&amp;fm=result&amp;ic=&amp;s=undefined&amp;hd=&amp;latest=&amp;copyright=&amp;se=&amp;sme=&amp;tab=0&amp;width=&amp;height=&amp;face=undefined&amp;ist=&amp;jit=&amp;cg=&amp;bdtype=0&amp;oriquery=&amp;objurl=https%3A%2F%2Fwww.edrawsoft.cn%2Fwp%2Fwp-content%2Fuploads%2F2020%2F10%2FCSShezimoxingssma.png&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z%26e3Bj16wof5up_z%26e3BvgAzdH3Fviw6pAzdH3FCSSijzt45xtg2ff4w&amp;gsm=1e&amp;rpstart=0&amp;rpnum=0&amp;islist=&amp;querylist=&amp;nojc=undefined&amp;dyTabStr=MCwzLDEsMiw2LDQsNSw3LDgsOQ%3D%3D&amp;lid=10759007594805456681</span><br></pre></td></tr></table></figure><h3 id="7-4-盒子内容区的属性"><a href="#7-4-盒子内容区的属性" class="headerlink" title="7.4 盒子内容区的属性"></a>7.4 盒子内容区的属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width:设置内容区域的宽度</span><br><span class="line">height:设置内容区域的高度</span><br></pre></td></tr></table></figure><h3 id="7-5-盒子内边距的属性"><a href="#7-5-盒子内边距的属性" class="headerlink" title="7.5 盒子内边距的属性"></a>7.5 盒子内边距的属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">padding-top:上内边距</span><br><span class="line">padding-right:右内边距</span><br><span class="line">padding-bottom:下内边距</span><br><span class="line">padding-left:左内边距</span><br><span class="line">padding:可以设置1-4个值。</span><br><span class="line">例如: padding: 10px; 四个方向的内边距都是10px</span><br><span class="line"> padding: 10px 20px; 上下10px  左右20px</span><br><span class="line"> padding: 10px 20px 30px; 上10px 左右20px  下30px</span><br><span class="line">     padding: 10px 20px 30px 40px; 上右下左</span><br><span class="line">注意:</span><br><span class="line">1.padding的值不能为负数</span><br><span class="line">2.行内元素左右内边距完美设置，但是上下内边距不能完美设置</span><br><span class="line">3.块级元素和行内块级元素四个方向都可以完美设置</span><br></pre></td></tr></table></figure><h3 id="7-6-盒子边框属性"><a href="#7-6-盒子边框属性" class="headerlink" title="7.6 盒子边框属性"></a>7.6 盒子边框属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">属性名:border-width，border-color，border-style</span><br><span class="line">作用:设置表格边框的宽度，颜色，样式</span><br><span class="line">属性值：</span><br><span class="line">border-width：像素值(默认值为3px)</span><br><span class="line">border-color：具体的颜色值(默认值为黑色)</span><br><span class="line">border-style：</span><br><span class="line">none:默认值。</span><br><span class="line">solid：实线</span><br><span class="line">dashed：虚线</span><br><span class="line">dotted：点线</span><br><span class="line">double：双实线</span><br><span class="line">属性名:border（复合属性）</span><br><span class="line">属性值:没有顺序和数量要求</span><br><span class="line"></span><br><span class="line">同时还具备以下属性:</span><br><span class="line">border-left-style,border-right-style,border-bottom-style,border-top-style</span><br><span class="line">同时其他三个属性同理</span><br></pre></td></tr></table></figure><h3 id="7-7-盒子外边距属性"><a href="#7-7-盒子外边距属性" class="headerlink" title="7.7 盒子外边距属性"></a>7.7 盒子外边距属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">margin-left：左外边距</span><br><span class="line">margin-right：右外边距</span><br><span class="line">margin-top:上外边距</span><br><span class="line">margin-bottom：下外边距</span><br><span class="line">margin：和padding一样都可以设置1-4个值。设置规则也一致</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">1.行内元素左右外边距完美设置，但是上下外边距无法设置</span><br><span class="line">2.块级元素和行内块级元素四个方向都可以完美设置</span><br><span class="line">3.上和左会影响到自己的位置，右和下会影响到后面兄弟元素的位置</span><br><span class="line">4.块级元素设置左右为auto，那么该块级元素会在父元素中水平居中</span><br><span class="line">5.margin的属性自可以为负数</span><br></pre></td></tr></table></figure><h3 id="7-8-内容溢出属性"><a href="#7-8-内容溢出属性" class="headerlink" title="7.8 内容溢出属性"></a>7.8 内容溢出属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">属性名:overflow</span><br><span class="line">作用：溢出内容的处理方式</span><br><span class="line">属性值:</span><br><span class="line">visible：默认(默认值)</span><br><span class="line">hidden:隐藏</span><br><span class="line">scroll:显示滚动条(不管内容是否溢出都显示)</span><br><span class="line">auto:自动显示滚动条(内容溢出了才显示)</span><br><span class="line">属性名:overflow-x； 属性值同上</span><br><span class="line">属性名:overflow-y； 属性值同上</span><br></pre></td></tr></table></figure><h3 id="7-9-样式的继承区别"><a href="#7-9-样式的继承区别" class="headerlink" title="7.9 样式的继承区别"></a>7.9 样式的继承区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">能继承:字体属性，文本属性，字体颜色</span><br><span class="line">不能继承:边框，背景，内外边距，宽高，溢出方式</span><br><span class="line"></span><br><span class="line">继承样式只需要记住一个规则:不影响布局的都可以继承。影响布局的都不可以。</span><br></pre></td></tr></table></figure><h2 id="8-浮动"><a href="#8-浮动" class="headerlink" title="8.浮动"></a>8.浮动</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">属性名:float</span><br><span class="line">作用:设置浮动</span><br><span class="line">属性值:</span><br><span class="line">left:设置左浮动</span><br><span class="line">right:设置右浮动</span><br><span class="line">none:不浮动(默认值)</span><br><span class="line"></span><br><span class="line">属性名:clear</span><br><span class="line">作用:清楚情面兄弟元素浮动的影响</span><br><span class="line">属性值:</span><br><span class="line">left:清理前面左浮动影响</span><br><span class="line">right:清理前面右浮动影响</span><br><span class="line">both:清理前面左后浮动影响</span><br></pre></td></tr></table></figure><h2 id="9-定位"><a href="#9-定位" class="headerlink" title="9.定位"></a>9.定位</h2><h3 id="9-1-相对定位"><a href="#9-1-相对定位" class="headerlink" title="9.1 相对定位"></a>9.1 相对定位</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">属性名:position: relative</span><br><span class="line">属性名:通过left right top botttom四个属性调整位置。 left:20px;向右移动20px 其他同理</span><br></pre></td></tr></table></figure><h3 id="9-2-绝对定位"><a href="#9-2-绝对定位" class="headerlink" title="9.2 绝对定位"></a>9.2 绝对定位</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">属性名:position: absolute</span><br><span class="line">属性名:通过left right top botttom四个属性调整位置。 left:20px;向右移动20px 其他同理</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS&quot;&gt;&lt;a href=&quot;#CSS&quot; class=&quot;headerlink&quot; title=&quot;CSS&quot;&gt;&lt;/a&gt;CSS&lt;/h1&gt;&lt;h2 id=&quot;1-CSS简介&quot;&gt;&lt;a href=&quot;#1-CSS简介&quot; class=&quot;headerlink&quot; title=&quot;1.CSS简介</summary>
      
    
    
    
    <category term="笔记" scheme="http://www.sion-io.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="前端" scheme="http://www.sion-io.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
